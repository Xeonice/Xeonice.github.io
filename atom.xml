<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helve&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.douglasdong.site/"/>
  <updated>2018-08-11T07:30:12.354Z</updated>
  <id>https://www.douglasdong.site/</id>
  
  <author>
    <name>Helvetica.D</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>this、apply、call、bind</title>
    <link href="https://www.douglasdong.site/2018-08-08.html"/>
    <id>https://www.douglasdong.site/2018-08-08.html</id>
    <published>2018-08-08T06:44:52.000Z</published>
    <updated>2018-08-11T07:30:12.354Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>ES5 中，<code>this</code> 的指向始终坚持一个原理：<strong><code>this 永远指向最后调用它的那个对象</code></strong></p><p>下面来看一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="string">"Cherry"</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//windowsName</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"inner: "</span> + <span class="keyword">this</span>); <span class="comment">//inner: Window</span></div><div class="line">&#125;</div><div class="line">a();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"outer: "</span> + <span class="keyword">this</span>); <span class="comment">//outer: Window</span></div></pre></td></tr></table></figure><p>根据刚刚那句话 <strong><code>this 永远指向最后调用它的那个对象</code></strong>，我们再看看最后调用 <code>a</code> 的地方 <code>a();</code>，前面没有调用的对象，那么就是全局对象 <code>Window</code>。这就相当于是 <code>window.a</code></p><p>注意，我们在这里没有使用严格模式，如果使用严格模式，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError：Cannot read property &#39;name&#39; of undefined</code></p><p>再看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name: <span class="string">"Cherry"</span>;</div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Cherry</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a.fn();</div></pre></td></tr></table></figure><p>这个例子中，函数 <code>fn</code> 是对象 <code>a</code> 调用的，所以打印的值就是 <code>a</code> 中的 <code>name</code> 值</p><p>我们做一个小小的改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name: <span class="string">"Cherry"</span>;</div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Cherry</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.a.fn();</div></pre></td></tr></table></figure><p>这里打印出 Cherry 的原因还是因为刚刚那句话：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，最后调用它的还是对象 <code>a</code></p><p>我们再来看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    <span class="comment">//name: "Cherry";</span></div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//undefined</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.a.fn();</div></pre></td></tr></table></figure><p>这里打印 <code>undefined</code> 的原因在于：调用 <code>fn</code> 的是对象 <code>a</code>，也就是说 <code>fn</code> 内部的 <code>this</code> 是对象 <code>a</code>，而对象 <code>a</code> 中并没有对 <code>name</code> 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code></p><p>这个例子还是说明了：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，因为最后调用的对象是 <code>a</code>，所以就算 <code>a</code> 中没有 <code>name</code> 这个属性，也不会继续向上个对象寻找 <code>this.name</code>，而是直接输出 <code>undefined</code></p><a id="more"></a><p>再来看一个比较坑的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name: <span class="string">"Cherry"</span>,</div><div class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//windowsName</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f = a.fn();</div><div class="line">f();</div></pre></td></tr></table></figure><p>这里你可能会有疑问，为什么不是 <code>Cherry</code>？这是因为虽然将 <code>a</code> 对象的 <code>fn</code> 方法赋给变量 <code>f</code> 了，但是没有调用，<strong><code>this 永远指向最后调用它的那个对象</code></strong>，由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <code>window</code> 调用的，所以 <code>this</code> 指向的也就是 <code>window</code></p><p>由以上五个例子可以看出，<code>this</code> 的指向并不是在创建的时候就可以确定的，在 ES5 中，<strong><code>this 永远指向最后调用它的那个对象</code></strong></p><p>再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</div><div class="line">    innerFunction();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn()</div></pre></td></tr></table></figure><p>现在应该能够理解其中的缘由了吧~~</p><h1 id="怎么改变-this-的指向？"><a href="#怎么改变-this-的指向？" class="headerlink" title="怎么改变 this 的指向？"></a>怎么改变 this 的指向？</h1><p>改变 this 的指向总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li><code>new</code> 实例化一个对象</li></ul><p>例7：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name = <span class="string">'Cherry'</span>,</div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></div><div class="line">    &#125;</div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1();</div><div class="line">        &#125;, <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2();  <span class="comment">//this.func1 is not a function</span></div></pre></td></tr></table></figure><p>在不使用箭头函数的情况下，是会报错的，因为最后调用 <code>setTimeout</code> 的对象是 <code>Window</code>，但是在 <code>window</code> 中并没有 <code>func1</code> 函数</p><p>我们在改变 <code>this</code> 指向将把这个例子作为 demo 进行改造</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 中的箭头函数是可以避免 ES5 中使用 <code>this</code> 的坑的，箭头函数的 <code>this</code> 始终指向函数定义时的 <code>this</code>，而非执行时。箭头函数需要记着这句话：<strong>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。</strong></p><p>例8：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name = <span class="string">'Cherry'</span>,</div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></div><div class="line">    &#125;</div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.func1();</div><div class="line">        &#125;, <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2();  <span class="comment">//Cherry</span></div></pre></td></tr></table></figure><h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了。我们是先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name = <span class="string">'Cherry'</span>,</div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></div><div class="line">    &#125;</div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span></div><div class="line">        setTimeout(<span class="function"><span class="keyword">function</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1();</div><div class="line">        &#125;, <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2();  <span class="comment">//Cherry</span></div></pre></td></tr></table></figure><p>这个例子中，在 <code>func2</code> 中，首先设置 <code>var _this = this</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 <code>a</code>，为了防止在 <code>func2</code> 中的 <code>setTimeout</code> 被 <code>Window</code> 调用而导致的在 <code>setTimeout</code> 中的 <code>this</code> 为 <code>Window</code>，我们将 <code>this</code> 先赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 <code>a</code> 了。</p><h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 <code>apply</code>、<code>call</code>、<code>bind</code> 函数也是可以改变 <code>this</code> 的指向的，我们先看看如何实现</p><h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply"></a>使用 apply</h3><p>例10：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name : <span class="string">"Cherry"</span>,</div><div class="line"></div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1()</div><div class="line">        &#125;.apply(a),<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2()            <span class="comment">// Cherry</span></div></pre></td></tr></table></figure><h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call"></a>使用 call</h3><p>例11：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name : <span class="string">"Cherry"</span>,</div><div class="line"></div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1()</div><div class="line">        &#125;.call(a),<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2()            <span class="comment">// Cherry</span></div></pre></td></tr></table></figure><h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind"></a>使用 bind</h3><p>例12：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name : <span class="string">"Cherry"</span>,</div><div class="line"></div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1()</div><div class="line">        &#125;.bind(a)(),<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2()            <span class="comment">// Cherry</span></div></pre></td></tr></table></figure><h2 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h2><p><code>apply</code>、<code>call</code>、<code>bind</code> 都是能够改变 <code>this</code> 指向的，但是这三个函数略有不同</p><p>MDN 中对 <code>apply</code> 定义如下：</p><blockquote><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><p>语法：</p><blockquote><p>fun.apply(thisArg, [argsArray])</p></blockquote><ul><li><p><code>thisArg</code>：在 <code>fun</code> 函数运行时指定的 <code>this</code> 值。需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动指向全局对象（浏览器中就是 <code>window对象</code>），同时值为原始值（数字，字符串，布尔值）的 <code>this</code> 会指向该原始值的自动包装对象。</p></li><li><p><code>argsArray</code>：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>fun</code> 函数。如果该参数的值为 <code>null</code> 或 <code>undefined</code>，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。</p></li></ul><h3 id="apply-和-call-区别"><a href="#apply-和-call-区别" class="headerlink" title="apply 和 call 区别"></a>apply 和 call 区别</h3><p><code>apply</code> 和 <code>call</code> 的区别是 <code>call</code> 方法接受的是若干个参数列表，而 <code>apply</code> 接收的是一个包含多个参数的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">b.apply(a,[<span class="number">1</span>,<span class="number">2</span>])     <span class="comment">// 3</span></div><div class="line">b.call(a,<span class="number">1</span>,<span class="number">2</span>)       <span class="comment">// 3</span></div></pre></td></tr></table></figure><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p>将前面的示例用 <code>bind</code> 尝试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a =&#123;</div><div class="line">    name : <span class="string">"Cherry"</span>,</div><div class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log( a + b)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> b = a.fn;</div><div class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)；</div></pre></td></tr></table></figure><p>会发现并没有输出，这是为什么呢？我们来看看 MDN 文档说明：</p><blockquote><p><code>bind()</code> 方法创建一个新的函数, 当被调用时，将其 <code>this</code> 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>简单一点来说，就是 <code>bind()</code> 仅仅创建了一个新的函数，我们需要手动去调用</p><h1 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h1><p>函数调用的方法一共有四种</p><ul><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ul><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>如之前的例1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);          <span class="comment">// windowsName</span></div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);    <span class="comment">// inner: Window</span></div><div class="line">&#125;</div><div class="line">a();</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>)         <span class="comment">// outer: Window</span></div></pre></td></tr></table></figure><p>这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 <code>window</code> 的，在严格模式，就是 <code>undefined</code>。 </p><p>但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。</p><h2 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h2><p>更多的情况是将函数作为对象的方法使用，比如例 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name: <span class="string">"Cherry"</span>,</div><div class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// Cherry</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a.fn();</div></pre></td></tr></table></figure><p>这里定义一个对象 <code>a</code>，对象 <code>a</code> 有一个属性 <code>name</code> 和一个方法 <code>fn</code></p><p>然后对象通过 <code>.</code> 方法调用了其中的 <code>fn</code> 方法</p><p>然后就是我们一直记得的那句话：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，所以在 <code>fn</code> 中的 <code>this</code> 就是指向 <code>a</code> 的</p><h2 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了 <code>new</code> 关键字, 则是调用了构造函数。<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 构造函数:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">arg1, arg2</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.firstName = arg1;</div><div class="line">    <span class="keyword">this</span>.lastName  = arg2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// This creates a new object</span></div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myFunction(<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</div><div class="line">a.lastName; <span class="comment">// 返回 "Cherry"</span></div></pre></td></tr></table></figure><p>这就有另一个面试经典问题：<code>new</code> 的过程了</p><p>伪代码表示 new 的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myFunction(<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</div><div class="line"></div><div class="line"><span class="keyword">new</span> myFunction&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    obj.__proto__ = myFunction.prototype;</div><div class="line">    <span class="keyword">var</span> result = myFunction.call(obj,<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'obj'</span>? result : obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>创建一个空对象 <code>obj</code></li><li>将新建的空对象的隐式原型指向其构造函数的显式原型</li><li>使用 <code>call</code> 改变 <code>this</code> 的指向</li><li>如果无对象值或者返回一个非对象值，则将 <code>obj</code> 返回作为新对象，如果返回值是一个新对象的话，那么直接返回该对象</li></ul><p>所以可以看出，在 <code>new</code> 的过程中，我们使用 call 改变了 this 的指向</p><h2 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h2><p>我们再来看之前的例6：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</div><div class="line">    innerFunction();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn()</div></pre></td></tr></table></figure><p>这里的 <code>innerFunction()</code> 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 <code>this</code> 就是指向 <code>window</code> 的）</p><p>例7：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">    name : <span class="string">"Cherry"</span>,</div><div class="line"></div><div class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.func1()</div><div class="line">        &#125;,<span class="number">100</span> );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">a.func2()     <span class="comment">// this.func1 is not a function</span></div></pre></td></tr></table></figure><p>复制代码这个简单一点的理解可以理解为 <strong><code>匿名函数的 this 永远指向 window</code></strong>，你可以这样想，还是那句话<strong><code>this 永远指向最后调用它的那个对象</code></strong>，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数没名字啊，所以我们是没有办法被其他对象调用匿名函数的。所以说<strong><code>匿名函数的 this 永远指向 window</code></strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>this</code> 指向的秘诀主要由以下几句话组成：</p><p><strong><code>this</code> 永远指向最后调用它的那个对象</strong></p><p><strong>匿名函数的 <code>this</code> 永远指向 <code>window</code></strong></p><p><strong>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则，<code>this</code> 为 <code>undefined</code></strong></p><p>至于为什么 <code>this</code> 在前 ES6 时代会存在指向不同的问题？可以参阅阮一峰大大的这篇文章 – <a href="http://www.ruanyifeng.com/blog/2018/06/javascript-this.html" target="_blank" rel="noopener">JavaScript 的 this 原理</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;this-的指向&quot;&gt;&lt;a href=&quot;#this-的指向&quot; class=&quot;headerlink&quot; title=&quot;this 的指向&quot;&gt;&lt;/a&gt;this 的指向&lt;/h1&gt;&lt;p&gt;ES5 中，&lt;code&gt;this&lt;/code&gt; 的指向始终坚持一个原理：&lt;strong&gt;&lt;code&gt;this 永远指向最后调用它的那个对象&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面来看一个最简单的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;windowsName&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;string&quot;&gt;&quot;Cherry&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name); &lt;span class=&quot;comment&quot;&gt;//windowsName&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;inner: &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//inner: Window&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;outer: &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//outer: Window&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据刚刚那句话 &lt;strong&gt;&lt;code&gt;this 永远指向最后调用它的那个对象&lt;/code&gt;&lt;/strong&gt;，我们再看看最后调用 &lt;code&gt;a&lt;/code&gt; 的地方 &lt;code&gt;a();&lt;/code&gt;，前面没有调用的对象，那么就是全局对象 &lt;code&gt;Window&lt;/code&gt;。这就相当于是 &lt;code&gt;window.a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意，我们在这里没有使用严格模式，如果使用严格模式，全局对象就是 &lt;code&gt;undefined&lt;/code&gt;，那么就会报错 &lt;code&gt;Uncaught TypeError：Cannot read property &amp;#39;name&amp;#39; of undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再看看这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;windowsName&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Cherry&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fn: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name); &lt;span class=&quot;comment&quot;&gt;//Cherry&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a.fn();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中，函数 &lt;code&gt;fn&lt;/code&gt; 是对象 &lt;code&gt;a&lt;/code&gt; 调用的，所以打印的值就是 &lt;code&gt;a&lt;/code&gt; 中的 &lt;code&gt;name&lt;/code&gt; 值&lt;/p&gt;
&lt;p&gt;我们做一个小小的改动：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;windowsName&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;Cherry&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fn: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name); &lt;span class=&quot;comment&quot;&gt;//Cherry&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.a.fn();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里打印出 Cherry 的原因还是因为刚刚那句话：&lt;strong&gt;&lt;code&gt;this 永远指向最后调用它的那个对象&lt;/code&gt;&lt;/strong&gt;，最后调用它的还是对象 &lt;code&gt;a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们再来看看这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;windowsName&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//name: &quot;Cherry&quot;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    fn: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name); &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.a.fn();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里打印 &lt;code&gt;undefined&lt;/code&gt; 的原因在于：调用 &lt;code&gt;fn&lt;/code&gt; 的是对象 &lt;code&gt;a&lt;/code&gt;，也就是说 &lt;code&gt;fn&lt;/code&gt; 内部的 &lt;code&gt;this&lt;/code&gt; 是对象 &lt;code&gt;a&lt;/code&gt;，而对象 &lt;code&gt;a&lt;/code&gt; 中并没有对 &lt;code&gt;name&lt;/code&gt; 进行定义，所以 log 的 &lt;code&gt;this.name&lt;/code&gt; 的值是 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个例子还是说明了：&lt;strong&gt;&lt;code&gt;this 永远指向最后调用它的那个对象&lt;/code&gt;&lt;/strong&gt;，因为最后调用的对象是 &lt;code&gt;a&lt;/code&gt;，所以就算 &lt;code&gt;a&lt;/code&gt; 中没有 &lt;code&gt;name&lt;/code&gt; 这个属性，也不会继续向上个对象寻找 &lt;code&gt;this.name&lt;/code&gt;，而是直接输出 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript 基础" scheme="https://www.douglasdong.site/categories/Javascript-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Javascript" scheme="https://www.douglasdong.site/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 异步编程迷思</title>
    <link href="https://www.douglasdong.site/2018-07-29.html"/>
    <id>https://www.douglasdong.site/2018-07-29.html</id>
    <published>2018-07-29T14:34:52.000Z</published>
    <updated>2018-08-08T04:41:40.742Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="为什么要异步编程？"><a href="#为什么要异步编程？" class="headerlink" title="为什么要异步编程？"></a>为什么要异步编程？</h1><p>Javascript 问世之初便是作为浏览器的辅助语言进行开发的，同时由于 Javascript 普遍用于浏览器的 GUI 开发，因此需要线程不能被阻塞</p><p>因此，Javascript 在之后的发展过程中都采用异步非阻塞的编程模式，也就是说，<strong>在执行一个指令后不是马上得到结果，继续执行命令，等到特定的事件触发以后，才得到结果</strong>，这也是我们常说的：Javascript 是由事件驱动的</p><h1 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h1><p>现目前的异步实现主要有以下几种实现方式：</p><ul><li><code>回调</code></li><li><code>Promise</code></li><li><code>Generator</code></li><li><code>await/async</code></li></ul><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>这种异步方式是最基础的实现，node 中在前 ES6 时代经常会碰到这种代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path.join(__dirname,<span class="string">'..'</span>),<span class="function"><span class="keyword">function</span>(<span class="params">err , files</span>)</span>&#123;</div><div class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">filename , index</span>)</span>&#123;</div><div class="line">        fs.readFle(filename , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            ....</div><div class="line">        &#125;)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>这段代码仅仅用于遍历一个目录，但是过深的嵌套很容易导致理解困难，而且这样回调也无法支持对异常的捕获，js 的嵌套回调也经常被调侃</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-07-v2-0a8d20afae14a3991283cf6e9050f677_r.jpg" alt="回调地狱"></p><a id="more"></a><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>简单一点理解的话，就是把要执行的回调函数拿到外面进行执行，使代码看起来很同步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">    <span class="comment">// 执行异步代码的调用 </span></div><div class="line">    <span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>(<span class="params">err , right</span>)</span>&#123;</div><div class="line">        <span class="comment">// 完全是可以根据返回的数据 , 直接执行相应的逻辑 , 不过为了让代码看着"好看同步" , </span></div><div class="line">        <span class="comment">// 决定把数据当作参数传递给外面,去外面(then的回调函数里, 或者catch的回调函数里)执行 </span></div><div class="line">        <span class="comment">// 根据返回的数据, 来确定该调用哪个接口 </span></div><div class="line">        <span class="keyword">if</span>(right)&#123;</div><div class="line">            resolve(<span class="string">"data"</span>); </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(err)&#123;</div><div class="line">            reject(<span class="string">'err'</span>) </div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;)  </div><div class="line"><span class="comment">// 如果执行了resolve() , 就走到这里 </span></div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    coding..</div><div class="line">&#125;)</div><div class="line"><span class="comment">//如果执行了reject , 就走到了这里 </span></div><div class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    coding..</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>为什么执行了 <code>resolve(&#39;data&#39;)</code>，或 <code>reject(&#39;err&#39;)</code> 后，<code>then</code> 的回调函数，或者 <code>catch</code> 的回调函数就知道，该我执行的时候到了呢？简单点说就是有人’通知’我呗！</p><p><code>resolve</code>，<code>reject</code> 本身是 <code>Promise</code> 内部的方法，实现大概是这样</p><p>当调用 <code>resolve(&#39;data&#39;)</code> 的时候 , 去通知.then里绑定的回调函数 , 通知你一下 , 你该执行了 , 这是参数 <code>this.emit(‘resolve’ , &#39;data&#39;)</code> </p><p>当调用 <code>reject(&#39;err&#39;)</code> 的时候 , 去通知 <code>.catch</code> 里绑定的回调函数 , 通知你一下 , 你该执行了 , 这是参数 <code>this.emit(&#39;reject&#39; , &#39;err&#39;)</code></p><p> 在调用 <code>.then(callback)</code> 的时候 , <code>callback</code> , 你监听下 <code>resolve</code> , 有人通知 <code>(emit)</code> 你的时候 , 你就执行</p><p>在调用 <code>.catch(callback)</code> 的时候 , <code>callback</code>, 你监听下 <code>reject</code>, 有人通知 <code>(emit)</code> 你的时候 , 你就执行</p><p><code>Promise</code> 实现如下：<a href="https://github.com/Tankas/knowledge/blob/master/%E4%BB%A3%E7%A0%81/promise.js" target="_blank" rel="noopener">Promise 简单实现</a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>定义：协程是一个无优先级的子程序调度组件 , 允许子程序在特定的地方挂起和恢复</p><p>线程包含于进程，协程包含于进程，只要内存足够，一个线程中可以有任意个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源</p><p>协程要做的是什么？异步的代码做着同步的活</p><h3 id="何时挂起？何时恢复？"><a href="#何时挂起？何时恢复？" class="headerlink" title="何时挂起？何时恢复？"></a>何时挂起？何时恢复？</h3><p>挂起：在协程发起异步调用的时候挂起</p><p>恢复：其他协程退出并且异步操作完成时</p><h2 id="Generator-gt-协程在-js-中的实现"><a href="#Generator-gt-协程在-js-中的实现" class="headerlink" title="Generator =&gt; 协程在 js 中的实现"></a>Generator =&gt; 协程在 js 中的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> x+<span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> a+<span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> b+<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> x+<span class="number">2</span>;</div><div class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> a+<span class="number">3</span>;</div><div class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> b+<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最直观的感觉是，当调用 <code>generator(1)</code> 的时候，其实上返回了一个链表，每一个单元中装一些函数片段，以 <code>yield</code> 为界限</p><p>像上面的例子：</p><p><strong><code>(x+2) =&gt; (a+3) =&gt; (b+2) =&gt; return</code></strong></p><p>每次通过 <code>next</code> 来移动指针到下一个函数片段，执行函数片段 <code>(eval)</code>，并返回结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gen = generator(<span class="number">2</span>);</div><div class="line">gen.next(); <span class="comment">// 当调用next(),会先走第一个代码段 , 然后就不执行了 , 交出控制权 .直到啥时候再执行next(),会走下一个代码段.</span></div></pre></td></tr></table></figure><p>我们完全可以在每个代码段都封装一个异步任务， 反正在异步任务执行的时候，我已经交出了控制权，js 主线程的代码继续往下走，等到所有异步任务都完成的时候，通知我一下，看看其他所有协程都退出的时候，就调用 <code>next()</code>，继续往下走。这样显得代码很同步</p><p>继续看下，当调用 <code>next(&#39;5&#39;)</code> 时，里面可以传入参数，而且传入的参数就是上一个 <code>yield</code> 异步任务的返回结果</p><p>可以说这个特性非常有用，就像上面说的，当异步任务完成的时候，就调用 <code>next()</code>，再执行下面的代码，但是是没法获取到上一个异步任务的结果的，所以这个特性就是做这个的，<code>next(&#39;异步任务的结果&#39;)</code></p><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p><code>async/await</code> 实质上就是 Generator 的高度封装，是 ES7 为我们提供的语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> gen = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </div><div class="line">    <span class="keyword">let</span> f1 = <span class="keyword">await</span> readFile(<span class="string">"one"</span>);</div><div class="line">    <span class="keyword">let</span> f2 = <span class="keyword">await</span> readFile2(<span class="number">123123</span>);       </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>简单说，<code>async/await</code> 就是对上面 Generator 自动化流程的封装，让每一个异步任务都是自动化的执行，当第一个异步任务 <code>readFile(&#39;one&#39;)</code> 执行完，<code>async</code> 内部自己执行 <code>next()</code>，调用第二个任务 <code>readFile2(123123)</code>，以此类推</p><p>这里也许有人会困惑，<strong>为什么 <code>await</code> 后面返回的必须是 <code>promise</code>？</strong></p><p>上面说了当第一个异步完成的时候通知我一下，我再调用  <code>next()</code>，继续往下执行，但是我是何时完成的？怎么通知你？</p><p><code>Promise</code> 就是做这件事情的，<code>async</code> 内部会在 <code>promise.then(callback)</code> 回调函数中调用 <code>next()</code>… （还有用 <code>thunk</code> 的，也是做这件事情的）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论哪一种处理回调地狱的方式，都是处理回调函数的。只不过真正调用的位置不同而已，上面几种方式都是如何组织回调函数链的执行位置，如何让代码看着更好看</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/post/5b68f894e51d45195f0b7945" target="_blank" rel="noopener">浅浅的谈一下回调地狱的问题</a><br><a href="https://github.com/rccoder/blog/issues/17" target="_blank" rel="noopener">回调地狱的今生前世</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要异步编程？&quot;&gt;&lt;a href=&quot;#为什么要异步编程？&quot; class=&quot;headerlink&quot; title=&quot;为什么要异步编程？&quot;&gt;&lt;/a&gt;为什么要异步编程？&lt;/h1&gt;&lt;p&gt;Javascript 问世之初便是作为浏览器的辅助语言进行开发的，同时由于 Javascript 普遍用于浏览器的 GUI 开发，因此需要线程不能被阻塞&lt;/p&gt;
&lt;p&gt;因此，Javascript 在之后的发展过程中都采用异步非阻塞的编程模式，也就是说，&lt;strong&gt;在执行一个指令后不是马上得到结果，继续执行命令，等到特定的事件触发以后，才得到结果&lt;/strong&gt;，这也是我们常说的：Javascript 是由事件驱动的&lt;/p&gt;
&lt;h1 id=&quot;异步实现&quot;&gt;&lt;a href=&quot;#异步实现&quot; class=&quot;headerlink&quot; title=&quot;异步实现&quot;&gt;&lt;/a&gt;异步实现&lt;/h1&gt;&lt;p&gt;现目前的异步实现主要有以下几种实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;回调&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;await/async&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;回调&quot;&gt;&lt;a href=&quot;#回调&quot; class=&quot;headerlink&quot; title=&quot;回调&quot;&gt;&lt;/a&gt;回调&lt;/h2&gt;&lt;p&gt;这种异步方式是最基础的实现，node 中在前 ES6 时代经常会碰到这种代码&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;fs.readdir(path.join(__dirname,&lt;span class=&quot;string&quot;&gt;&#39;..&#39;&lt;/span&gt;),&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err , files&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    files.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;filename , index&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        fs.readFle(filename , &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ....&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段代码仅仅用于遍历一个目录，但是过深的嵌套很容易导致理解困难，而且这样回调也无法支持对异常的捕获，js 的嵌套回调也经常被调侃&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-07-v2-0a8d20afae14a3991283cf6e9050f677_r.jpg&quot; alt=&quot;回调地狱&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript 异步执行" scheme="https://www.douglasdong.site/categories/Javascript-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="Javascript" scheme="https://www.douglasdong.site/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 事件循环原理总结</title>
    <link href="https://www.douglasdong.site/2018-06-02.html"/>
    <id>https://www.douglasdong.site/2018-06-02.html</id>
    <published>2018-06-02T12:33:24.000Z</published>
    <updated>2018-08-06T15:00:01.554Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><ul><li>node 的初始化<ul><li>初始化 node 环境</li><li>执行输入代码</li><li>执行 <code>process.nextTick</code> 回调</li><li>执行 MicroTask（Promise）</li></ul></li><li>进入 EventLoop 阶段<ul><li>进入 timer 阶段（执行timer（<code>setTimeout</code>、<code>setInterval</code>）的回调）<ul><li>检查 timer 队列是否有到期的回调，如果有，将到期的 timer 回调按照 timerId 升序执行（<code>setTimeout</code>、<code>setInterval</code>）</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>进入 I/O callback 阶段（执行一些系统调用错误，比如网络通信的错误回调）<ul><li>检查是否有 pending 的 I/O 回调，如果有，执行回调，如果没有，退出阶段</li><li>检查是否有 <code>process.nextTick</code> 任务，如果有，全部执行</li><li>检查是否有 MicroTask，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>进入 idle，prepare 阶段<ul><li>这两个阶段与编程关系不大，按下不表</li></ul></li><li>进入 poll 阶段（获取新的 I/O 事件, 适当的条件下node将阻塞在这里）<ul><li>首先检查是否存在尚未完成的回调，如果存在，那么分为两种情况<ul><li>第一种情况<ul><li>如果有可用回调（到期的定时器和一些 IO 事件），执行所有可用回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>第二种情况<ul><li>如果没有可用回调</li><li>检查是否有 <code>setImmediate</code> 任务，如果有，退出 poll 阶段，如果没有，阻塞在此阶段，等待新的事件通知</li></ul></li></ul></li><li>如果不存在尚未完成的回调，退出 poll 阶段</li></ul></li><li>进入 check 阶段（执行 <code>setImmediate()</code> 的回调）<ul><li>如果有 <code>setImmediate</code> 回调，那么执行所有的 immediate 回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出 check 阶段</li></ul></li><li>进入 closing 阶段（执行 <code>socket</code> 的 <code>close</code> 事件回调）<ul><li>如果有 <code>setImmediate</code> 回调，那么执行所有的 immediate 回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出 closing 阶段</li></ul></li><li>检查是否有活跃的 handles（定时器，IO 等事件句柄）<ul><li>如果有，继续下一轮循环</li><li>如果没有，结束事件循环，退出程序</li></ul></li></ul></li></ul><a id="more"></a><h1 id="setTimeout-和-setImmediate-执行顺序"><a href="#setTimeout-和-setImmediate-执行顺序" class="headerlink" title="setTimeout 和 setImmediate 执行顺序"></a><code>setTimeout</code> 和 <code>setImmediate</code> 执行顺序</h1><h2 id="普通代码中设置定时器"><a href="#普通代码中设置定时器" class="headerlink" title="普通代码中设置定时器"></a>普通代码中设置定时器</h2><p>普通代码执行阶段中设置的这两个执行任务，它们的执行顺序不是固定的</p><ul><li>首先，设置的 <code>setTimeout(callback, 0)</code> 被转换为 <code>setTimeout(callback, 1)</code>，所以进入定时器阶段时，会根据当前时间判断定时是否超过 1ms</li><li>事件循环在进入定时器阶段之前会由系统调用方法来更新当前时间，由于系统中同时运行着其他的程序，系统需要等待其他程序的进程运行结束才能获取准确时间，所以更新得到的时间可能会有一定的延迟</li><li>更新时间时，若没有延迟，定时不到 1ms ,immediate 任务会先执行；如果存在延迟，并且这个时间达到了 1ms 的界限， timeout 任务就会首先执行</li></ul><h2 id="IO-回调中设置定时器"><a href="#IO-回调中设置定时器" class="headerlink" title="IO 回调中设置定时器"></a>IO 回调中设置定时器</h2><p><code>setImmediate</code> 会率先执行</p><ul><li>进入 poll phase 轮询阶段之前会先检查是否有 timer 定时任务。</li><li>如果没有 timer 定时任务，才会执行后面的 IO 回调。</li><li>我们在 IO 回调中设置 setTimeout 定时任务，这时已经过了 timer 检查阶段，所以 timer 定时任务会被推迟到下一个循环中执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;执行流程&quot;&gt;&lt;a href=&quot;#执行流程&quot; class=&quot;headerlink&quot; title=&quot;执行流程&quot;&gt;&lt;/a&gt;执行流程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;node 的初始化&lt;ul&gt;
&lt;li&gt;初始化 node 环境&lt;/li&gt;
&lt;li&gt;执行输入代码&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;process.nextTick&lt;/code&gt; 回调&lt;/li&gt;
&lt;li&gt;执行 MicroTask（Promise）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 EventLoop 阶段&lt;ul&gt;
&lt;li&gt;进入 timer 阶段（执行timer（&lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;）的回调）&lt;ul&gt;
&lt;li&gt;检查 timer 队列是否有到期的回调，如果有，将到期的 timer 回调按照 timerId 升序执行（&lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;process.nextTick&lt;/code&gt; 回调，如果有，全部执行&lt;/li&gt;
&lt;li&gt;检查是否有 MicroTask，如果有，全部执行&lt;/li&gt;
&lt;li&gt;退出该阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 I/O callback 阶段（执行一些系统调用错误，比如网络通信的错误回调）&lt;ul&gt;
&lt;li&gt;检查是否有 pending 的 I/O 回调，如果有，执行回调，如果没有，退出阶段&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;process.nextTick&lt;/code&gt; 任务，如果有，全部执行&lt;/li&gt;
&lt;li&gt;检查是否有 MicroTask，如果有，全部执行&lt;/li&gt;
&lt;li&gt;退出该阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 idle，prepare 阶段&lt;ul&gt;
&lt;li&gt;这两个阶段与编程关系不大，按下不表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 poll 阶段（获取新的 I/O 事件, 适当的条件下node将阻塞在这里）&lt;ul&gt;
&lt;li&gt;首先检查是否存在尚未完成的回调，如果存在，那么分为两种情况&lt;ul&gt;
&lt;li&gt;第一种情况&lt;ul&gt;
&lt;li&gt;如果有可用回调（到期的定时器和一些 IO 事件），执行所有可用回调&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;process.nextTick&lt;/code&gt; 回调，如果有，全部执行&lt;/li&gt;
&lt;li&gt;检查是否有 MicroTask 任务，如果有，全部执行&lt;/li&gt;
&lt;li&gt;退出该阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二种情况&lt;ul&gt;
&lt;li&gt;如果没有可用回调&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;setImmediate&lt;/code&gt; 任务，如果有，退出 poll 阶段，如果没有，阻塞在此阶段，等待新的事件通知&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果不存在尚未完成的回调，退出 poll 阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 check 阶段（执行 &lt;code&gt;setImmediate()&lt;/code&gt; 的回调）&lt;ul&gt;
&lt;li&gt;如果有 &lt;code&gt;setImmediate&lt;/code&gt; 回调，那么执行所有的 immediate 回调&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;process.nextTick&lt;/code&gt; 回调，如果有，全部执行&lt;/li&gt;
&lt;li&gt;检查是否有 MicroTask 任务，如果有，全部执行&lt;/li&gt;
&lt;li&gt;退出 check 阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入 closing 阶段（执行 &lt;code&gt;socket&lt;/code&gt; 的 &lt;code&gt;close&lt;/code&gt; 事件回调）&lt;ul&gt;
&lt;li&gt;如果有 &lt;code&gt;setImmediate&lt;/code&gt; 回调，那么执行所有的 immediate 回调&lt;/li&gt;
&lt;li&gt;检查是否有 &lt;code&gt;process.nextTick&lt;/code&gt; 回调，如果有，全部执行&lt;/li&gt;
&lt;li&gt;检查是否有 MicroTask 任务，如果有，全部执行&lt;/li&gt;
&lt;li&gt;退出 closing 阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检查是否有活跃的 handles（定时器，IO 等事件句柄）&lt;ul&gt;
&lt;li&gt;如果有，继续下一轮循环&lt;/li&gt;
&lt;li&gt;如果没有，结束事件循环，退出程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://www.douglasdong.site/categories/Node-js/"/>
    
    
      <category term="Javascript" scheme="https://www.douglasdong.site/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 执行机制解析</title>
    <link href="https://www.douglasdong.site/2018-04-21.html"/>
    <id>https://www.douglasdong.site/2018-04-21.html</id>
    <published>2018-04-21T12:33:24.000Z</published>
    <updated>2018-08-06T15:01:00.395Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="关于-Javascript"><a href="#关于-Javascript" class="headerlink" title="关于 Javascript"></a>关于 Javascript</h1><p>Javascript 是一门单线程语言，在最新的 HTML5 中提出了 <code>Web-worker</code>，但 Javascript 是单线程这一核心并未改变，所以，一切 Javascript 版的“多线程”都是用单线程模拟出来的。</p><h1 id="Javascript-事件循环"><a href="#Javascript-事件循环" class="headerlink" title="Javascript 事件循环"></a>Javascript 事件循环</h1><p>既然 JS 是单线程，那就像只有一个窗口的银行，客户需要一个一个办理业务，同理 JS 任务也要一个一个顺序执行，如果一个任务耗时过长，那么后一个任务也必须等着，那么问题来了，<strong>假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？</strong>因此聪明的程序员将其分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p><strong>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染，而像加载图片、音乐之类占用资源大，耗时久的任务，就是异步任务</strong></p><p>下面是异步任务定义的导图表示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/ignore-error/1" alt="异步执行"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的“场所”，同步的进入主进程，异步的进入 <code>Event Table</code> 并注册函数</li><li>当指定的事情完成时，<code>Event Table</code> 会将这个函数移入 <code>Event Queue</code></li><li>主线程内的任务执行完毕为空，会去 <code>Event Queue</code> 读取对应的函数，进入主进程执行</li><li>上述过程会不断重复，也就是常说的 <code>Event Loop</code>（事件循环）</li></ul><p>怎么知道主线程执行栈为空？JS 引擎存在 <code>monitor process</code> 进程，会持续不断的检查主进程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> data = [];</div><div class="line">$ajax(&#123;</div><div class="line">    url: www.javascript.com,</div><div class="line">    data: data,</div><div class="line">    success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'发送成功'</span>);</div><div class="line">    &#125;</div><div class="line">)&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);    </div></pre></td></tr></table></figure><p>上面是一段简易的 <code>ajax</code> 请求代码</p><ul><li><code>ajax</code> 进入 <code>Event Table</code>，注册回调函数 <code>success</code></li><li>执行 <code>console.log(’代码执行结束)</code></li><li><code>ajax</code> 事件完成，回调函数 <code>success</code> 进入 <code>Event Queue</code></li><li>主线程从 <code>Event Queue</code> 读取回调函数 <code>success</code> 并执行</li></ul><p>接下来我们来研究进阶活动：<code>setTimeout</code></p><a id="more"></a><h1 id="又爱又恨的-setTimeout"><a href="#又爱又恨的-setTimeout" class="headerlink" title="又爱又恨的 setTimeout"></a>又爱又恨的 setTimeout</h1><p>大名鼎鼎的 <code>setTimeout</code>，我们经常这么实现延时 3 秒执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log (<span class="string">'延时3秒'</span>);</div><div class="line">&#125;, <span class="number">3000</span>)    </div></pre></td></tr></table></figure><p>渐渐的，<code>setTimeout</code> 用的地方多了以后就会出现问题，有时候<strong>明明写的延时 3 秒，实际却 5、6 秒才执行</strong>，这又是怎么回事？</p><p>先看一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    task();</div><div class="line">&#125;, <span class="number">3000</span>)   </div><div class="line"><span class="built_in">console</span>.log (<span class="string">'执行console'</span>); </div></pre></td></tr></table></figure><p>根据前面我们的结论，<code>setTimeout</code> 是异步的，应该先执行 <code>console.log</code> 这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行console</span></div><div class="line"><span class="comment">//task()</span></div></pre></td></tr></table></figure><p>验证一下，结果正确！</p><p>然后修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    task()</div><div class="line">&#125;, <span class="number">3000</span>)</div><div class="line">sleep(<span class="number">100000000</span>);    </div></pre></td></tr></table></figure><p>乍一看其实差不多，但我们把这段代码在 chrome 执行一下，却发现控制台执行 <code>task()</code> 需要的时间远远超过 3 秒，说好的延时 3 秒，为什么需要这么长时间？</p><p>这时候我们需要重新理解 <code>setTimeout</code> 的定义，我们先说上述代码是怎么执行的：</p><ul><li><code>task()</code> 进入 <code>Event Table</code> 并注册，计时开始</li><li>执行 <code>sleep</code> 函数，很慢，非常慢，计时仍在继续</li><li>3 秒到了，计时事件 <code>timeout</code> 完成，<code>task()</code> 进入 <code>Event Queue</code>，但是 <code>sleep</code> 还没执行完，只好等着</li><li><code>sleep</code> 终于执行完了，<code>task()</code> 终于从 <code>Event Queue</code> 进入了主线程执行</li></ul><p>上述的流程走完，我们知道 <strong><code>setTimeout</code> 这个函数，是经过指定时间后，把要执行的任务（本例中为 <code>task()</code>） 加入到 <code>Event Queue</code> 中</strong>，又因为是<strong>单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只好等着</strong>，导致真正的延迟时间远远大于 3 秒</p><p>我们还经常遇到 <code>setTimeout(fn, 0)</code> 这样的代码，0 秒后执行时什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn, 0)</code> 的含义是，指定某个任务在主进程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行，举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码1</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</div><div class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>);</div><div class="line">&#125;, <span class="number">0</span>); </div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//代码2</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</div><div class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>);</div><div class="line">&#125;, <span class="number">3000</span>); </div></pre></td></tr></table></figure><p>代码 1 的输出结果是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先执行这里</span></div><div class="line"><span class="comment">//执行啦</span></div></pre></td></tr></table></figure></p><p>代码 2 的输出结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先执行这里</span></div><div class="line"><span class="comment">// ... 3s later</span></div><div class="line"><span class="comment">//执行啦</span></div></pre></td></tr></table></figure><p>关于 <code>setTimeout</code> 要补充的是，即便主进程为空，0 毫秒实际上也是达不到的，<strong>根据 HTML 的标准，最低是 4 毫秒</strong>，有兴趣的同学可以自行了解</p><h1 id="又恨又爱的-setInterval"><a href="#又恨又爱的-setInterval" class="headerlink" title="又恨又爱的 setInterval"></a>又恨又爱的 setInterval</h1><p><code>setInterval</code> 与 <code>setTimeout</code> 差不多，只不过后者是循环的执行，对于执行顺序来说，<strong><code>setInterval</code> 会每隔指定的时间将注册的函数置入 <code>Event Queue</code></strong>，如果前面的任务耗时太久，那么同样需要等待</p><p>唯一需要注意的一点是，对于 <code>setInterval(fn, ms)</code> 来说，我们已经知道<strong>不是每过 <code>ms</code> 秒会执行一次 <code>fn</code>，而是每过 <code>ms</code> 秒，会有 <code>fn</code> 进入 <code>Event Queue</code>，一旦 <code>setInterval</code> 的回调函数 <code>fn</code> 执行时间超过了延迟时间 <code>ms</code>，那么就完全看不出来有时间间隔了</strong></p><h1 id="Promise-与-process-nextTick-callback"><a href="#Promise-与-process-nextTick-callback" class="headerlink" title="Promise 与 process.nextTick(callback)"></a>Promise 与 process.nextTick(callback)</h1><p>传统的定时器我们已经研究过了，接着我们探究 <code>Promise</code> 与 <code>process.nextTick(callback)</code> 的表现</p><p><code>Promise</code> 的定义和功能本文不再赘述，而 <code>process.nextTick(callback)</code> 类似 node.js 版的 <code>setTimeout</code>，在事件循环的下一次循环中调用 <code>callback</code> 回调函数</p><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务）：包括整体代码 <code>script</code>，<code>setTimeout</code>，<code>setInterval</code></li><li>micro-task（微任务）：<code>Promise</code>，<code>process.nextTick</code></li></ul><p>不同类型的任务会进入对应的 <code>Event Queue</code>，比如 <code>setTimeout</code> 和 <code>setInterval</code> 会进入相同的 <code>Event Queue</code></p><p>事件循环的顺序，决定 js 代码的执行顺序，进入整体代码（宏任务）后，开始第一次循环，接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务，听起来有点绕，我们用文章最开始的一段代码说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">setTimeout (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;    </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>);    </div></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程</li><li>先遇到 <code>setTimeout</code>，那么将其回调函数注册后分发到宏任务 <code>Event Queue</code>（注册过程与上同，下文不再赘述）</li><li>接下来遇到了 <code>Promise</code>，<code>new Promise</code> 立即执行，<code>then</code> 函数分发到微任务 <code>Event Queue</code></li><li>遇到 <code>console.log()</code>，立即执行</li><li>整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <code>then</code> 在微任务 <code>Event Queue</code> 中，执行</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <code>Event Queue</code> 开始，我们发现了宏任务 <code>Event Queue</code> 中 <code>setTimeout</code> 对应的回调函数，立即执行</li><li>结束</li></ul><p>事件循环，宏任务，微任务的关系如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/ignore-error/1" alt="事件循环关系"></p><p>我们来分析一段比较复杂的代码，看看你是否真的掌握了 js 的执行机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</div><div class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)</div><div class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</div><div class="line">    resolve();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</div><div class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</div><div class="line">        resolve();</div><div class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</div><div class="line">    &#125;)</div><div class="line">&#125;)   </div></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体 script 作为第一个宏任务进入主线程，遇到 <code>console.log()</code>，输出 1</li><li>遇到 <code>setTimeout</code>，其回调函数被分发到宏任务 <code>Event Queue</code> 中，我们记为 <code>setTimeout1</code></li><li>遇到 <code>process.nextTick()</code>，其回调函数被分发到微任务 <code>Event Queue</code> 中，我们记为 <code>then1</code></li><li>又遇到 <code>setTimeout</code>，其回调函数被分发到宏任务 <code>Event Queue</code> 中，我们记为 <code>setTimeout2</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各 <code>Event Queue</code> 的情况，此时已经输出了 1 和 7 </li><li>我们发现了 <code>process1</code> 和 <code>then1</code> 两个微任务</li><li>执行 <code>process1</code>，输出 6</li><li>执行 <code>then1</code>，输出 8</li></ul><p>第一轮事件循环正式结束，这一轮的结果是输出 1、7、6、8，那么第二轮事件循环从 <code>setTimeout1</code> 宏任务开始：</p><ul><li>首先输出 2，接下来遇到了 process.nextTick()，同样将其分发到微任务 <code>Event Queue</code> 中，记为 <code>process2</code>，<code>new Promise</code> 立即执行输出 4，<code>then</code> 也分发到微任务 <code>Event Queue</code> 中，记为 <code>then2</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有 <code>process2</code> 和 <code>then2</code> 两个微任务可以执行</li><li>输出 3</li><li>输出 5</li><li>第二轮时间循环结束，输出 2、4、3、5</li><li>第三轮事件循环开始，此时只剩下 <code>setTimeout2</code>，执行</li><li>直接输出 9</li><li>将 <code>process.nextTick()</code> 分发到微任务 <code>Event Queue</code> 中，记为 <code>process3</code></li><li>直接执行 <code>new Promise</code>，输出 11</li><li>将 <code>then</code> 分发到微任务 <code>Event Queue</code> 中，记为 <code>then3</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮时间循环宏任务执行结束，执行两个微任务 <code>process3</code> 和 <code>then3</code></li><li>输出 10</li><li>输出 12</li><li>第三轮事件循环结束，第三轮输出 9，11，10，12</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为 1、7、6、8、2、4、3、5、9、11、10、12（请注意，node 环境下的事件监听依赖 libuv 和前端环境不完全相同，输出顺序可能会有误差）</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>（1）js 的异步</strong></p><p>我们从最开头就说 Javascript 是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要</p><p><strong>（2）事件循环 Event loop</strong></p><p>事件循环是 js 实现异步的一种方法，也是 js 的执行机制</p><p><strong>（3）Javascript 的执行和运行</strong></p><p>执行和运行有很大的区别，Javascript 在不同的环境下，比如 node，浏览器，Ringo 等等，执行方式是不同的，而运行大多指 Javascript 解析引擎，是统一的</p><p><strong>（4）settimemediate</strong></p><p>微任务和宏任务还有很多种类，比如 <code>setImmediate</code> 等等，执行都是有共同点的，有兴趣的同学可以自行了解</p><p><strong>（5）最后的最后</strong></p><ul><li>Javascript 是一门单线程语言</li><li><code>Event Loop</code> 是 Javascript 的执行机制</li></ul><p>转载至：<br>作者：ssssyoki<br>链接：<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-Javascript&quot;&gt;&lt;a href=&quot;#关于-Javascript&quot; class=&quot;headerlink&quot; title=&quot;关于 Javascript&quot;&gt;&lt;/a&gt;关于 Javascript&lt;/h1&gt;&lt;p&gt;Javascript 是一门单线程语言，在最新的 HTML5 中提出了 &lt;code&gt;Web-worker&lt;/code&gt;，但 Javascript 是单线程这一核心并未改变，所以，一切 Javascript 版的“多线程”都是用单线程模拟出来的。&lt;/p&gt;
&lt;h1 id=&quot;Javascript-事件循环&quot;&gt;&lt;a href=&quot;#Javascript-事件循环&quot; class=&quot;headerlink&quot; title=&quot;Javascript 事件循环&quot;&gt;&lt;/a&gt;Javascript 事件循环&lt;/h1&gt;&lt;p&gt;既然 JS 是单线程，那就像只有一个窗口的银行，客户需要一个一个办理业务，同理 JS 任务也要一个一个顺序执行，如果一个任务耗时过长，那么后一个任务也必须等着，那么问题来了，&lt;strong&gt;假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？&lt;/strong&gt;因此聪明的程序员将其分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步任务&lt;/li&gt;
&lt;li&gt;异步任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染，而像加载图片、音乐之类占用资源大，耗时久的任务，就是异步任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是异步任务定义的导图表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/ignore-error/1&quot; alt=&quot;异步执行&quot;&gt;&lt;/p&gt;
&lt;p&gt;导图要表达的内容用文字来表述的话：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步和异步任务分别进入不同的“场所”，同步的进入主进程，异步的进入 &lt;code&gt;Event Table&lt;/code&gt; 并注册函数&lt;/li&gt;
&lt;li&gt;当指定的事情完成时，&lt;code&gt;Event Table&lt;/code&gt; 会将这个函数移入 &lt;code&gt;Event Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主线程内的任务执行完毕为空，会去 &lt;code&gt;Event Queue&lt;/code&gt; 读取对应的函数，进入主进程执行&lt;/li&gt;
&lt;li&gt;上述过程会不断重复，也就是常说的 &lt;code&gt;Event Loop&lt;/code&gt;（事件循环）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;怎么知道主线程执行栈为空？JS 引擎存在 &lt;code&gt;monitor process&lt;/code&gt; 进程，会持续不断的检查主进程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ajax(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    url: www.javascript.com,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    data: data,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    success: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;发送成功&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;代码执行结束&#39;&lt;/span&gt;);    &lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面是一段简易的 &lt;code&gt;ajax&lt;/code&gt; 请求代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ajax&lt;/code&gt; 进入 &lt;code&gt;Event Table&lt;/code&gt;，注册回调函数 &lt;code&gt;success&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;console.log(’代码执行结束)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ajax&lt;/code&gt; 事件完成，回调函数 &lt;code&gt;success&lt;/code&gt; 进入 &lt;code&gt;Event Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主线程从 &lt;code&gt;Event Queue&lt;/code&gt; 读取回调函数 &lt;code&gt;success&lt;/code&gt; 并执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们来研究进阶活动：&lt;code&gt;setTimeout&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript 异步执行" scheme="https://www.douglasdong.site/categories/Javascript-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="Javascript" scheme="https://www.douglasdong.site/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Thunk 解析</title>
    <link href="https://www.douglasdong.site/2018-04-11.html"/>
    <id>https://www.douglasdong.site/2018-04-11.html</id>
    <published>2018-04-11T11:19:24.000Z</published>
    <updated>2018-08-06T15:01:36.933Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="何为-THUNK？"><a href="#何为-THUNK？" class="headerlink" title="何为 THUNK？"></a>何为 THUNK？</h1><p>开发者时常会面临一个选择：函数的参数到底应该何时求值？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">f ( x + <span class="number">5</span> );</div></pre></td></tr></table></figure><p>上例中的代码非常正常，问题是：<strong>什么时候计算参数 x + 5 呢</strong>？</p><p>一种策略是立即计算，于是 <code>f(x + 5)</code> 会被转换成 <code>f(6)</code>，然后进入函数 <code>f</code> 内运行函数</p><p>另一种策略是延迟计算，在进入函数 <code>f</code> 之前并不计算参数值，而是进入函数体之后才计算，因此函数体内的 <code>return m * 2;</code> 会被转换为 <code>return (x + 5) * 2;</code>，此时才开始计算</p><p>如果不考虑开发成本，延迟计算是比较好的，否则如果函数体内走了某 if 分支并没有用到该参数，就白计算了，浪费性能。延迟到真正用到参数时才开始计算，这也是程序开发的一种流行的风格：<strong>越懒越好</strong><br><a id="more"></a></p><h2 id="如何实现-Thunk？"><a href="#如何实现-Thunk？" class="headerlink" title="如何实现 Thunk？"></a>如何实现 Thunk？</h2><p>如何实现延迟计算呢？可以生成一个临时函数（Thunk 函数），将参数放进去，上面代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">tempFunc</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> tempFunc() * <span class="number">2</span>;</div><div class="line">&#125;;</div><div class="line">f (thunk);  <span class="comment">//12    </span></div></pre></td></tr></table></figure><p>上面这样的延迟计算，可能对效率控来说节省了一些理论上的性能（实际真节省了吗？未必），但从代码可读性，可维护性上来看，这样是得不偿失的</p><h2 id="Thunk-的具体应用"><a href="#Thunk-的具体应用" class="headerlink" title="Thunk 的具体应用"></a>Thunk 的具体应用</h2><p>Thunk 函数在 JS 里的应用是将多参的一步函数转换为单参，通常异步函数的最后一个参数是回调函数，以 NodeJS 的核心模块 File System 的异步函数 <code>readFile</code> 为例</p><p>函数原型：<code>fs.readFile (file[, options], callback)</code><br>支持 3 个参数，其中最后一个是回调函数，普通调用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someCallback</span> (<span class="params"> err, data </span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">    <span class="built_in">console</span>.log (data);</div><div class="line">&#125;</div><div class="line">fs.readFile(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>, someCallback); </div></pre></td></tr></table></figure><p>用 Thunk 改造后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">someCallback</span> (<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName, options</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> fs.readFile(fileName, options, callback);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> readFileThunk = Thunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">readFileThunk(someCallBack);    </div></pre></td></tr></table></figure><p>Thunk 函数真正的作用是<strong>简化了参数，将原本多参的函数，简化成只接受回调函数做参数</strong>，即多参版本的一步函数，经由 Thunk，变成了单参（参数为回调函数）函数</p><p>现实中不必为每个异步函数定制一个 Thunk 函数，因此可以定义通用的 Thunk 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</div><div class="line">            args.push(callback);</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</div><div class="line">readFileThunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>)(someCallback); </div></pre></td></tr></table></figure><p>可以把上面 Thunk 函数放到 common 位置，任何多参的异步函数（最后一个参数为回调函数），都可以调用上面的 Thunk 函数转换成单参版本</p><p>其实上述 Thunk 函数等价于柯里化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> readFileThunk = fs.readFile.bind(<span class="literal">null</span>, <span class="string">'./orange.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">readFileThunk(someCallback);</div></pre></td></tr></table></figure><p>如果不想自己造轮子来写 Thunk 函数，可以 Thunkify 模块：<code>npm install thunkify</code>，源代码和我们写的 Thunk 非常像</p><h2 id="Thunk-的真正用途"><a href="#Thunk-的真正用途" class="headerlink" title="Thunk 的真正用途"></a>Thunk 的真正用途</h2><p>上面举的 Thunk 函数的例子，无论是延迟计算，还是将多参异步函数转换成单参，其实都没什么用，所以在 Generator 函数出现之前，Thunk 函数确实没什么用，真正让其发挥作用的是配合 Generator 函数实现自动化异步操作，以读取文件为例，Generator 函数封装了两个异步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</div><div class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</div><div class="line"></div><div class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'./apples.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">    <span class="built_in">console</span>.log(r1);</div><div class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>);</div><div class="line">    <span class="built_in">console</span>.log(r2);</div><div class="line">&#125;;    </div></pre></td></tr></table></figure><p>定义的异步操作很清晰（这也是 Generator 的优点，可以用同步化的方式定义异步操作步骤），可以如下执行异步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> g = gen();</div><div class="line"><span class="keyword">var</span> r = g.next();</div><div class="line">r.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;  <span class="comment">//r.value 是一个 function，等价于 fs.readFile(callback)</span></div><div class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">    <span class="keyword">var</span> r2 = g.next(data);</div><div class="line">    r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</div><div class="line">        g.next(data);</div><div class="line">    &#125;);</div><div class="line">&#125;);    </div></pre></td></tr></table></figure><p>上面代码第二行执行 <code>next</code> 后，返回值 r 的 <code>value</code> 属性是 Generator 函数体内 <code>yield readFileThunk(&#39;./apples.txt&#39;, &#39;utf8&#39;);</code> 语句的执行结果，即 r 的 <code>value</code> 属性是一个内部封装了 <code>[&#39;./apples.txt&#39;, &#39;utf8&#39;]</code> d的单参数的 fs.readFile 函数，即 r 的 <code>value</code> 属性是 fs.readFile(callback)函数</p><p>因此上面代码第三行 <code>r.value(function(err, data){...}</code> 等价于 <code>fs.readFile(function(err, data){...}</code>，此时才开始正式执行异步函数读取文件内容，读取到的内容通过第 5 行 <code>next</code> 方法传递给 Generator 函数里的 <code>r1</code>，打印出文件内容，之后就是重复上述套路</p><p>显然开发者不想用这样嵌套的调用方法，所以可以定义一个 <code>run</code> 方法将上面的调用代码封装起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">genFunc</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> g = genFunc();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> result = g.next(data);</div><div class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</div><div class="line">        result.value(next);</div><div class="line">    &#125;</div><div class="line">    next();</div><div class="line">&#125;</div><div class="line">run(gen);    </div></pre></td></tr></table></figure><p>定义了 <code>run</code> 方法后，执行 Generator 函数就方便了很多，直接将 Generator 函数作为参数传动给 <code>run</code> 就行了，然后会自动像多米诺骨牌一样依次执行 Generator 函数内的异步操作，当然，前提是每一个异步操作，都要是 Thunk 函数，即 <code>yield</code> 命令后面的必须是 Thunk 函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;何为-THUNK？&quot;&gt;&lt;a href=&quot;#何为-THUNK？&quot; class=&quot;headerlink&quot; title=&quot;何为 THUNK？&quot;&gt;&lt;/a&gt;何为 THUNK？&lt;/h1&gt;&lt;p&gt;开发者时常会面临一个选择：函数的参数到底应该何时求值？&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;m&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;f ( x + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; );&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例中的代码非常正常，问题是：&lt;strong&gt;什么时候计算参数 x + 5 呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;一种策略是立即计算，于是 &lt;code&gt;f(x + 5)&lt;/code&gt; 会被转换成 &lt;code&gt;f(6)&lt;/code&gt;，然后进入函数 &lt;code&gt;f&lt;/code&gt; 内运行函数&lt;/p&gt;
&lt;p&gt;另一种策略是延迟计算，在进入函数 &lt;code&gt;f&lt;/code&gt; 之前并不计算参数值，而是进入函数体之后才计算，因此函数体内的 &lt;code&gt;return m * 2;&lt;/code&gt; 会被转换为 &lt;code&gt;return (x + 5) * 2;&lt;/code&gt;，此时才开始计算&lt;/p&gt;
&lt;p&gt;如果不考虑开发成本，延迟计算是比较好的，否则如果函数体内走了某 if 分支并没有用到该参数，就白计算了，浪费性能。延迟到真正用到参数时才开始计算，这也是程序开发的一种流行的风格：&lt;strong&gt;越懒越好&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Javascript 异步执行" scheme="https://www.douglasdong.site/categories/Javascript-%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="Javascript" scheme="https://www.douglasdong.site/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>第八章 -- 布局</title>
    <link href="https://www.douglasdong.site/2018-02-05.html"/>
    <id>https://www.douglasdong.site/2018-02-05.html</id>
    <published>2018-02-04T20:35:24.000Z</published>
    <updated>2018-08-06T15:01:52.535Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="计划布局"><a href="#计划布局" class="headerlink" title="计划布局"></a>计划布局</h1><p>在开始把设计转换为功能完整的模板时，设计者往往很想马上开始编写页面和处理图像。但是，这样做很快就会遇到麻烦。相反，先做一点儿计划可以避免很多问题。</p><p>要想创建可伸缩且容易维护的 CSS 系统，首先应该检查设计，寻找重复的模式，这包括页面结构中的模式或在站点中元素反复出现的方式。在这个阶段，不应该太关注表现方式，而是应该注意结构和意义。我喜欢打印出每个设计，圈出模式，然后在每个页面上随便写上批注。但是，有些人喜欢在 Phootoshop 文件上加批注或是使用灰色框设计图。</p><p>先把页面划分为大的结构性区域，比如容器、页眉、内容区域和页脚。这些区域在整个站点中往往是一致的，很少改变。如果用建筑来类比，可以把这些区域看做建筑物的外墙。</p><p>然后，将注意力转移到内容区域本身，开始建立网格结构。设计有多少个不同的内容区域？它们有什么差异？从布局的角度来说，内容区域是确实不一样，还是可以被同等看待？大多数设计只有几个独特的内容区域，所以应该寻找共同的特征而不是视觉表现。你可以把这些内容区域看做建筑物的内部承重墙。</p><p>最后，在各个内容区域中寻找不同的布局结构。是否需要把某些信息分为两列、三列或四列？与前面不同，这些布局结构往往非常灵活，在各个页面之间常常有变化。可以把它们看做建筑物的隔断墙。将这些结构与前一步相结合，可以形成每个页面的结构计划。现在，要拿起绘图纸和彩色铅笔，开始详细设计结构和尺寸。</p><p>结构设计完以后，现在可以开始关注不同类型的内容。内容是新闻稿、文章还是公告？给每个内容块起一个有意义的名称，然后分析它们的关系。可能新闻稿和公告实际上没什么差别，在这种情况下，把它们组合成一个内容类型是有道理的。</p><p>查看每个内容块的结构，看看不同的类型中是否有共同的模式。例如，文章和新闻稿可能都有醒目的页眉和页脚，所以可以加上相应的标识。即使页眉和页脚看起来不一样，实际上也没关系，因为以后可以根据上下文应用样式。对于错误消息、搜索框和菜单项等也是这样。应该尽量采用一般的类名，然后根据上下文应用样式。</p><p>找出模式并确定命名约定之后，最好马上开始定义将使用的元素，这是有好处的。例如，链接列表可能是一个无序列表，而文章可能是一个 <code>div</code>，其中包含 <code>h2</code>、段落和锚元素。与几位同事一起提前定义元素，比随时添加元素容易得多。我还发现应该记下颜色编码、尺寸等信息，这在开发阶段会有帮助。另外，可以在设计的打印稿上添加批注以便快速参考。<br><a id="more"></a></p><h1 id="设置基本结构"><a href="#设置基本结构" class="headerlink" title="设置基本结构"></a>设置基本结构</h1><p>假设我们要开发一个典型的三列博客模板，见下图</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-1.png" alt="8-1"></p><p><center>典型的三列布局</center><br><br></p><p>通过分析设计发现，我们需要用一个容器元素让设计居中，其中包含页眉、内容区域和页脚。因此，标记应该像下面这样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    </div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Your header content goes here--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Your pages content goes here--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Your footer content goes here--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        </div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>因为后三个区域放在容器中，我们先设置容器元素的样式。</p><h2 id="使用外边距让设计居中"><a href="#使用外边距让设计居中" class="headerlink" title="使用外边距让设计居中"></a>使用外边距让设计居中</h2><p>长文本行可能阅读起来很困难，让人讨厌。现代显示器的尺寸越来越大，屏幕可读性问题变得越来越重要。缓解这个问题的一种方法是让设计居中。居中是指只占据屏幕的一部分，而不是横跨屏幕的整个宽度，这样就会创建比较短的容易阅读的行。</p><p>假设有一个典型的布局，希望让其中的容器 <code>div</code> 在屏幕上水平居中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>为此，只需定义容器 <code>div</code> 的宽度，然后将水平外边距设置为 <code>auto</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">920px</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在这个示例中，我决定以像素为单位指定容器 <code>div</code> 的宽度，让它适合分辨率为 <code>1024x768</code> 的屏幕。但是，也可以将宽度设置为主体的百分之几，或者使用 <code>em</code> 相对于文本字号设置宽度。</p><h1 id="基于浮动的布局"><a href="#基于浮动的布局" class="headerlink" title="基于浮动的布局"></a>基于浮动的布局</h1><p>用 CSS 进行布局有几种不同的方式，包括绝对定位和使用负的外边距值。我发现基于浮动的布局是最容易使用的，也是最可靠的。顾名思义，在基于浮动的布局中，只需设置希望定位的元素的宽度，然后将它们向左或向右浮动。</p><p>因为浮动的元素不再占据文档流中的任何空间，它们就不再对包围它们的块框产生任何影响。为了解决这个问题，需要对布局中各个点上的浮动元素进行清理。非常常见的做法不是连续地浮动和清理元素，而是浮动几乎所有东西，然后在整个文档的“战略点”（比如页脚）上进行一次或两次清理。还可以使用溢出方法清理某些元素的内容。这是我目前最喜欢的方法，所以在后面的示例中都是用这种方法。</p><h2 id="两列的浮动布局"><a href="#两列的浮动布局" class="headerlink" title="两列的浮动布局"></a>两列的浮动布局</h2><p>要在内容区创建一个两列布局，首先需要创建一个基本的 HTML 结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"primary"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- main content goes here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"secondary"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- navigation and secondary content goes here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>这个设计的次要内容区域（包括站点导航）将位于页面的左边，主内容位于右边。但是，为了提高易用性和可访问性，我选择在源代码中将主内容区域放在次要内容区域的前面。首先，主内容是页面上最重要的东西，所以在文档中应该先出现。其次，这样可以方便屏幕阅读器用户，他们用不着经过可能很长的链接列表和不太重要的内容（比如站点宣传）就能找到主内容部分。</p><p>在创建基于浮动的布局时，一般将两列都向左浮动，然后使用外边距或内边距在两列之间创建一个隔离带。在使用这种方法时，列在可用空间内包得很紧，没有喘息的空间。如果浏览器表现良好的话，这不是问题；但是差劲的浏览器会打乱紧密的布局，迫使一列退到另一列下面。（比如 IE）</p><p>实现这个布局的 CSS 非常简单。只需为每个列设置想要的宽度，然后将次要内容向左浮动，将主内容向左浮动。还需要在主内容中添加一点儿内边距，以避免其中包含的文本紧挨着元素的右边缘。注意，我还在所有浮动元素中添加了 <code>display: inline</code>。这个预防措施用来防止 IE 中的双内边距浮动产生的 bug（详细信息见下一章）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">650px</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为总宽度是 920 像素，这些设置在每个浮动元素之间留出 20 像素宽的隔离带。正如前面提到的，这可以防止内容扩展导致浮动元素下降。</p><p>因为这些元素是浮动的，它们不再在文档流中占据任何空间，这会导致页脚向上升。为了避免这种情况，需要对它们的父元素（在这里是内容 <code>div</code>）应用溢出方法，从而清理浮动元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> &#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在你看到效果：一个简单的两列 CSS 布局（见下图）。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-3.png" alt="8-3"></p><p><center>浮动的两列布局</center><br><br></p><p>注意，我没有把创建的两个元素命名为 <code>primary-content</code> 和 <code>secondary-content</code>，而是简称为 <code>primary</code> 和 <code>secondary</code>。这两个元素嵌套在 <code>content</code> 元素中，可以创建关联，我利用了这一事实。这有两个好处。首先，不需要为要应用样式的每个元素创建新的类名，而应使用层叠找到元素。更重要的是，可以多次使用 <code>primary</code> 和 <code>secondary</code> 类，这会创建一个非常灵活的命名系统。例如，假设我们希望创建的是三列布局而不是两列布局，具体方法请见下一节。</p><h2 id="三列的浮动布局"><a href="#三列的浮动布局" class="headerlink" title="三列的浮动布局"></a>三列的浮动布局</h2><p>创建三列布局所需的 HTML 与两列布局的 HTML 非常相似，唯一的差异是在内容 <code>div</code> 中添加了两个新的 <code>div</code>：一个用于主内容，另一个用于次要内容。因此，可以重用灵活的 <code>primary</code> 和 <code>secondary</code> 类名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"primary"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"primary"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">--</span> <span class="attr">your</span> <span class="attr">primary</span> <span class="attr">primary</span> <span class="attr">content</span> <span class="attr">goes</span> <span class="attr">here</span> <span class="attr">--</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"secondary"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">--</span> <span class="attr">your</span> <span class="attr">secondary</span> <span class="attr">primary</span> <span class="attr">content</span> <span class="attr">goes</span> <span class="attr">here</span> <span class="attr">--</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"secondary"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--navigation and secondary content goes here --&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>可以使用与两列布局技术相同的 CSS，将次要内容向左浮动，将主内容向右浮动。然后，在主内容 <code>div</code> 中。将主 <code>div</code> 向左浮动，将次要 <code>div</code> 向右浮动（见下图）。这其实就是将主内容区域分成两列，从而形成三列的效果。</p><p>与前面一样，所用的 CSS 非常简单。只需设置想要的宽度，然后将主 <code>div</code> 向左浮动，将次要 <code>div</code> 向右浮动，在中间留出 20 像素的间距：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-4.png" alt="8-4"></p><p><center>通过将内容列分成两列，形成三列布局</center><br><br></p><p>注意，第一个示例中主 <code>div</code> 中添加的右内边距现在要应用在第二个示例的主 <code>div</code> 上。因此，需要从一般样式中删除内边距，把它应用于更特定的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">670px</span>; <span class="comment">/* width increased and padding removed */</span></div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样就形成了一个漂亮的三列布局（见下图）。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-5.png" alt="8-5"></p><p><center>使用浮动的三列布局</center><br><br></p><h1 id="固定宽度、流式和弹性布局"><a href="#固定宽度、流式和弹性布局" class="headerlink" title="固定宽度、流式和弹性布局"></a>固定宽度、流式和弹性布局</h1><p>固定宽度的布局，可以在知道每个元素的精确宽度的情况下进行精确的布局，而且知道所有的东西在什么地方。这使固定宽度的布局成为最简便、最常用的布局方法。</p><p>但是，固定宽度的布局也有缺点。首先，因为它们是固定的，所以无论窗口的尺寸有多大，它们的尺寸总是不变。因此，它们无法充分利用可用空间。在高分辨率的屏幕上，为分辨率为 1024x760 的屏幕创建的设计会缩小并且出现在屏幕的中甲。反之，为分辨率为 1024x760 的屏幕创建的设计在低分辨率上的屏幕会导致水平滚动。随着屏幕尺寸范围越来越大，固定宽度设计越来越不适应灵活的 Web。因此，它们常常被认为是糟糕的权宜之计。</p><p>固定宽度的另一个问题是关于行长和文本易读性的。固定宽度的布局往往适合于浏览器默认字号，但是，只要将文本字号增加几级，边栏就会挤满空间并且行长太短，阅读起来不舒服。</p><p>为了解决这些问题，可以使用流式布局或者弹性布局替代固定宽度的布局。</p><h2 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h2><p>在使用流式布局时，尺寸是用百分数而不是像素设置的。这使流式布局能相对于浏览器窗口进行伸缩。随着浏览器窗口变大，列也会变宽。相反，随着窗口变小，列的宽度也减小。流式布局可以非常高效的利用空间。</p><p>但是，流式布局也不是没有问题的。在窗口宽度较小的时候，行变得非常窄，很难阅读。在多列布局中尤其如此。因此，有必要添加以像素或 <code>em</code> 为单位的 <code>min-width</code>，从而防止布局变得太窄。但是，如果 <code>mid-width</code> 设置的太大，流式设计也会遇到与固定宽度布局相同的限制。</p><p>与之相反，如果设计横跨整个浏览器窗口，那么行就变得太长，也很难阅读。可以采取几个措施来避免这个问题。首先，不要横跨浏览器而是让容器只跨越宽度的一部分，比如 <code>85%</code>。还可以考虑用百分数设置内边距和外边距，这样的话，内边距和外边距的宽度将随着窗口尺寸而变，可以防止列太快得变得过宽。最后，对于非常严重的情况，也可以选择为容器设置最大宽度，以防止内容在大显示器上变得过宽。</p><p>可以使用这些技术将前面的固定宽度的三列布局转换为流式三列布局。首先，将容器宽度设置为窗口总宽度的百分数。大多数人根据自己屏幕上的效果选择尺寸，这很好。但是，如果希望更精确一点，可以通过查看浏览器统计数据确定最常用的窗口尺寸，然后根据固定宽度版本和这个尺寸的比例选择容器半分熟。例如，如果设计者使用的宽度为 <code>960px</code>，而大多数用户的浏览器窗口设置为 <code>1250px</code>，那么使用的百分数是 <code>(960/1250) * 100 = 76.8%</code>。</p><p>接下来，以容器宽度的百分数形式设置主内容区域和次要内容区域的宽度。在前面的示例中，主内容 <code>div</code> 的宽度是 <code>670px</code>。因为总宽度是 <code>920px</code>，计算结果为 <code>72.82%</code>。以相似的方法计算出次要内容 <code>div</code> 的宽度是 <code>25%</code>。这在导航元素和容器之间流出 <code>2.18%</code> 的隔离带，从而应对任何取整错误和宽度差异。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">wifth</span>: <span class="number">76.8%</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">text-align</span>: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">72.82%</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.conetent</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后需要设置主内容区域中列的宽度。这需要一点儿技巧，因为内容 <code>div</code> 的宽度依据的是主内容元素的宽度，而不是整个容器。现在，主 <code>div</code> 的宽度是 <code>400px</code>，即父元素的 <code>59.7%</code>。以相似的方法计算出次要 <code>div</code> 的宽度是 <code>34.33%</code>。最后，还需要 <code>20px</code> 的槽，即父元素的 <code>2.63%</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.primary</span>&#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">59.7%</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">34.33%</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">2.63%</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这会产生一个最适合 <code>1250px</code> 像素窗口的流式布局，但是在屏幕分辨率更大或更小时阅读起来也比较舒服。</p><p>因为这个布局会恰当地伸缩，所以不需要添加 <code>max-width</code> 属性。但是，为确保文本行的长度适合阅读，最好添加以 <code>em</code> 为单位的 <code>max-width</code>。对于比较小的窗口尺寸，这个布局会有点儿挤，所以还添加以 <code>em</code> 为单位的 <code>min-width</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">76.8%</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">text-align</span>: left;</div><div class="line">    <span class="attribute">max-width</span>: <span class="number">125em</span>;</div><div class="line">    <span class="attribute">min-width</span>: <span class="number">62em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在你应该看到了一个漂亮灵活的流式布局。</p><h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><p>虽然流式布局可以充分利用可用空间，但是在大分辨率显示器上，行仍然会过长，让用户不舒服。相反，在窄窗口中或者在增加文本字号时，行会变得非常短，内容很零碎。对于这个问题，弹性布局可能会是一种解决方案。</p><p>弹性布局相对于字号（而不是浏览器宽度）来设置元素的宽度。以 <code>em</code> 为单位设置宽度，可以确保在字号增加时整个布局随之扩大。这可以将行长保持在可阅读的范围，对于视力弱或有认知障碍的人尤其有用。</p><p>与其他布局技术一样，弹性布局也有自己的问题。弹性布局的一些问题与固定宽度布局相同，比如不能充分利用可用空间。另外，因为在文本字号增加时整个布局会加大，所以弹性布局会变得比浏览器窗口宽，导致水平滚动条出现。为了防止这种情况，可能需要在容器 <code>div</code> 上添加 <code>100%</code> 的 <code>max-width</code>。</p><p>大多数浏览器上的默认字号是 <code>16px</code>，<code>10px</code> 大约是 <code>16px</code> 的 <code>62.5%</code>，所以在主体上将字号设置为 <code>62.5%</code> 就可以了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">62.5%</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为在使用默认字号时 <code>1em</code> 现在相当于 <code>10px</code>，所以可以相当轻松地将固定宽度布局转换为弹性布局。在本书的前一个版本中，我建议以 <code>em</code> 为单位设置所有宽度。但是，<strong>我的同事建议内部宽度仍然使用百分数，只以 em 为单位设置容器的宽度。这样的话，内部宽度仍然是相对于字号的。</strong>这样就可以方便地修改布局的总尺寸，不必修改每个元素的宽度，这种解决方案更灵活、更易于维护。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">92em</span>;</div><div class="line">    <span class="attribute">max-width</span>: <span class="number">95%</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">    <span class="attribute">text-align</span>: left;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">72.82%</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.primary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">34.33%</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.content</span> <span class="selector-class">.primary</span> <span class="selector-class">.secondary</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">34.33%</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">2em</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在使用常规文本字号时，这些代码产生的布局与固定宽度布局看起来一样（见下图），但是它会随着文本字号的增加而漂亮地增大（见下图）。</p><p>除非所有浏览器都默认支持页面缩放，否则，对于老式浏览器，可能仍然需要考虑使用弹性布局。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-6.png" alt="8-6"></p><p><center>使用默认文本字号时的弹性布局</center><br><br></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-7.png" alt="8-7"></p><p><center>文本字号增加几次后的弹性布局</center><br><br></p><h2 id="流式和弹性图像"><a href="#流式和弹性图像" class="headerlink" title="流式和弹性图像"></a>流式和弹性图像</h2><p>如果选择使用流式或弹性布局，那么固定宽度的图像就会对设计产生强烈的影响。当布局的宽度减小时，图像会相对它移动，可能对彼此产生消极影响。图像会以自然的最小宽度显示，从而防止某些元素的尺寸减小。有些图像会超出包含它们的元素，从而破坏精心调整过的设计。增加布局的宽度也会产生戏剧性的效果。</p><p>对于需要跨越大区域的图像，比如站点页眉或品牌区域中的图像，可以考虑使用背景图像而不是图像元素。随着 <code>branding</code> 元素的伸缩，背景图像或多或少会露出来一些：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># <span class="selector-tag">branding</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">171px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(img/branding.png) no-repeat left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"branding"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>如果图像需要用作页面上的图像元素，那么将容器元素的宽度设置为 <code>100%</code> 并且将 <code>overflow</code> 属性设置为 <code>hidden</code>。这样的话，图像右边会被截短，使它适合 <code>branding</code> 元素，而不会随着布局伸缩：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#branding</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"branding"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/img/branding.png"</span> <span class="attr">width</span>=<span class="string">"1600"</span> <span class="attr">height</span>=<span class="string">"171"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>对于常规内容图像，你可能希望它们垂直和水平伸缩以避免被剪切。为此，可以将图像元素添加到没有任何尺寸的页面上。然后设置图像的百分数宽度，并且添加与图像宽度相同的 <code>max-width</code> 以避免像素失真（pixelization）。</p><p>例如，假设希望创建一种新闻稿样式，在左边是窄的图像列，右边是比较大的文本列。图像的宽度需要大约是包含它的框的四分之一，文本占据余下的空间。为此，只需将图像的宽度设置为 <code>25%</code>，然后将 <code>max-width</code> 设置为图像的尺寸（在这个示例中是 <code>200px</code> 宽）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">img</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</div><div class="line">    <span class="attribute">max-width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">2%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.news</span> <span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">68%</span>;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">2%</span> <span class="number">2%</span> <span class="number">2%</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>随着 <code>news</code> 元素的扩展或收缩，图像和文本段落也会扩展或收缩，从而保持视觉上的平衡。但是，在符合标准的浏览器上，图像不会超过它的实际尺寸。</p><h1 id="高度相等的列"><a href="#高度相等的列" class="headerlink" title="高度相等的列"></a>高度相等的列</h1><p>除了在主布局中创建列，你可能还需要在其他地方创建高度相等的列，比如像下图这样。尽管使用表格很容易实现这种效果，但是在 CSS 中实现时需要一点儿技巧。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-8.png" alt="8-8"></p><p><center>三个高度相等的列</center><br><br></p><p>先看看标记</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Andy Budd<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Richard Rutter<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Jeremy Keith<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bottom"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>对于这个示例，需要 3 个 <code>div</code>，每个列一个。在每个 <code>div</code> 中，需要标题、一些内容和一个空的 <code>div</code>，这个 <code>div</code> 作为底角的钩子。然后，把这 3 个 <code>div</code> 放在容器 <code>div</code> 中，我们将使用容器 <code>div</code> 限制高度。现在开始给框设置样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#89ac10</span> <span class="built_in">url</span>(/img/top.gif) no-repeat left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种技术的关键是给每个框设置大的底内边距，然后用数值相似的负外边距消除这个高度。这会导致每个列溢出容器元素（见下图）。如果把容器的 <code>overflow</code> 属性设置为 <code>hidden</code>，列就在最高点被裁切。在这个示例中，给每个元素设置 <code>520px</code> 的底内边距和 <code>500px</code> 的底外边距。<code>20px</code> 的差值在每个框的地步形成可见的内边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">520px</span>;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#89ac10</span> <span class="built_in">url</span>(/img/top.gif) no-repeat left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了把列的底边定位在正确的位置，需要让它们与容器元素的底部对其。为此，首先把容器的 <code>position</code> 设置为 <code>relative</code>。然后把空 <code>div</code> 的 <code>position</code> 设置为 <code>absolute</code>，把它们的 <code>bottom</code> 属性设置为0。现在，只需设置正确的宽度和高度，应用底部背景图像。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">250px</span>;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">padding-bottom</span>: <span class="number">520px</span>;</div><div class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">margin-left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">display</span>: inline;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#89ac10</span> <span class="built_in">url</span>(/img/top.gif) no-repeat left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>结果是一个高度与最长列相等的三列布局。</p><h1 id="CSS-3-列"><a href="#CSS-3-列" class="headerlink" title="CSS 3 列"></a>CSS 3 列</h1><p>CSS 3 也可以创建等高文本列，见下图。这要通过 <code>column-count</code>、<code>column-width</code> 和 <code>column-gap</code> 属性实现。</p><p>假设使用的标记如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Socrates<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"co1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>After philosophizing for a while...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/8-9.png" alt="8-9"></p><p><center>使用 CSS 3 列属性实现的文本列</center><br><br></p><p>应用以下规则创建一个三列布局，每个列的宽度是 <code>14em</code>，列之间有 <code>2em</code> 的间距。CSS 列的优点之一是在可用空间小鱼已定义列的宽度时的处理方式。列不会像使用浮动时那样回绕，而是会减少列数。因此，如果空间不够显示三列，就会减少到两列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.col</span> &#123;</div><div class="line">    <span class="attribute">-moz-column-count</span>: <span class="number">3</span>;</div><div class="line">    <span class="attribute">-moz-column-width</span>: <span class="number">14em</span>;</div><div class="line">    <span class="attribute">-moz-column-gap</span>: <span class="number">2em</span>;</div><div class="line">    <span class="attribute">-moz-column-rule</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">    <span class="attribute">-webkit-column-count</span>: <span class="number">3</span>;</div><div class="line">    <span class="attribute">-webkit-column-width</span>: <span class="number">14em</span>;</div><div class="line">    <span class="attribute">-webkit-column-gap</span>: <span class="number">2em</span>;</div><div class="line">    <span class="attribute">-webkit-column-rule</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">    <span class="attribute">column-count</span>: <span class="number">3</span>;</div><div class="line">    <span class="attribute">column-width</span>: <span class="number">14em</span>;</div><div class="line">    <span class="attribute">column-gap</span>: <span class="number">2em</span>;</div><div class="line">    <span class="attribute">column-rule</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计划布局&quot;&gt;&lt;a href=&quot;#计划布局&quot; class=&quot;headerlink&quot; title=&quot;计划布局&quot;&gt;&lt;/a&gt;计划布局&lt;/h1&gt;&lt;p&gt;在开始把设计转换为功能完整的模板时，设计者往往很想马上开始编写页面和处理图像。但是，这样做很快就会遇到麻烦。相反，先做一点儿计划可以避免很多问题。&lt;/p&gt;
&lt;p&gt;要想创建可伸缩且容易维护的 CSS 系统，首先应该检查设计，寻找重复的模式，这包括页面结构中的模式或在站点中元素反复出现的方式。在这个阶段，不应该太关注表现方式，而是应该注意结构和意义。我喜欢打印出每个设计，圈出模式，然后在每个页面上随便写上批注。但是，有些人喜欢在 Phootoshop 文件上加批注或是使用灰色框设计图。&lt;/p&gt;
&lt;p&gt;先把页面划分为大的结构性区域，比如容器、页眉、内容区域和页脚。这些区域在整个站点中往往是一致的，很少改变。如果用建筑来类比，可以把这些区域看做建筑物的外墙。&lt;/p&gt;
&lt;p&gt;然后，将注意力转移到内容区域本身，开始建立网格结构。设计有多少个不同的内容区域？它们有什么差异？从布局的角度来说，内容区域是确实不一样，还是可以被同等看待？大多数设计只有几个独特的内容区域，所以应该寻找共同的特征而不是视觉表现。你可以把这些内容区域看做建筑物的内部承重墙。&lt;/p&gt;
&lt;p&gt;最后，在各个内容区域中寻找不同的布局结构。是否需要把某些信息分为两列、三列或四列？与前面不同，这些布局结构往往非常灵活，在各个页面之间常常有变化。可以把它们看做建筑物的隔断墙。将这些结构与前一步相结合，可以形成每个页面的结构计划。现在，要拿起绘图纸和彩色铅笔，开始详细设计结构和尺寸。&lt;/p&gt;
&lt;p&gt;结构设计完以后，现在可以开始关注不同类型的内容。内容是新闻稿、文章还是公告？给每个内容块起一个有意义的名称，然后分析它们的关系。可能新闻稿和公告实际上没什么差别，在这种情况下，把它们组合成一个内容类型是有道理的。&lt;/p&gt;
&lt;p&gt;查看每个内容块的结构，看看不同的类型中是否有共同的模式。例如，文章和新闻稿可能都有醒目的页眉和页脚，所以可以加上相应的标识。即使页眉和页脚看起来不一样，实际上也没关系，因为以后可以根据上下文应用样式。对于错误消息、搜索框和菜单项等也是这样。应该尽量采用一般的类名，然后根据上下文应用样式。&lt;/p&gt;
&lt;p&gt;找出模式并确定命名约定之后，最好马上开始定义将使用的元素，这是有好处的。例如，链接列表可能是一个无序列表，而文章可能是一个 &lt;code&gt;div&lt;/code&gt;，其中包含 &lt;code&gt;h2&lt;/code&gt;、段落和锚元素。与几位同事一起提前定义元素，比随时添加元素容易得多。我还发现应该记下颜色编码、尺寸等信息，这在开发阶段会有帮助。另外，可以在设计的打印稿上添加批注以便快速参考。&lt;br&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>第六章 -- 对列表应用样式和创建导航条</title>
    <link href="https://www.douglasdong.site/2018-01-21.html"/>
    <id>https://www.douglasdong.site/2018-01-21.html</id>
    <published>2018-01-21T13:31:24.000Z</published>
    <updated>2018-08-06T15:01:59.523Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="对列表应用样式和创建导航条"><a href="#对列表应用样式和创建导航条" class="headerlink" title="对列表应用样式和创建导航条"></a>对列表应用样式和创建导航条</h1><p>列表让我们能够对相关的元素进行分组，并由此给它们添加意义和结构。大多数网页都包含某种形式的列表，比如最近的新闻列表、喜欢的网页的链接列表或到站点其他部分的链接列表。将这些条目标识为列表并且加上标记会在 <code>HTML</code> 文档中增加结构，提供应用样式的钩子（hook）<br><a id="more"></a></p><h2 id="基本列表样式"><a href="#基本列表样式" class="headerlink" title="基本列表样式"></a>基本列表样式</h2><p>基本列表样式非常简单，假设有下面这个任务列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Read emails<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Write chapter<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Cook dinner<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Watch Lost<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>为了添加定制的项目列表，可以使用 <code>list-style-image</code> 属性。但是，这种方法对项目符号图像的位置控制能力不强。更常用的方法是<strong>关闭项目符号，并且将定制的项目符号作为背景添加在列表元素上。然后可以使用背景图像的定位属性精确地控制自定义项目符号的对齐方式。</strong></p><p><code>IE</code> 的早期版本和 <code>Opera</code> 使用左外边距控制列表的缩进，而包括 <code>Safari</code> 和 <code>Firefox</code> 在内的大多数现代浏览器则选择使用左内边距。因此，首先需要将列表的 <code>外边距（margin）</code> 和 <code>内边距（padding</code> 设置为零，从而去掉这个缩进。要去掉默认的项目符号，只需将列表样式类型设置为 <code>none</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>添加定制的项目符号非常简单。在列表项左边添加内边距，为符号留出所需的空间。然后将项目符号作为背景图像应用于列表项。如果列表项跨越多行，你可能希望将项目符号放在接近列表项顶部的位置。但是，如果知道列表项的内容不会跨越多行，那么可以将垂直位置设置为 <code>middle</code> 或 <code>50%</code>，从而让项目符号垂直居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/bullet.gif) no-repeat <span class="number">0</span> <span class="number">50%</span>;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">30px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>产生的列表样式如下：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-1.png" alt="6-1"></p><p><center>具有自定义项目符号的简单列表样式</center><br><br></p><h2 id="创建基本的垂直导航条"><a href="#创建基本的垂直导航条" class="headerlink" title="创建基本的垂直导航条"></a>创建基本的垂直导航条</h2><p>在前面的示例中测试用第五章中学到的链接样式技术，就可以创建图形丰富的垂直导航条和 <code>CSS 翻转</code>，如下图所示</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-2.png" alt="6-2"></p><p><center>垂直导航条</center><br><br></p><p>与平常一样 ，首先需要一个良好的语义标记：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home.htm"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.htm"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"service.htm"</span>&gt;</span>Our Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"work.htm"</span>&gt;</span>Our Work<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"news.htm"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"contact.htm"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>首先要做的是去掉默认的项目符号并将外边距和内边距设置为零：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style-type</span>: none<span class="string">'</span></div><div class="line"><span class="string">&#125;</span></div></pre></td></tr></table></figure><p>然后可以开始处理图形样式。在这里，我给导航菜单设置浅绿色的背景和深绿色的边框。还要以 <code>em</code> 为单位设置导航列表的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style-type</span>: none;</div><div class="line">   <span class="attribute">width</span>: <span class="number">8em</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8BD400</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#486B02</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>不对列表项应用样式，而是对其中包含的锚链接应用样式，由此提供更好的浏览器兼容性。<br>为了创建与按钮相似的单击区域，需要将锚的 <code>display</code> 属性设置为 <code>block</code>。然后扩展锚链接，让它占据可用空间（在这里，由列表的宽度决定） 。可以显示地设置锚的宽度，但是我发现如果设置父元素的宽度，代码更容易维护。最后两个规则只是修饰性的，它们设置链接文本的颜色并关闭下划线。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#2B3F00</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了在菜单项上创建鞋面效果，需要把顶边框设置得比背景颜色浅，让底边框深一点儿。现在，还可以设置一个背景图像作为图标。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#2B3F00</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#E4FFD3</span>;</div><div class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#486B02</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/arrow.gif) no-repeat <span class="number">5%</span> <span class="number">50%</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">1em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所有边框叠在另一个链接的顶上，但是最后一个链接的底边框与列表的底边框形成了双线。在这里，我采用简单的方法，去掉列表的底边框。但是，这在某些情况下不可行，那么可以在第一个或最后一个列表项上添加类，这样就可以直接删除边框。以后还可以使用 <code>:last-child</code> 伪类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-class">.last</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">border-bottom</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后还需要应用 <code>:hover</code>、<code>:focus</code>、<code>:selected</code> 状态。为此，只需修改背景和文本颜色。还可以通过修改边框颜色创建按下的按钮效果。当鼠标悬停在锚链接上时，这些样式应用于锚链接。它们还应用于具有 <code>selected</code> 的父列表项中的锚。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-class">.selected</span> <span class="selector-tag">a</span>&#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#E4FFD3</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#6DA203</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在除 <code>Windows</code> 上的 <code>IE 6</code> 和更低版本之外的所有主流浏览器上，这种技术都是有效的。但是，<code>IE 6</code> 在列表项上添加了额外的空间，这令人费解。为了修复这个 bug，需要将列表上的 <code>display</code> 属性设置为 <code>inline</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">display</span>: inline; <span class="comment">/* :KLUDGE: Removes large gaps in IE/Win*/</span></div></pre></td></tr></table></figure><h2 id="在导航条中突出显示当前页面"><a href="#在导航条中突出显示当前页面" class="headerlink" title="在导航条中突出显示当前页面"></a>在导航条中突出显示当前页面</h2><p>在前面的垂直导航条示例中，我使用一个类表示当前页面。对于在页面中嵌入导航的小站点，只需逐个页面地添加这个类。对于大型站点，导航很可能是动态建立的，在这种情况下可以在后端添加类。但是，对于主导航不改变的中等规模的站点，往往通过外部文件包含导航。在这些情况下，如果有办法突出显示当前页面，而不需要动态地在菜单中添加类，那不是很棒吗？是的，用 CSS 可以实现这种效果。</p><p>这个概念的工作方式是，在每个页面的主题元素中添加一个 <code>ID</code> 或 <code>类名</code>，从而之处用户当前在哪个页面或部分中。然后，在导航列表中的每个项添加一个对应的 <code>ID</code> 或 <code>类名</code>。可以使用 <code>主体的 ID</code> 和 <code>列表ID/类</code> 的唯一组合在站点导航中突出显示当前部分或页面。</p><p>以下面的 <code>HTML</code> 片段为例。当前页面是主页，这由主体上的 <code>ID home</code> 表示。主导航中的每个列表项都被分配了一个类名，这个类名根据与列表项相关联的页面的名称而定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span> = <span class="string">"home"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home.htm"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.htm"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"service.htm"</span>&gt;</span>Our Service<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"work.htm"</span>&gt;</span>Our Work<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"news.htm"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"contact.htm"</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>为了突出显示当前页面，只需寻找以下 ID 和类名的组合：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#home</span> <span class="selector-class">.nav</span> <span class="selector-class">.home</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#about</span> <span class="selector-class">.nav</span> <span class="selector-class">.about</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#news</span> <span class="selector-class">.nav</span> <span class="selector-class">.news</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#products</span> <span class="selector-class">.nav</span> <span class="selector-class">.products</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#services</span> <span class="selector-class">.nav</span> <span class="selector-class">.services</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: right bottom;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">cursor</span>: default;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>当用户在主页上时，具有 <code>home</code> 类的导航项将显示为被选择状态；在新闻页面上，具有 <code>news</code> 类的导航项将显示为被选择状态。为了增加效果，我将鼠标光标改为显示默认的箭头样式。这样的话，如果鼠标经过被选择的链接，那么光标不会改变状态，因此不会诱使用户单击当前页面的链接。</p><h2 id="创建简单的水平导航条"><a href="#创建简单的水平导航条" class="headerlink" title="创建简单的水平导航条"></a>创建简单的水平导航条</h2><p>假设有一个搜索结果页面，要创建一个基于页面的简单导航列表，比如下图这样，为此，需要先创建导航项的有序列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"pagination"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"search.htm?page=1"</span> <span class="attr">rel</span>=<span class="string">"prev"</span>&gt;</span>Prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"search.htm?page=1"</span> <span class="attr">rel</span>=<span class="string">"prev"</span>&gt;</span>Prev<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"selected"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"search.htm?page=3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"search.htm?page=4&gt;4&lt;/a&gt;&lt;/li&gt;</span></span></div><div class="line"><span class="tag"><span class="string">   &lt;li&gt;&lt;a href="</span><span class="attr">search.htm</span>?<span class="attr">page</span>=<span class="string">5</span>"&gt;</span>5<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"search.htm?page=3"</span> <span class="attr">rel</span>=<span class="string">"next"</span>&gt;</span>Next<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-3.png" alt="6-3"></p><p><center>水平搜索结果导航条</center><br><br></p><p>注意，我使用 <code>rel</code> 属性表示结果集中的前一个和下一个页面。这是一种非常好的 <code>rel</code> 属性使用方法，在以后给链接设置不同的样式时很方便。</p><p>与本章前面的其他列表示例一样，首先需要去掉默认的浏览器外边距、内边距和列表样式。包括我在内的许多开发人员喜欢在样式表的开头使用 <code>全局reset</code> 来完成这个任务。如果你使用 <code>全局 reset</code>，可以跳过这个步骤。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style-type</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了让列表项水平排列而不是垂直排列，可以吧 <code>display</code> 属性设置为 <code>inline</code>。但是，对于比较复杂的水平列表样式，如果浮动列表项，然后使用外边距把它们分开，就会更灵活。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">   <span class="attribute">margin-right</span>: <span class="number">0.6em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在，列表项都水平显示了，可以开始应用图形样式了。在这里，我希望所有页码都出现在灰色背景的方框中。当用户把鼠标悬停在这些链接上时，我希望背景变成蓝色，链接文本变成白色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">li</span><span class="selector-class">.selected</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.5em</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</div><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">li</span><span class="selector-class">.selected</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: blue;</div><div class="line">   <span class="attribute">color</span>: white;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这对于页码非常合适，但是我希望 <code>prev</code> 和 <code>next</code> 链接的样式稍有不同。为此，我使用属性选择器寻找它们的 <code>rel</code> 属性。我不希望前一个和下一个链接有边框，所以去掉边框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-attr">[rel="prev"]</span>,</div><div class="line"> <span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-attr">[rel="next"]</span> &#123;</div><div class="line">    <span class="attribute">border</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，我还希望在列表的开头和末尾添加箭头。可以在 HTML 中直接编写它们，但是，也可以使用 CSS 注入它们，这样便于以后修改或删除它们。这需要使用 <code>:before</code> 和 <code>:after</code> 伪选择器以及 <code>content</code> 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-attr">[rel="prev"]</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line">   <span class="attribute">content</span>: <span class="string">"\00AB"</span>;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">0.5em</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.pagination</span> <span class="selector-tag">a</span><span class="selector-attr">[rel="next"]</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">   <span class="attribute">content</span>: <span class="string">"\00BB"</span>;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">0.5em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一个声明应用于列表开头的锚链接，它使用字符编码 <code>&quot;00AB&quot;</code> 在这个链接前面添加双左箭头。第二个声明应用于最后一个锚链接，他在这个链接后面添加双右箭头。</p><h2 id="创建图形化导航条"><a href="#创建图形化导航条" class="headerlink" title="创建图形化导航条"></a>创建图形化导航条</h2><p>简单的导航条很适合分页的内容，但是你可能希望为主导航创建图形更丰富的菜单。在这个示例中，我要演示如何创建下图这样的图形化导航条。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-4.png" alt="6-4"></p><p><center>水平导航条</center><br><br></p><p>与前面的示例一样，先建立一个简单的无序列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home.htm"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.htm"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"news.htm"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"products.htm"</span>&gt;</span>Products<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"services.htm"</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"clients.htm"</span>&gt;</span>Clients<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"case-studies.htm"</span>&gt;</span>Case Studies<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>然后将 <code>padding</code> 和 <code>margin</code> 设置为零，并且去掉默认的项目符号，对于这个示例，我想让水平导航条的宽度为 <code>72 em</code>，并且以重复的桔红色渐变作为背景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style</span>: none;</div><div class="line">   <span class="attribute">width</span>: <span class="number">72em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#FAA819</span> <span class="built_in">url</span>(img/mainNavBg.gif) repeat-x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个列表当前是垂直显示的，为了让它水平显示，让列表项向左浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>请记住，当元素浮动时，它不在占据文档流中的任何空间。因此，父列表中实际上没有内容，它就会收缩，从而隐藏列表背景。正如在第三章中学到的，有几种方法可以让父元素包含浮动的子元素，一种方法是添加一个进行清理的元素。但这会在页面中增加不必要的标记，所以应该尽可能避免。另一种方法是让父元素浮动，并且使用某个元素（比如站点页脚）对它进行清理以便换行。第三种方法是使用 <code>overflow:hidden</code> 技术，我通常使用这种方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span>&#123; </div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style</span>: none;</div><div class="line">   <span class="attribute">width</span>: <span class="number">72em</span>;</div><div class="line">   <span class="attribute">overflow</span>: hidden;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#FAA819</span> <span class="built_in">url</span>(img/mainNavBg.gif) repeat-x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与页面导航条示例一样，这个水平导航条中的每个链接的 <code>display</code> 属性也设置为 <code>block</code>，从而让它们表现的像按钮一样。如果希望每个按钮具有固定的尺寸，那么可以显式地设置它的高度和宽度。但是，这会导致可维护性问题，因此我希望每个按钮的宽度由锚文本的尺寸决定。为此，不设置显式的宽度，而是在每个锚链接的左边和右边应用 <code>3em</code> 的内边距。与前面的示例一样，使用行高让链接文本垂直居中。最后，关闭链接下划线并且将链接颜色改为白色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">2em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img.divider.gif) repeat-y left top;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，导航条中的第一个链接会有不必要的分割线，在第一个列表上添加一个雷并且将背景图像设置为 <code>none</code>，就可以去掉它：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-class">.first</span> <span class="selector-tag">a</span>&#123;</div><div class="line">   <span class="attribute">background-image</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>另外，如果你不太在乎 <code>IE 6</code> 的支持问题，也可以不用其他类，而是使用 <code>:first-child</code> 伪类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">background</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，这个示例中的反转状态仅仅是改变链接颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>你应该看见了一个样式漂亮的水平导航条，具有良好的跨浏览器支持。</p><h1 id="简化的”滑动门“标签页式导航"><a href="#简化的”滑动门“标签页式导航" class="headerlink" title="简化的”滑动门“标签页式导航"></a>简化的”滑动门“标签页式导航</h1><p>第四章学习了 Douglas Bowman 的滑动门技术，以及如何使用它创建灵活的圆角框。这种技术也可以用来创建灵活的可扩展的标签页式导航。使用这个方法时，用一个大图像和一个侧边图像创建标签页。随着标签页中文本的扩展，大图像中的更多部分露出来。较小的图像留在左边，盖住大图像的硬边缘，实现下图所示的效果。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-5.png" alt="6-5"></p><p><center>”滑动门“技术的示例</center><br><br></p><p>在以下示例中用来创建标签页的图像。这两个图像都非常大，这允许字号增加几倍，标签页也不会断裂。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-6.png" alt="6-6"></p><p><center>组成标签页的两个图像</center><br><br></p><p>这个示例的 HTML 与前面的水平导航条示例完全一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"home.htm"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"about.htm"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"news.htm"</span>&gt;</span>News<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"products.htm"</span>&gt;</span>Products<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"services.htm"</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"clients.htm"</span>&gt;</span>Clients<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"case-studies.htm"</span>&gt;</span>Case Studies<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>与前面的示例一样，将 <code>margin</code> 和 <code>padding</code> 设置为零，去掉项目符号，并且设置导航条的宽度，还把导航列表的 <code>overflow</code> 设置为 <code>hidden</code> 以便清理内部的浮动元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style</span>: none;</div><div class="line">   <span class="attribute">width</span>: <span class="number">72em</span>;</div><div class="line">   <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与前面的示例一样，列表元素向左浮动，从而让它们水平显示而不是垂直显示。但是这一次，将组成标签页的两个图像中比较大的图像作为背景图像应用于列表项。由于这个图像形成标签页的右边缘，所以将它定位到右边。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img/tab-right.gif) no-repeat right top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与前面的示例一样，锚显示为块级元素以使整个区域可点击。每个标签页的宽度由内容的宽度控制，设置行高可以控制高度。为了完成标签页效果，将标签页的左边图像作为背景应用于锚并且左对齐。当标签页改变尺寸时，这个图像总是对准左边，盖在大图像上面，盖住左边的硬边缘。</p><p>为了创建翻转效果，只需改变链接颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span> <span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>产生的标签页式导航应该像下图这样。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-7.png" alt="6-7"></p><p><center>正常文本字号的”滑动门”标签页式导航</center><br><br></p><p>如果在浏览器中加大文本字号，那么应该会看到标签页扩展了，见下图</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-8.png" alt="6-8"></p><p><center>几次增加文本字号之后的“滑动门”标签页式导航</center><br><br></p><p>用这个方法可以轻松的创建有吸引力的容易访问的标签页式导航条。</p><h1 id="Suckerfish-下拉菜单"><a href="#Suckerfish-下拉菜单" class="headerlink" title="Suckerfish 下拉菜单"></a>Suckerfish 下拉菜单</h1><p>Suckerfish 下拉菜单技术及其简单，只需把自导航嵌套在无序列表中，把列表定位到屏幕之外，然后当鼠标悬停在父列表项上时重新定位它。在下图可以看到最终效果：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-9.png" alt="6-9"></p><p><center>纯 CSS Suckerfish 下拉菜单效果</center><br><br></p><p>首先，建立多层导航列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span> = <span class="string">"nav"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/home/"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/products/"</span>&gt;</span>Products<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/products/sliverback/"</span>&gt;</span>Sliverback<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/products/fontdeck/"</span>&gt;</span>Font Deck<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/services/"</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/services/design/"</span>&gt;</span>Design<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/services/development/"</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/services/consultancy/"</span>&gt;</span>Consultancy<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/contact/"</span>&gt;</span>Contact Us<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>与本章中的所有导航示例一样，首先需要将外边距和内边距设置为零，并且去掉默认的项目符号。因为这应该是一个水平导航，需要给列表项设置宽度并让它们向左浮动。出于格式上的考虑，我希望给导航列表设置边框和背景颜色。但是，因为其中包含的列表项都是浮动的，它们不占据空间，这会导致列表收缩。为了解决这个问题，我也让列表浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span>, <span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">list-style-type</span>: none;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#486B02</span>;</div><div class="line">    <span class="attribute">background-color</span>: <span class="number">#8BD400</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>为了确保下拉菜单中的菜单项垂直对其，需要把列表的宽度设置为与列表项相同。下拉菜单现在初步成型了。</p><p>为了激活之前的隐藏实际的下拉菜单，需要把它们的 <code>position</code> 设置为 <code>absolute</code>，然后把它们隐藏到屏幕左边之外。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">li</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">8em</span>;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">left</span>: -<span class="number">999em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在到了关键之处，在父列表项中添加鼠标悬停伪选择器，把下拉菜单的位置改回正常位置，这样下拉菜单就会重新出现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">   <span class="attribute">left</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后几个样式把导航链接设置为块级元素，然后修改列表的外观，设置背景颜色和斜面边框。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#2B3F00</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.3em</span> <span class="number">1em</span>;</div><div class="line">   <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#486B02</span>; </div><div class="line">   <span class="attribute">border-left</span>: <span class="number">1px</span> solid <span class="number">#E4FFD3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">li</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#E4FFD3</span>;</div><div class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#486B02</span>;</div><div class="line">   <span class="attribute">border-left</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">border-right</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*remove unwanted borders on the end list items*/</span></div><div class="line"><span class="selector-tag">ul</span><span class="selector-class">.nav</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">border-right</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">border-bottom</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">ul</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#E4FFD3</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#6DA203</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这就是想要的效果，一个简单的只使用 CSS 的下拉导航条。这种技术适用于大多数现代浏览器，但是在 IE 的老版本中无效，因为它们不支持在非锚元素上使用 <code>:hover</code> 伪类。为了解决这个问题，可以使用几行 Javascript 或 .htc 行为文件启用这个功能。</p><h1 id="CSS-图像映射"><a href="#CSS-图像映射" class="headerlink" title="CSS 图像映射"></a>CSS 图像映射</h1><p>利用图像映射可以将图像的一些区域指定为热点。图像映射在几年前非常流行，但是近年来不太常见了，因为近几年发展出了更简单、表现性更低的标记。虽然图像映射仍然是 HTML 的有效部分，但是它们将表现形式与内容混在了一起。可以结合使用列表、锚和一些高级 CSS 创建出简单的图像映射。</p><p>对于本节的示例，我使用了 Clearleft 团队的一些成员在办公室外的涂鸦墙模仿独立乐队的一张图片（见下图）。当鼠标悬停在每个人身上时，我希望会出现一个矩形框，单击这个框就会进入这个人的网站。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-10.png" alt="6-10"></p><p><center>Rich、Sophie、Cath、James、和 Paul 在办公室外的涂鸦墙前模仿乐队成员</center><br><br></p><p>首先需要做的是将图片添加到页面中，放在一个已命名的 <code>div</code> 中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imagemap"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/nerdcore.jpg"</span> <span class="attr">width</span>=<span class="string">"333"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">alt</span>=<span class="string">"Some of the Clearleft team"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>然后，在图片后面添加每个人的网站链接的列表。需要给每个列表项分配一个类以便标识到列表项中的人。还可以给每个链接设置 <code>title</code> 属性，其中包含这个人的名字。这样的话，当鼠标悬停在链接上时，在大多数浏览器上显示的工具提示中会显示人名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"imagemap"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/nerdcore.jpg"</span>, <span class="attr">width</span>=<span class="string">"333"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">alt</span>=<span class="string">"Some of the Clearleft team"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"rich"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.clagnut.com/"</span> <span class="attr">title</span>=<span class="string">"Richard Rutter"</span>&gt;</span>Richard Rutter<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"sophie"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wellieswithwings.org/"</span> <span class="attr">title</span>=<span class="string">"Sophie Barrett"</span>&gt;</span>Sophie Barrett<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"cath"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.electricelephant.com/"</span> <span class="attr">title</span>=<span class="string">"Cathy Jones"</span>&gt;</span>Cathy Jones<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"james"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.jeckecko.net/blog/"</span> <span class="attr">title</span>=<span class="string">"James Box"</span>&gt;</span>James Box<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"paul"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://twitter.com/nicepaul"</span> <span class="attr">title</span>=<span class="string">"Paul Annett"</span>&gt;</span>Paul Annett<span class="tag">&lt;/<span class="name">a</span>&gt;</span>        </div></pre></td></tr></table></figure><p>设置 <code>div</code> 的宽度和高度，让它匹配图像的尺寸。然后，将 <code>div</code> 的 <code>position</code> 属性设置为 <code>relative</code>。最后这一步是这种技术的关键，因为它让包含的链接可以相对于 <code>div</code>（也就是图像）的边缘进行绝对定位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">333px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">   <span class="attribute">position</span>: relative; <span class="comment">/* The key to this technique */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为不希望显示项目符号，所以通过将 <code>list-style</code> 属性设置为 <code>none</code> 来去掉它们。为了保持完整性，还可能需要将列表的 <code>margin</code> 和 <code>padding</code> 设置为零；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下一件事情是对链接应用样式。对锚链接进行绝对定位，它们都将移动到 <code>div</code> 的左上角。然后可以将它们分别定位到相应的人身上，形成热点。但是，首先需要设置它们的宽度和高度，从而创建需要的单击区域。链接文本仍然显示，因此，需要使用一个大的附属作为文本缩进量，从而让他们从屏幕上消失。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">   <span class="attribute">text-indent</span>: -<span class="number">1000em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在可以将各个链接定位在相应的人身上；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.rich</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">80px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.sophie</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">90px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.cath</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">140px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">55px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.james</span> <span class="selector-tag">a</span> &#123; </div><div class="line">   <span class="attribute">top</span>: <span class="number">140px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">145px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.paul</span> <span class="selector-tag">a</span> &#123;    </div><div class="line">   <span class="attribute">top</span>: <span class="number">165px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">245px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，为了创建反转效果，将一个白色的实线边框应用于鼠标悬停时的链接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">imagemap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>基本的技术就是这样，如果将鼠标悬停在一个图片上，那么应该会看到与下图相似的情况：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-11.png" alt="6-11"></p><p><center>翻转状态下的 CSS 图像映射</center><br><br></p><h2 id="flickr-风格的图像映射"><a href="#flickr-风格的图像映射" class="headerlink" title="flickr 风格的图像映射"></a>flickr 风格的图像映射</h2><p>如果你使用过图像共享服务 flickr，那么可能见过对图像进行说明的相似技术（见下图）。当翻转加了说明的图像时，在包含每个说明的区域上出现一个双边框的框。当鼠标悬停在这些框上时，它将突出显示并且显示说明。只要稍加修改，就可以使用前面的技术实现这种效果。</p><p>为了创建双边框的框，需要在每个锚链接内部添加两个额外的 <code>span</code>。说明也需要添加一个额外的 <code>span</code>。添加这些额外的 <code>span</code> 之后，列表应该像下面这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">ul</span>&gt;</div><div class="line">   &lt;li class="rich"&gt;</div><div class="line">       &lt;a href="http://www.clagnut.com/"&gt;</div><div class="line">           &lt;span class="outer"&gt;</div><div class="line">           &lt;span class="inner"&gt;</div><div class="line">           &lt;span class="note"&gt;Richard Rutter&lt;/span&gt;</div><div class="line">           &lt;/span&gt;</div><div class="line">           &lt;/span&gt;</div><div class="line">        &lt;/a&gt;</div><div class="line">   &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure><p>CSS 的开头与前面的示例相同，将容器 <code>div</code> 的尺寸设置为图像尺寸，将 <code>position</code> 属性设置为 <code>relative</code>。将列表的 <code>margin</code> 和 <code>padding</code> 设置为零并且去掉项目符号。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">333px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">   <span class="attribute">position</span>: relative; <span class="comment">/* The key to this technique */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与前面一样，包含的锚链接进行绝对定位。但是，这一次要设置内部 <code>span</code> 的尺寸，让外部的 <code>span</code> 和锚链接根据它们确定尺寸。我给外部 <code>span</code> 设置深色边框，给内部 <code>span</code> 设置浅色边框，从而突出显示它们在图像上的位置。最后，我不希望隐藏锚链接中的文本，而是想把它显示为工具提示，因此我给文本设置一些基本样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/shim.gif);</div><div class="line">   <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.outer</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.inner</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block; </div><div class="line">   <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>与前面一样，需要将锚定位到每个人身上：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.rich</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">80px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.sophie</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">90px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.cath</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">140px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">55px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.james</span> <span class="selector-tag">a</span> &#123; </div><div class="line">   <span class="attribute">top</span>: <span class="number">140px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">145px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-class">.paul</span> <span class="selector-tag">a</span> &#123;    </div><div class="line">   <span class="attribute">top</span>: <span class="number">165px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">245px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然后对锚链接应用翻转效果。实现的方法是在鼠标悬停并获得焦点的时候将锚的边框颜色从透明色改为黄色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-tag">imagemap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">border-color</span>: <span class="number">#d4d82d</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了在热点翻转时显示说明，首先需要将说明 <code>span</code> 的内容定位到热点的下面。为此，将说明 <code>span</code> 的位置设置为 <code>absolute</code> 并且将底部位置设置为负值。为了让说明部分更加美观，设置宽度、一些内边距和背景颜色，然后让文本居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.note</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">bottom</span>: -<span class="number">1em</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">7em</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.5em</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#ffc</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果在浏览器中查看这个页面，它应该像下图这样：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-12.png" alt="6-12"></p><p><center>flickr 风格的翻转已经初步成型了</center><br><br></p><p>可以看出，效果已经初步成型了。说明部分看起来不错，但是如果它们在热点下面水平居中，而不是对准左边，就更好了。实现的方法是将说明 <code>span</code> 的左边缘定位到热点的中点；接下来，使用负的外边距值将说明 <code>span</code> 向左移动说明部分宽度的一半。这个示例中的热点有 50 像素宽，所以将说明的左边设置为 50 像素。说明部分有 8em 宽（包括内边距），所以设置 4em 的负的左外边距就会使说明在热点下面水平居中，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.note</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">bottom</span>: -<span class="number">3em</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">7em</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.5em</span>;</div><div class="line">   background-colorL #ffc;</div><div class="line">   <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</div><div class="line">   <span class="selector-tag">left</span>: 25<span class="selector-tag">px</span>;</div><div class="line">   <span class="selector-tag">margin-left</span>: <span class="selector-tag">-4em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在说明已经居中了，应该处理它们的交互性了。在默认情况下，说明应该隐藏起来，只在鼠标悬停在热点上才显示。为此，可以将 <code>display</code> 属性设置为 <code>none</code>，然后在鼠标悬停在锚链接上时将它改为 <code>block</code>。但是，这会使某些屏幕阅读器无法访问说明的内容。所以我不这样做，而是将文本隐藏到屏幕左边之外，并且在鼠标悬停时对它重新定位：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.note</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">bottom</span>: -<span class="number">3em</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">7em</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.5em</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#ffc</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">left</span>: -<span class="number">1000em</span>;</div><div class="line">   <span class="attribute">margin-left</span>: -<span class="number">5em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.note</span> &#123;</div><div class="line">.imagemap a:focus .note &#123;</div><div class="line">   <span class="selector-tag">left</span>: 25<span class="selector-tag">px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在差不多完成了，只需要再做两处调整。如果不是一直显示热点的外边距，而是只在图像翻转时显示边框，那样就更好了。这样的话，人们就可以不受热点的干扰，正常的欣赏图像。但是，当鼠标悬停在图像上显示热点，就能让访问者知道还有更多的信息。实现的方法是在默认情况下把内外 span 的边框设置为透明的，当鼠标悬停在图像上时设置它们的颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.outer</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">a</span> <span class="selector-class">.inner</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid transparent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.imagemap</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">a</span> <span class="selector-class">.inner</span>,</div><div class="line"><span class="selector-class">.imagemap</span><span class="selector-pseudo">:focus</span> <span class="selector-tag">a</span> <span class="selector-class">.inner</span> &#123;</div><div class="line">   <span class="attribute">border-color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="远距离翻转"><a href="#远距离翻转" class="headerlink" title="远距离翻转"></a>远距离翻转</h1><p>远距离翻转是一种鼠标翻转事件，它在页面的其他地方触发显示方式的改变。实现的方法是：在锚链接内嵌套一个或多个元素；然后，使用绝对定位对嵌套的元素进行定位。尽管显示在不同的地方，但是它们都包含在同一个父锚中，所以可以对同一个鼠标悬停事件作出反应。因此，当鼠标悬停在一个元素上时，可以影响另一个元素的样式。</p><p>在这个示例中，我们将扩展 CSS 图像映射技术，在图像下面放一个链接列表。当鼠标悬停在链接上时，图像热点将突出显示。同样，当鼠标悬停在图像上的热点区域时，文本链接也将突出显示。</p><p>这个示例的 HTML 与基本 CSS 图像映射示例相似。但是，需要添加两个 <code>span</code>：一个包围链接文本，一个空的 <code>span</code> 作为热点。由此，链接文本可以定位在图像下面，将热点放在对应的人身上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"remote"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img/nerdcore.jpg"</span> <span class="attr">width</span>=<span class="string">"333"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">alt</span>=<span class="string">"Rich, Sophie, Cath, James and Paul"</span> /&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"rich"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.clagnut.com/"</span> <span class="attr">title</span>=<span class="string">"Richard Rutter"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hotspot"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"link"</span>&gt;</span>&amp;raquo; Richard Rutter<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"sophie"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.wellieswithwings.org/"</span> <span class="attr">title</span>=<span class="string">"Sophie Barrett"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hotspot"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"link"</span>&gt;</span>&amp;raquo; Sophie Barrett<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"cath"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.electricelephant.com/"</span> <span class="attr">title</span>=<span class="string">"Cathy Jones"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hotspot"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"link"</span>&gt;</span>&amp;raquo; Cathy Jones<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"james"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.jeckecko.net/blog"</span> <span class="attr">title</span>=<span class="string">"James Box"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hotspot"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"link"</span>&gt;</span>&amp;raquo; James Box<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">       <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"paul"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.twitter.com/nicepaul"</span> <span class="attr">title</span>=<span class="string">"Paul Annett"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hotspot"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"link"</span>&gt;</span>&amp;raquo; Paul Annett<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">       </div><div class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>基本的列表样式与图片映射示例相同：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.remote</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">333px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.imagemap</span> <span class="selector-tag">ul</span> &#123;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">list-style</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先需要做的是将热点的 <code>position</code> 属性设置为 <code>absolute</code>，然后指定它们的尺寸。在这个示例中，3个热点的尺寸相同，另外两个大一点儿。因此，我先定义默认尺寸，然后在需要的地方覆盖它们。与前一种技术一样，将所有锚定位在图像的左上角。然后使用 <code>top</code> 和 <code>left</code> 定位属性，将每个热点定位到图像中相关的人身上。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span> <span class="selector-class">.hotspot</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">60px</span>;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.rich</span> <span class="selector-tag">a</span> <span class="selector-class">.hotspot</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">50px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">80px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.sophie</span> <span class="selector-tag">a</span> <span class="selector-class">.hotspot</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">90px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">200px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.james</span> <span class="selector-tag">a</span> <span class="selector-class">.hotspot</span> &#123; </div><div class="line">   <span class="attribute">top</span>: <span class="number">140px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">145px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.paul</span> <span class="selector-tag">a</span> <span class="selector-class">.hotspot</span> &#123;    </div><div class="line">   <span class="attribute">top</span>: <span class="number">165px</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">245px</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">60px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">80px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样，包含链接文本的 <code>span</code> 也进行绝对定位，并且将宽度设置为 15em。它们的定位也是相对于包含它们的列表的，在这个示例中，使用负的右位置值定位到图像的右边。最后，给链接设置光标样式，确保在 <code>IE</code> 显示正确的图标。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">10em</span>;</div><div class="line">   <span class="attribute">right</span>: -<span class="number">11em</span>;</div><div class="line">   <span class="attribute">cursor</span>: pointer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.rich</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.sophie</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">1.2em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">remote</span> <span class="selector-class">.cath</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">2.4em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">remote</span> <span class="selector-class">.james</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">3.6em</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.remote</span> <span class="selector-class">.paul</span> <span class="selector-tag">a</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">top</span>: <span class="number">4.8em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>热点和链接文本现在应该会出现在正确的位置上。</p><p>为了在鼠标悬停在热点或文本上时实现翻转效果，当鼠标悬停在父锚上时需要在热点 <code>span</code> 上应用一个边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.hotspot</span>,</div><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> <span class="selector-class">.hotspot</span> &#123;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样，为了在鼠标悬停在文本或热点 <code>span</code> 上时改变文本颜色，当鼠标悬停在父锚上或以其他方式获得焦点时需要改变 <code>span</code> 上的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.link</span>,</div><div class="line"><span class="selector-class">.remote</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> <span class="selector-class">.link</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#0066FF</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果在 Safari 和 Firefox 中测试这个示例，效果会很好（见下图）。如果鼠标悬停在人名上，链接文本会改变颜色，同时图像中这个人身上出现一个框。如果鼠标悬停在图像中某个人身上，也会发生同样的情况。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/6-13.png" alt="6-13"></p><p><center>远距离翻转演示，当图像下面的链接文本翻转时，图像中相关的人身上会出现一个框</center><br><br></p><h1 id="对于定义列表的简短说明"><a href="#对于定义列表的简短说明" class="headerlink" title="对于定义列表的简短说明"></a>对于定义列表的简短说明</h1><p>本章讨论如何用无序列表创建各种效果，但是，还有第三种常常被忽视的列表类型——定义列表，这种列表受到越来越多的关注。定义列表由两个核心组件组成：定义术语 <code>&lt;dt&gt;</code> 和一个或多个定义描述 <code>&lt;dd&gt;</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">dl</span>&gt;</div><div class="line">   &lt;dt&gt;Apple&lt;/dt&gt;</div><div class="line">       &lt;dd&gt;Red, yellow or green fruit&lt;/dd&gt;</div><div class="line">       &lt;dd&gt;Computer company&lt;/dd&gt;</div><div class="line">   &lt;dt&gt;Banana&lt;/dt&gt;</div><div class="line">       &lt;dd&gt;Curved yellow fruit&lt;/dd&gt;</div><div class="line">&lt;/dl&gt;</div></pre></td></tr></table></figure><p>顾名思义，定义列表的主要用途是组成”定义“。但是，HTML 规范相当含糊，它建议可以将定义列表用于产品属性或会话等其他用途。这使”定义“的概念有了一定程度的延伸，但是 HTML 是一种简单的文本格式化语言，在这个上下文中”定义“的意义还是比较明确的。</p><p>以这种风格使用定义列表的理由之一是，没有其他 HTML 元素能够提供这种类型的关联。但是，这不完全正确，因为 <code>div</code> 元素的用途就是把文档分成逻辑部分。更令人担心的是，这个理由与使用表格进行布局的理由完全一样，这使人很担心定义列表开始被滥用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对列表应用样式和创建导航条&quot;&gt;&lt;a href=&quot;#对列表应用样式和创建导航条&quot; class=&quot;headerlink&quot; title=&quot;对列表应用样式和创建导航条&quot;&gt;&lt;/a&gt;对列表应用样式和创建导航条&lt;/h1&gt;&lt;p&gt;列表让我们能够对相关的元素进行分组，并由此给它们添加意义和结构。大多数网页都包含某种形式的列表，比如最近的新闻列表、喜欢的网页的链接列表或到站点其他部分的链接列表。将这些条目标识为列表并且加上标记会在 &lt;code&gt;HTML&lt;/code&gt; 文档中增加结构，提供应用样式的钩子（hook）&lt;br&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>第五章 -- 对链接应用样式</title>
    <link href="https://www.douglasdong.site/2018-01-14.html"/>
    <id>https://www.douglasdong.site/2018-01-14.html</id>
    <published>2018-01-14T13:04:55.000Z</published>
    <updated>2018-08-06T15:02:07.490Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="简单的链接样式"><a href="#简单的链接样式" class="headerlink" title="简单的链接样式"></a>简单的链接样式</h1><p>对链接应用样式最容易的方式是使用锚类型选择器。例如，以下规则使所有锚显示为红色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: red;&#125;</div></pre></td></tr></table></figure><p>但是，锚可以作为内部引用，也可以作为外部链接，所以使用类型选择器不总是理想的。例如，下面的第一个锚包含一个片段标识符，当用户单击这个锚时，页面将跳转到第二个锚的位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">"#mainContent"</span>&gt;</span>Skip to main content<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span> = <span class="string">"mainContent"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><a id="more"></a><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>虽然只想让真正的链接变成红色，但是标题的内容也成了红色的。为了避免这个问题，CSS 提供了两个特殊的选择器，称为链接伪类选择器。 <code>:link</code> 伪类选择器用来寻找没有被访问过的链接，<code>:visited</code> 伪类选择器用来寻找被访问过的链接。所以，在下面的示例中，所有没有被访问过的链接将是懒得色的，所有被访问过的链接将是绿色的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>: blue&#125; <span class="comment">/* Make unvisited link blue */</span></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>: green;&#125;<span class="comment">/* Make visited links green */</span></div></pre></td></tr></table></figure><p>可以用来对链接应用样式的另外两个选择器是 <code>:hover</code> 和 <code>:active</code> 动态伪类选择器用来寻找被激活的元素。对于链接来说，激活发生在链接被单击时。所以，在下面的示例中，当鼠标悬停在链接上单击链接时，链接将变成红色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="attribute">color</span>: red;&#125;</div></pre></td></tr></table></figure><p>为了尽可能提高页面的可访问性，在定义鼠标悬停状态时，最好在链接上添加 <code>:focus</code> 伪类。在通过键盘移动到链接上时，这让链接显示的样式与鼠标悬停时相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">color</span>: red;&#125;</div></pre></td></tr></table></figure><p>其他元素也可以使用 <code>:hover</code>、<code>:active</code>、或 <code>:focus</code> 伪类选择器。例如，可以在表格行上添加 <code>:hover</code> 伪类，在提交按钮上添加 <code>:active</code> 伪类，在输入框上添加 <code>:focus</code> 伪类，从而突出显示各种交互形式。 <code>IE 7</code> 和更低版本不支持在除链接之外的其他元素上使用伪类选择器，但是所有现代浏览器都支持。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* makes table rows yellow when hovered over */</span></div><div class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:hover</span> &#123;</div><div class="line">   <span class="attribute">background</span>: yellow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* make submit buttons in some browsers yellow when pressed */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-attr">[type= "submit"]</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background</span>:yellow;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* make inputs yellow when selected */</span></div><div class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">background</span>:yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="伪类运用"><a href="#伪类运用" class="headerlink" title="伪类运用"></a>伪类运用</h2><p>大多数人最初使用这些选择器做的第一件事就是去掉链接的下划线，然后在鼠标悬停在链接上或单击链接时取消下划线。实现方法是将未访问和已访问的链接的 <code>text-decoration</code> 属性设置为 <code>none</code>，将鼠标悬停其上和已激活的链接的 <code>text-decoration</code> 属性设置为 <code>underline</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">text-decoration</span>: none;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">text-decoration</span>: underline;&#125;</div></pre></td></tr></table></figure><h2 id="选择器次序"><a href="#选择器次序" class="headerlink" title="选择器次序"></a>选择器次序</h2><p>在前面的示例中，选择器的次序非常重要。如果次序反过来，鼠标悬停和激活样式就不起作用了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">text-decoration</span>: underline;&#125;</div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">text-decoration</span>: none;&#125;</div></pre></td></tr></table></figure><p>这是由层叠造成的。在第一章中提到过，当两个规则具有相同的特殊性时，后定义的规则优先。在这个示例中，两个规则具有相同的特殊性，所以 <code>:link</code> 和 <code>:visited</code> 样式将覆盖 <code>:hover</code> 和 <code>:active</code> 样式。为了确保不会发生这种情况，最好按照以下次序应用链接样式:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span></div></pre></td></tr></table></figure><p>记住这个次序的简单方法是记住 <code>Lord Vader Hates Furry Animals</code>，其中的 L 代表 <code>Link</code>，V 代表 <code>visited</code>，H 代表 <code>hover</code>，F 代表 <code>focus</code>，A 代表 <code>active</code>。</p><h1 id="让下划线更有趣"><a href="#让下划线更有趣" class="headerlink" title="让下划线更有趣"></a>让下划线更有趣</h1><p>从易用性和可访问性的角度来说，通过颜色之外的某些方式让链接区别于其他内容是很重要的。这是因为许多有视觉障碍的人很难区分对比不强烈的颜色，尤其是在文本比较小的情况下。例如 ，有色盲症的人无法区分具有相似亮度或饱和度的某些颜色。因此，默认情况下，链接是有下划线的。</p><h2 id="简单的链接修饰"><a href="#简单的链接修饰" class="headerlink" title="简单的链接修饰"></a>简单的链接修饰</h2><p>但是，设计人员往往不喜欢链接的下划线，因为下划线让页面看上去比较乱。如果决定去掉链接的下划线，那么可以让链接显示为粗体。这样的话，页面看起来没那么乱，而链接仍然醒目：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当鼠标悬停在链接上或激活链接时，可以重新应用下划线，从而增强其交互状态：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">text-decoration</span>: underline;</div><div class="line">   <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是，也可以使用边框创建不太影响美观的下划线。在下面的示例中，取消默认的下划线，将它替换为不太显眼的点线。当鼠标悬停在链接上或激活链接时，这条线变成实线，从而向用户提供视觉反馈：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border-bottom</span>: <span class="number">1px</span> dotted <span class="number">#000</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">border-bottom-style</span>: solid;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="奇特的链接下划线"><a href="#奇特的链接下划线" class="headerlink" title="奇特的链接下划线"></a>奇特的链接下划线</h2><p>通过使用图像创建链接下划线，可以产生非常有意思的效果。例如，创建一个非常简单的下划线图像，它由斜线组成 （见下图）。</p><p><br><br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-13.png" alt="5-1-13"></p><p><center>简单的下划线图像 </center><br><br></p><p>可以使用以下代码将这个图像应用于链接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#666</span>;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/underline1.gif) repeat-x left bottom;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在下图中可以看到这个链接样式的效果。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-12.png" alt="5-1-12"></p><p><center>定制的链接下划线</center><br><br></p><p>这种方式并不限于 <code>link</code> 和 <code>visited</code> 样式。在下面的示例中，我为 <code>hover</code> 和 <code>active</code> 状态创建了一个动画 GIF，然后使用以下 CSS 应用它：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus.</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/underline1-hover.gif);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当鼠标悬停在链接上或单击链接时，斜线从左到右滚动出现，这就产生了一种有意思的脉冲效果。并非所有浏览器都支持背景图像动画，但是不支持这个特性的浏览器常常会显示动画的第一帧，这能确保效果在老师浏览器中可以平稳退化。</p><h1 id="已访问链接的样式"><a href="#已访问链接的样式" class="headerlink" title="已访问链接的样式"></a>已访问链接的样式</h1><p>设计人员和开发人员常常忘记处理已访问链接的样式，导致已访问的链接和未访问的链接采用相同的样式。但是，不同的已访问链接样式可以帮助用户，让他们知道哪些页面或站点他们已经访问过了，避免不必要的”回溯“操作。</p><p>通过在每个已访问链接的旁边添加一个复选框，就可以创建一种非常简单的已访问链接的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/check.gif) no-repeat right middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="为链接目标设置样式"><a href="#为链接目标设置样式" class="headerlink" title="为链接目标设置样式"></a>为链接目标设置样式</h1><p>除了链接到特定的文档之外，还可以使用包含片段标识符的链接链接到页面的特定部分。实现的方法是在 <code>href</code> 的末尾加一个 <code>#</code>，然后加上要链接的元素的 <code>ID</code>。这非常适合指向很长的评论页面中的某一评论。例如，假设希望链接到这个页面上的第三个评论：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;a href= "http://example.com/story.htm#comment3"&gt;</div><div class="line">   <span class="selector-tag">A</span> <span class="selector-tag">great</span> <span class="selector-tag">comment</span> <span class="selector-tag">by</span> <span class="selector-tag">Simon</span></div><div class="line">&lt;/a&gt;</div></pre></td></tr></table></figure><p>在单击前面的链接时，就会转到相应的文档，而且页面向下滚动到 <code>comment3</code> 元素。但是，如果页面内容非常多，常常很难看出链接把你转到了哪个元素。为了解决这个问题，CSS 3 允许使用 <code>:target</code> 伪类为目标元素设置样式。在下一个示例中，我要给目标元素设置黄色背景以突出显示它（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.comment</span><span class="selector-pseudo">:target</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果希望更清楚一些，可以给这个元素设置动画背景图像，图像从黄色逐渐褪色为白色，从而模拟 37 Signal 等公司常用的黄色褪色技术。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.comment</span><span class="selector-pseudo">:target</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(img/fade.gif);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-14.png" alt="5-1-14"></p><p><center>使用 <code>:target</code> 选择器后，链接到的第三个评论以黄色背景突出显示</center><br><br></p><p><code>Safari</code> 和 <code>Firefox</code> 的所有近期版本都支持目标选择器，但是 IE 还不支持。</p><h1 id="突出显示不同类型的链接"><a href="#突出显示不同类型的链接" class="headerlink" title="突出显示不同类型的链接"></a>突出显示不同类型的链接</h1><p>在许多站点上，很难看出链接时指向本站点上的另一个页面，还是指向另一个站点。我们曾经都有这样的经历：单击一个链接，期望浏览器转到当前站点上的另一个页面，却被带到了别处。为了解决这个问题，许多站点在新窗口中打开外部链接。但是，这不是好办法，因为它使用户失去了控制能力，而且这些多余的窗口可能会弄乱用户的桌面。如果没有通知用户出现了新窗口，这还会给屏幕阅读器用户造成问题。另外，新窗口实际上无法使用后退按钮，因为不可能返回到前一个屏幕。</p><p>较好的解决方案是让外部链接看起来不一样，让用户自己选择是离开当前站点，还是在新窗口或新的标签页中打开这个链接。为此，可以在外部链接旁边加一个小图标。 wikipedia.com 等站点就是这么做的，而且对于离站链接的图标已经出现了一种约定：一个框加一个箭头（见下图）。</p><p><br><br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-1.png" alt="5-1-1"></p><p><center>外部链接图标</center><br><br></p><p>在页面上包含外部链接的最容易的方法是在所有外部链接上加一个类，然后将图标作为背景图像应用。在下面的示例中，给链接设置少量的右内边距，从而给图标留出空间，然后将图标作为背景图像应用于链接的右上角（见下图）</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-2-1.png" alt="5-1-2"></p><p><center>外部链接样式</center><br><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.external</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/externalLink.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尽管这个方法是有效的，但是它不太灵巧，也不够优雅，因为必须手工地在每个外部链接上添加类。有办法让 CSS 判断链接是否是外部链接吗？实际上，确实有办法，就是使用属性选择器。</p><h2 id="利用-CSS-3-属性选择器实现突出显示"><a href="#利用-CSS-3-属性选择器实现突出显示" class="headerlink" title="利用 CSS 3 属性选择器实现突出显示"></a>利用 CSS 3 属性选择器实现突出显示</h2><p>CSS 3 拓展了属性选择器的功能，提供了子字符串匹配。顾名思义，这些选择器允许通过对属性值的一部分和指定的文本进行匹配来寻找元素。CSS 3 还没有成为正式的规范，所以使用这些高级选择器可能会使代码失效。但是，大多数符合标准的浏览器已经支持这些 CSS 3 选择器了。</p><p>这种技术的工作方式是使用 <code>[att^=val]</code> 属性选择器寻找以文本 <code>http:</code> 开头的所有链接：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http:"]</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/externalLink.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这应该会突出显示所有外部链接。但是，它也会选中使用 <code>绝对 URL</code> 而不是 <code>相对 URL</code> 的内部链接。为了避免这个问题，需要重新设置指向自己站点的所有链接，删除它们的外部链接图标。方法是匹配指向自己域名的链接，删除外部链接图标，重新设置内边距（见下图）。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http://www.yoursite.com"]</span>,</div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="http://yoursite.com"]</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: none;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-3.png" alt="5-1-3"></p><p><center>这个页面对外部链接和内部链接使用不同的样式</center><br><br></p><p>大多数现代浏览器都支持这种技术，而老式浏览器（比如 <code>IE6</code> 或更低版本）会忽略它。</p><p>如果愿意，还可以拓展这种技术，对邮件链接也进行突出显示。在下面的示例中，在所有 <code>mailto</code> 链接上添加一个小的邮件图标：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="mailto:"]</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img/email.png) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>甚至可以突出显示非标准的协议，比如用小的 <code>AIM 图标</code> 突出显示 AIM 即时消息协议（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href^="aim:"]</span> &#123;</div><div class="line">   <span class="attribute">background</span>: url (img/im.png) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"aim:goim?screenname=andybudd"</span>&gt;</span>instant message<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-4.png" alt="5-1-4"></p><p><center>邮件和及时消息链接样式</center><br><br></p><h2 id="突出显示可下载的文档和提要"><a href="#突出显示可下载的文档和提要" class="headerlink" title="突出显示可下载的文档和提要"></a>突出显示可下载的文档和提要</h2><p>另一种烦人的常见情况是，单击一个链接，本以为会进入另一个页面，却发现网站开始下载一个 PDF 或 Microsoft Word 文档。好在 CSS 也可以帮助区分这些类型的链接。这要使用 <code>[att$=val]</code> 属性选择器，它寻找以特定值（<code>.pdf 或 .doc</code>）结尾的属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=".pdf"]</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img/pdfLink.gif) no-repeat right top ;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=".doc"]</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img/wordLink.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>采用与前面示例相似的方式，可以用不同的图标突出显示 Word 文档和 PDF，告诉访问者它们是下载链接而不是另一个页面的链接。</p><p>最后，许多人在自己的网站上提供了 RSS 提要（feed）。访问者可以将这些链接复制到提要阅读器中，但是，无意间单击这些链接就会进入一个页面，其中的数据似乎是没有意义的。为了避免可能发生的混淆，可以通过类似的方法用自己的 RSS 图标突出显示 RSS 提要：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=".rss"]</span>, <span class="selector-tag">a</span><span class="selector-attr">[href$=".rdf"]</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(img/feedLink.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所有这些技术都有助于改进用户在站点上的浏览体验。通过提醒用户注意离站链接或可下载的文档，让他们明确地了解在单击链接时会发生的情况，避免了不必要的回溯操作和烦恼。</p><p>PS：<code>IE6</code> 和更低的版本不支持属性选择器，但是可以通过在每个元素中添加类，使用 JavaScript 和 DOM 实现相似的效果。最好的方法之一是使用 Simon Willison 编写的 <code>getElementBySelector</code> 函数，另外，<code>jQuery</code> 也可以做类似的事情。</p><h1 id="创建类似按钮的链接"><a href="#创建类似按钮的链接" class="headerlink" title="创建类似按钮的链接"></a>创建类似按钮的链接</h1><p>希望实现类似按钮效果，并拥有更大的可单击区域时，可以将锚的 <code>display</code> 属性设置为 <code>block</code>， 然后修改 <code>width</code>、<code>height</code> 和其他属性来创建需要的样式和单击区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">6.6em</span>;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">1.4</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#66a330</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8cca12</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>产生的链接应该像下图这样</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-5.png" alt="5-1-5"></p><p><center>与按钮相似的链接样式</center><br><br></p><p>由于链接现在显示为块级元素，单击块中的任何地方都会激活链接。</p><p>从这段 CSS 可以看到宽度是以 <code>em</code> 为单位显式设置的。由于其性质，块级元素会扩展，填满可用的宽度，所以如果它们父元素的宽度大于链接所需要的宽度，那么需要将希望的宽度应用于链接。如果希望在页面的主内容区域中使用这种样式的链接，就很可能出现这种情况。但是，如果这种样式的链接出现在宽度比较窄的地方，如边栏中，那么可能只需设置边栏的宽度，而不需要为链接的宽度担心。</p><p>使用 <code>line-height</code> 取代 <code>height</code> 来控制按钮的高度是为了能够使按钮中的文本垂直居中。如果设置 <code>height</code> ，就必须使用内边距将文本压低，模拟出垂直居中的效果。但是，文本在行框中总是垂直居中的，所以如果使用 <code>line-height</code>，文本就会出现在框的中间。但是，有一个缺点。<strong>如果按钮中的文本占据两行，按钮的高度就是需要的高度的两倍。避免这个问题的唯一方法是调整按钮和文本的尺寸，让文本不换行，至少在文本字号超过合理值之前不会换行。</strong></p><p>如果选用这种技术，那么要确保元素是真正的链接，而不要更新服务器。否则，可能会出现意外的结果。在 Google 加速程序启动时，人们发现 CMS 或 Web 应用程序中的内容神秘的消失了。有时候，站点的全部内容在一夜之间就消失了。<strong>这是因为这些工具的开发人员使用锚链接而不是用表单元素作为删除按钮。Google 加速程序会访问这些链接以便缓存他们，这样就会无意间删除内容！搜索引擎的 <code>spider</code> 可以造成相同的结果，递归的删除大量数据，因此，绝不要使用链接更新服务器。或者用技术术语来说，链接应该只用于 <code>GET 请求</code> ，决不要用于 <code>POST 请求</code>。</strong></p><h2 id="简单的翻转"><a href="#简单的翻转" class="headerlink" title="简单的翻转"></a>简单的翻转</h2><p>在过去，人们使用庞大且过分复杂的 Javascript 函数实现翻转效果。现在，使用 <code>:hover</code> 伪类就可以创建翻转效果，而不需要使用 Javascript。可以扩展前面的示例，在鼠标悬停时设置链接的背景和文本颜色，从而实现非常简单的翻转效果（见下图）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#f7a300</span>;</div><div class="line">   <span class="attribute">border-color</span>: <span class="number">#ff7400</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-6.png" alt="5-1-6"></p><p><center>显示激活区域的鼠标悬停样式</center><br><br></p><h2 id="图像翻转"><a href="#图像翻转" class="headerlink" title="图像翻转"></a>图像翻转</h2><p>修改背景颜色对于简单的按钮很合适，但是对于比较复杂的按钮，你可能会想到使用背景图像。在下一个示例中，我创建了 3 个按钮图像，一个用于<code>默认状态</code>，一个用于<code>鼠标悬停和焦点状态</code>，一个用于<code>激活状态</code>（见下图）。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-7.png" alt="5-1-7"></p><p><center><code>正常状态</code>、<code>鼠标悬停状态</code>和<code>激活状态</code>的图像</center><br><br></p><p>这个示例的代码和前面的示例相似，主要的差异是使用的是背景图像而不是背景颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">203px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">72px</span>;</div><div class="line">   <span class="attribute">text-indent</span>: -<span class="number">1000em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/button.png) left top no-repeat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/button-over.png);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/button-active.png);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个示例使用固定宽度和高度的按钮，所以我在 CSS 中设置显式的像素尺寸。为了实现我希望的文本效果，我把按钮文本放在图像上，然后使用大的负文本缩进隐藏锚文本。但是，也可以创建特大的按钮图像，或者结合使用背景颜色和图像创建流式的或弹性的按钮。</p><h2 id="Pixy-样式的翻转"><a href="#Pixy-样式的翻转" class="headerlink" title="Pixy 样式的翻转"></a>Pixy 样式的翻转</h2><p>多图像方法的主要缺点是，在浏览器第一次加载鼠标悬停的图像时有短暂的延迟。这会造成闪烁效果，让人感觉按钮有点儿反应迟钝。可以将鼠标悬停的图像作为背景应用于父元素，从而预先加载它们。但是，有一种方法：<code>不切换多个背景图像，而是使用一个图像并切换它的背景位置</code>。使用单个图像的好处是减少了服务器请求的数量，而且可以将所有状态放在一个地方。这个方法被称为 Pixy 方法，Pixy 是它的发明者 Petr Stanicek 的昵称。</p><p>首先，创建组合的按钮图像（见下图）。在这个示例中，只使用<code>正常状态</code>、<code>鼠标悬停状态和激活状态</code>，但是如果愿意，也可以使用<code>已访问状态</code>。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-8.png" alt="5-1-8"></p><p><center>用一个图像表示这些按钮状态</center><br><br></p><p>代码几乎与之前的示例相同。但是，这一次背景图像的对齐方式是：<strong>正常状态下，背景图像在中间；鼠标悬停状态下，背景图像在右边；激活状态下，背景图像在左边。</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">203px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">72px</span>;</div><div class="line">   <span class="attribute">text-indent</span>: -<span class="number">1000em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/buttons.png) -<span class="number">203px</span> <span class="number">0</span> no-repeat;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: right top;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可惜，即使只是改变图像的对齐方式，Windows 上的 <code>IE</code> 仍然会向服务器请求新的图像。这会产生轻微的闪烁 ，有点儿烦人。为了避免闪烁，需要<strong>将翻转状态应用于链接的父元素</strong>，例如包含它的段落。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/button.png) no-repeat right top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在图像重新加载时，它仍然会消失一段时间。但是，现在会露出相同的图像，消除了闪烁。</p><p>消除闪烁的另一种方式是在 <code>IE</code> 专用的 CSS 文件中包含以下代码，这会启用背景缓存。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">html</span> &#123;</div><div class="line">   <span class="attribute">filter</span>: <span class="built_in">expression</span>(document.execCommand(<span class="string">"BackgroundImageCache"</span>, false, true));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="CSS-精灵"><a href="#CSS-精灵" class="headerlink" title="CSS 精灵"></a>CSS 精灵</h2><p>多个服务器请求会对站点的性能产生显著的影响，所以 Pixy 方法把所有按钮状态包含在一个图像中，从而减少请求数量。但是，为什么要就此止步呢？为什么不更进一步，把所有图标甚至站点导航都包含在一个图像中？这样就可以把对多个图像的服务器调用数量减少到二三个。这就是 <code>CSS 精灵</code> — 包含许多不同的图标、按钮或图形的单个图像。许多大型网站使用这种技术，包括 Yahoo！的主页。实际上，我们的 Clearleft 站点导航也使用这种技术（见下图）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">text-indent</span>: -<span class="number">9999px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">119px</span>;</div><div class="line">   width 100px;</div><div class="line">   background-image: url('/img/nav.png');</div><div class="line">   <span class="selector-tag">background-repeat</span>: <span class="selector-tag">no-repeat</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.home</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">0</span> -<span class="number">119px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: -<span class="number">100px</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>,</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span><span class="selector-class">.who-we-are</span> <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</div><div class="line">   <span class="attribute">background-position</span>: -<span class="number">100px</span> -<span class="number">119px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-9.png" alt="5-1-9"></p><p><center>Clearleft 站点上使用的 CSS 精灵文件</center><br><br></p><p>使用这种技术可以减少 Web 浏览器发出的服务器请求，这会显著加快下载速度。另外，使用精灵把所有按钮、图标和各种图形集中在一个地方可以提高可维护性。所以这是一种非常好的方法。</p><h2 id="用-CSS-3-实现翻转"><a href="#用-CSS-3-实现翻转" class="headerlink" title="用 CSS 3 实现翻转"></a>用 CSS 3 实现翻转</h2><p>CSS 3 包含 <code>text-shadow</code>、 <code>box-shadow</code>、 和 <code>border-radius</code> 等属性，可以创建样式很丰富的按钮，而不需要使用任何图像。为了创建这种按钮，我首先复制第一个案例中的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">6.6em</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">1.4em</span>;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">1.4</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#66a300</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8cca12</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来，添加曲线边框和投影。我还要让按钮文本有点儿投影（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">6.6em</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">1.4em</span>;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">1.4</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#66a330</span>;</div><div class="line">   <span class="attribute">-moz-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">-webkit-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8cca12</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#66a330</span>;</div><div class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-5-1.png" alt="5-1-5"></p><p><center>只使用 CSS 实现的圆角按钮</center><br><br></p><p>为了实现渐变，<code>Safari 4 beta</code> 版支持专有的值 <code>-webkit-gradient</code>。尽管我一般不建议使用专有的代码，但是这可以展示 CSS 以后的发展。这个专有的值包含几个参数，包括渐变的类型（直线或放射状）、渐变的方向（在这里是左上到左下）、初始颜色、结束颜色和中间的过渡点。显然，如果不希望使用这种专有的代码，可以使用渐变的背景图像。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">6.6em</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">1.4em</span>;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">1.4</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#66a300</span>;</div><div class="line">   <span class="attribute">-moz-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">-webkit-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">-webkit-gradient</span>(linear, left top, left bottom, from(#abe142), <span class="built_in">to</span>(#67a400));</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8cca12</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#66a300</span>;</div><div class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后，<code>Safari</code> 还提供另一个称为 <code>box-reflect</code> 的专有属性，顾名思义，它可以创建对象的倒影。这个属性包含多个参数，包含倒影的位置和距离以及蒙版图像。有意思的是，可以使用 <code>-webkit-gradient</code> 值自动地生成这个模板。在这里，我把倒影定位在按钮下面 <code>2px</code>，并且使用一个褪到白色的蒙版（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">width</span>: <span class="number">6.6em</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">1.4em</span>;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">1.4</span>;</div><div class="line">   <span class="attribute">text-align</span>: center;</div><div class="line">   <span class="attribute">text-decoration</span>: none;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#66a330</span>;</div><div class="line">   <span class="attribute">-moz-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">-webkit-border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">6px</span>;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">-webkit-gradient</span>(linear, left top, left bottom, from(#abe142), <span class="built_in">to</span>(#67a400));</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#8cca12</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">text-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#66a300</span>;</div><div class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#ccc</span>;</div><div class="line">   <span class="attribute">-webkit-box-reflect</span>: below <span class="number">2px</span> <span class="built_in">-webkit-gradient</span>(linear, left top, left bottom, from(transparent), <span class="built_in">color-stop</span>(0.52, transparent), <span class="built_in">to</span>(white));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-10.png" alt="5-1-10"></p><p><center>使用 Safari 专有 CSS 扩展实现的圆角按钮</center><br><br></p><h1 id="纯-CSS-工具提示"><a href="#纯-CSS-工具提示" class="headerlink" title="纯 CSS 工具提示"></a>纯 CSS 工具提示</h1><p>工具提示是当鼠标悬停在具有 <code>title</code> 属性的元素上时一些浏览器弹出的黄色小文本框。通过使用 CSS 定位技术，可以创建纯 CSS 工具提示。这种技术需要符合标准的现代浏览器（比如 <code>Firefox</code>）才能正确的工作。因此，它不是日常使用的技术。但是，它演示了高级 CSS 的能力，让你能够体会一下当 CSS 得到更好支持之后会是什么情况。</p><p>先需要创建结构良好且有意义的 <code>HTML</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.andybudd.com/"</span> <span class="attr">class-</span>"<span class="attr">tooltip</span>"&gt;</span>Andy Budd<span class="tag">&lt;<span class="name">span</span>&gt;</span> (This websit rocks) <span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> is a web developer based in Brighton England.</div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure><p>这个链接设置的类名为 <code>tooltip</code>，以便从其他链接中区分出来。在这个链接中，添加希望显示为链接文本的文本，然后添加包围在 <code>span</code> 中的工具提示文本。我将工具提示包围在圆括号中，这样的话在样式关闭的时候这个句子仍然是有意义的。</p><p>首先需要做的是将锚的 <code>position</code> 属性设置为 <code>relative</code>。这样就可以相对于父元素的位置对 <code>span</code> 的内容进行绝对定位。因为不希望工具显示一开始就显示出来，所以应该将它的 <code>display</code> 属性设置为 <code>none</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-class">.tooltip</span> &#123;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">a</span><span class="selector-class">.tooltip</span> <span class="selector-tag">span</span> &#123;</div><div class="line">   <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当鼠标悬停在这个锚上时，表示希望显示 <code>span</code> 的内容。方法是将 <code>span</code> 的 <code>display</code> 属性设置为 <code>block</code>，但是只是在鼠标悬停在这个链接上才这样做。</p><p>为了让 <code>span</code> 的内容出现在锚的右下方，需要将 <code>span</code> 的 <code>position</code> 属性设置为 <code>absolute</code>，并且将它定位在距离锚顶部 <code>1em</code>，距离左边 <code>2em</code> 的地位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">span</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">top</span>: <span class="number">1em</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这就是这种技术的主体部分，余下的工作是添加一些样式让 <code>span</code> 看起来更像是工具提示。可以给 <code>span</code> 加一些内边距、一个边框和背景颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-class">.tooltip</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">span</span>, <span class="selector-tag">a</span><span class="selector-class">.tooltip</span><span class="selector-pseudo">:focus</span> <span class="selector-tag">span</span> &#123;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">position</span>: absolute;</div><div class="line">   <span class="attribute">top</span>: <span class="number">1em</span>;</div><div class="line">   <span class="attribute">left</span>: <span class="number">2em</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0.2em</span> <span class="number">0.6em</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#996633</span>;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#FFFF66</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在 <code>Firefox</code> 中查看，效果应该如下：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/5-1-11.png" alt="5-1-11"></p><p><center>纯 CSS 工具提示</center><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的链接样式&quot;&gt;&lt;a href=&quot;#简单的链接样式&quot; class=&quot;headerlink&quot; title=&quot;简单的链接样式&quot;&gt;&lt;/a&gt;简单的链接样式&lt;/h1&gt;&lt;p&gt;对链接应用样式最容易的方式是使用锚类型选择器。例如，以下规则使所有锚显示为红色：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; &amp;#123;&lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: red;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是，锚可以作为内部引用，也可以作为外部链接，所以使用类型选择器不总是理想的。例如，下面的第一个锚包含一个片段标识符，当用户单击这个锚时，页面将跳转到第二个锚的位置：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;#mainContent&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Skip to main content&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&quot;mainContent&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Welcome&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;h1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>第四章 -- 背景图像效果</title>
    <link href="https://www.douglasdong.site/4-1.html"/>
    <id>https://www.douglasdong.site/4-1.html</id>
    <published>2017-11-19T14:23:55.000Z</published>
    <updated>2018-08-06T15:02:24.245Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>对 image 标签的滥用导致纯修饰性的图像把页面弄乱了。好在 CSS 使我们能够在页面上显示图像，而不需要让图像成为标记的一部分，即将图像作为背景添加到现有的元素中。本章将通过一系列实际示例讲解如何使使用背景图像创建各种有意思且有用的技术。</p><p>本章将介绍以下内容：</p><ul><li>固定宽度和可变宽度的圆角框</li><li>滑动门技术</li><li>多个背景图像和 <code>border-radius</code> 属性</li><li>CSS 投影</li><li>不透明度和 RGBa</li><li>让 PNG 适用于 <code>IE</code> 的老版本</li><li>视差滚动</li><li>图像替换</li></ul><a id="more"></a><h1 id="背景图像基础"><a href="#背景图像基础" class="headerlink" title="背景图像基础"></a>背景图像基础</h1><h2 id="如何设立背景图像"><a href="#如何设立背景图像" class="headerlink" title="如何设立背景图像"></a>如何设立背景图像</h2><p>应用背景图像是很容易的。如果希望网站有一个好看的背景，那么只需将图像作为背景应用于主题元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123; </div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/pattern.gif);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>默认情况下，浏览器水平和垂直地重复显示背景图像</strong>，让图像平铺在整个页面上。可以选择背景图像是水平平铺、垂直平铺，还是根本不平铺。</p><h2 id="背景图像使用案例"><a href="#背景图像使用案例" class="headerlink" title="背景图像使用案例"></a>背景图像使用案例</h2><p>目前渐变非常时髦， <em>你可能希望在页面上应用垂直渐变。</em> 为此，需要<strong>创建一个很高但很窄的渐变图像，然后将这个图像应用于页面的主体并让它水平平铺</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123; </div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/gradient.gif);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为这个渐变图像的高度是固定的，所以<strong>如果页面内容的长度超过了图像的高度，那么渐变就会突然终止</strong>。 <em>可以创建一个非常长的图像，逐渐变化到一个固定的颜色。但是，很难预测到页面会有多长</em> 。<br><strong>实际上，只需再添加一个背景颜色即可</strong>。背景图像会叠加在背景颜色的上面，<strong>当图像结束时，被叠加的颜色就会显示出来了</strong>。如果背景颜色与渐变底部的颜色相同，那么图像和背景颜色之间的转换就看不出来了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123; </div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/gradient.gif);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="单独运用背景图像"><a href="#单独运用背景图像" class="headerlink" title="单独运用背景图像"></a>单独运用背景图像</h2><p>平铺图像在某些情况下会很有用。但是，在大多数情况下，需要在页面上添加不是平铺的图像。假设我们希望在网页的开头显示一个大的品牌图像，那么在大多数情况下，将图像直接添加到页面上就够了。 <em>但是，如果图像不包含信息，是纯表现性的，那么可能希望将图像从其余内容中分离出来。</em> <strong>实现的方法是在 <code>HTML</code> 中为这个图像创建一个 ”钩子“ （单独创建一个 <code>div</code> ），然后使用 CSS 加载这个图像。</strong></p><p>在下面的示例中，我在标记中添加一个空的 <code>div</code> 并且给它设定 <code>ID:branding</code> 。然后可以将这个 <code>div</code> 的尺寸设置为与品牌图像相同，作为背景应用并指定不重复。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#branding</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">700px</span>;</div><div class="line">   <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/branding.gif)</div><div class="line">   background-repeat: no-repeat;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="图像位置"><a href="#图像位置" class="headerlink" title="图像位置"></a>图像位置</h2><p>还可以设置背景图像的位置。假设要在站点的每个标题上添加一个项目符号，可以编写下面这样的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">30px</span>;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bullet.gif);</div><div class="line">   <span class="attribute">background-repeat</span>: no-repeat;</div><div class="line">   <span class="attribute">background-position</span>: left center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/4-1.png" alt="4-1"></p><p></p><p align="center">使用背景图像创建项目符号</p><br><br><p></p><p><strong>最后两个关键字指出图像的位置</strong>。在这个实例中， <em>图像定位在元素的左边且垂直居中</em> 。除了使用关键字以外，<strong>还可以使用像素或百分数等单位设置背景图像的位置。</strong></p><p>如果使用像素设置背景位置，那么图像左上角到元素左上角的距离为指定的像素数。所以，<strong>如果指定垂直和水平位置都是 20 像素，那么图像左上角将出现在元素左上角下面 20 像素、左边 20 像素的地方。</strong></p><p>但是，使用百分数进行背景定位的工作方式不太一样。 <em>百分数定位并不对背景图像的左上角进行定位，而是使用图像上的一个对应点</em> .<strong>所以，如果指定垂直和水平位置都是 20%，那么实际上是在将图像上距离左上角 20% 的点定位到父元素上距离左上角 20% 的位置。</strong></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/4-2.png" alt="4-2"></p><p>如果希望使用百分数而不是关键字实现前面的示例，那么<strong>需要将垂直位置设置为 50%，这会使项目符号图像垂直居中</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">30px</span>;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bullet.gif);</div><div class="line">   <span class="attribute">background-repeat</span>: no-repeat;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">50%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="为何不能混用单位和关键字？"><a href="#为何不能混用单位和关键字？" class="headerlink" title="为何不能混用单位和关键字？"></a>为何不能混用单位和关键字？</h2><p>规范指出，<strong>不要将像素或百分数等单位和关键字混合使用</strong>。这似乎是一个没有意义的规则，而且许多现代浏览器故意忽略了这个规则。但是，<strong>混合使用单位和关键字在某些浏览器上会导致错误，而且很可能使 CSS 失效</strong>。因此，最好不要混合使用单位和关键字。</p><h2 id="background-属性简写版本"><a href="#background-属性简写版本" class="headerlink" title="background 属性简写版本"></a>background 属性简写版本</h2><p>为了简便，<strong>CSS 还提供了 <code>background</code> 属性的简写版本</strong>。可以通过它同时设置所有属性，不需要分别设置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#ccc</span> <span class="built_in">url</span>(/img/bullet.gif) no-repeat left center;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>尽管背景图像是一个容易掌握的概念，但是它们是许多高级 CSS 技术的基础。</p><h1 id="圆角框"><a href="#圆角框" class="headerlink" title="圆角框"></a>圆角框</h1><p>对基础 CSS 最初的批评意见之一是 CSS 太死板了，只能建立方框。为了解决这个问题，人们开始创建具有曲线的设计。圆角框很快成为最时髦的 CSS 技术之一。创建圆角框有好几种方法。每种方法各有优缺点，对这些方法的选择主要取决于实际情况。</p><h2 id="固定宽度的圆角框"><a href="#固定宽度的圆角框" class="headerlink" title="固定宽度的圆角框"></a>固定宽度的圆角框</h2><p>最容易创建的是固定宽度的圆角框。它们<strong>只需要两个图像：一个图像用于框的顶部，另一个用于底部</strong>。例如，假设要创建下图这样的框样式。</p><p>这个框的 <code>HTML</code> 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Headline<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>需要用图形软件创建两个下图这样的图像：一个图像用于框的顶部，另一个用于底部</p><p><br></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/4-4-1.gif" alt="4-4-1"></p><center>bottom</center><br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/4-4-2.gif" alt="4-4-2"><br><center>top</center><p><br></p><p>然后，<strong>将顶部图像应用于标题元素，将底部图像应用于 <code>div</code> 框的底部</strong>。因为这个框样式是单色的，所以可以在 <code>div</code> 框上添加背景颜色，从而形成框的主体。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">418px</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#effce7</span> <span class="built_in">url</span>(/img/bottom.gif) no-repeat left bottom;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top.gif) no-repeat left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们<strong>不希望内容碰到框的边界，所以还需要在 <code>div</code> 中的元素上添加一些内边距：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">418px</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#effce7</span> <span class="built_in">url</span>(/img/bottom.gif) no-repeat left bottom;</div><div class="line">   <span class="attribute">padding-bottom</span>: <span class="number">1px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top.gif) no-repeat left top;</div><div class="line">   <span class="attribute">margin-top</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最终形成的圆角框样式如下：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/4-3.png" alt="4-3"></p><p><center>简单的圆角框样式</center><br><br></p><p>这个方法对于单色而且没有边框的简单框是有效的。但是， <strong>如果希望创建像下图这样更生动的样式，该怎么办？</strong></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.09.46.png" alt="屏幕截图 2017-11-23 23.09.46"></p><p><center>样式更特殊的圆角框</center><br><br></p><p>实际上，可以使用相同的方式，但是 <em>这一次不在框上设置背景颜色，而是设置一个重复显示的背景图像。还需要将底部曲线图像应用到另一个元素上。</em> 在这个示例中，我使用框的最后一个段落元素：</p><p><br><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Headline<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"last"</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">424px</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/tile2.gif) repeat-y;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top2.gif) no-repeat left bottom;</div><div class="line">   <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-class">.last</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/bottom2.gif) no-repeat left bottom;</div><div class="line">   <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span>, <span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.11.15.png" alt="屏幕截图 2017-11-23 23.11.15"></p><p><center>框随着文本尺寸的增加而垂直扩展</center><br><br></p><p>上图所示为生成的框。<strong>因为没有给这个框设置高度，所以它会随着文本尺寸的增加进行垂直扩展。</strong></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.17.31.png" alt="屏幕截图 2017-11-23 23.17.31"></p><p><center>应用了样式的固定宽度框。框的高度会随着文本尺寸的增加而扩展</center><br><br></p><h2 id="灵活的圆角框"><a href="#灵活的圆角框" class="headerlink" title="灵活的圆角框"></a>灵活的圆角框</h2><p><em>如果加大文本字号，前面的示例都会垂直扩展。但是，它们不会水平扩展，因为框的宽度必须与底部图像的宽度一致</em> 。 如果希望创建灵活的框，那么需要采用略有不同的方法。不要用一个图像组成顶部和底部曲线，而<strong>应用两个相互重叠的图像</strong>。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/Group 2.png" alt="Group 2"></p><p><center>如何扩展顶部图像来形成灵活的圆角框</center><br><br></p><p>随着框尺寸的增加，大图像有更多的部分显露出来，这样就实现了框拓展的效果。这个方法有时候被称为滑动门技术<code>（Sliding doors technique）</code>，因为一个图像在另一个图像上滑动，将它的一部分隐藏了起来。<strong>这个方法需要更多的图像，所以必须在标记中添加两个额外的无语义元素</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-outer"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-inner"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Headline<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>这个方法需要 4 个图像：两个顶部图像组成顶部曲线，两个底部图像组成底部曲线和框的主体（见图 4-8）。因此，<strong>底部图像的高度必须与框的最大高度相同</strong>。分别将这些图像命名为 <code>top-left.gif</code>、<code>top-right.gif</code>、<code>bottom-left.gif</code>、<code>bottom-right.gif</code>。</p><p>首先，将 <code>bottom-left.gif</code> 应用于主框 <code>div</code>，将 <code>bottom-right.gif</code> 应用于外边的 <code>div</code>。接下来，将 <code>top-left.gif</code> 应用于内部的 <code>div</code>，将 <code>top-right.gif</code> 应用于标题。最后，添加一些内边距以便在内容周围形成一点空白。</p><p><br><br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">20em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#effce7</span> <span class="built_in">url</span>(/img/bottom-left.gif) no-repeat left bottom;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-outer</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/bottom-right.gif) no-repeat right bottom;</div><div class="line">   <span class="attribute">padding-bottom</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-inner</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top-left.gif) no-repeat left top;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top-right.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-top</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span>, <span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">1em</span>;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/Group.png" alt="Group"></p><p><center>创建灵活的圆角框所需的图像</center><br><br></p><p><em>在这个示例中，我以 <code>em</code> 为单位设置框的宽度，所以在浏览器中增加文本尺寸时框会伸展（见图 4-9）</em> 。当然，可以用百分数设置宽度，这使框根据浏览器窗口的尺寸进行扩展或收缩。这是弹性和流式布局背后的主要原则之一。</p><h2 id="山顶角"><a href="#山顶角" class="headerlink" title="山顶角"></a>山顶角</h2><p>山顶角（mountaintop corner）是一个简单但非常灵活的概念。若要创建一系列具有不同颜色的圆角框，用之前的方法就必须为每种颜色方案创建不同的角图像。如果只有几个图像，那么这个方法也可以，但是，如果想让用户创建自己的颜色方案，那么应该怎么办？可能必须在服务器上动态地创建角图像，这非常复杂。</p><p>幸好还有另一个方法，<strong>不用创建有颜色的角图像，而是创建曲线形的位图角蒙版（见下图）</strong>。 <em>蒙版区域盖住你正在使用的背景颜色，而角区域实际上是透明的。当放在有颜色的框上时，它们就会形成曲线框的效果（见下图）。</em></p><p><br><br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/Group-4.png" alt="Group-4"></p><p><center>位图角蒙版。白色的蒙版将覆盖背景颜色，产生简单的曲线效果</center><br><br></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.25.58.png" alt="屏幕截图 2017-11-23 23.25.58"></p><p><center>山顶角框</center><br><br></p><p>因为这些角蒙版是位图，所以<strong>对于小曲线效果最好。如果使用大曲线，那么它会出现锯齿，不好看</strong>。</p><p>基本代码于前一个方法相似，它<strong>需要 4 个元素来应用 4 个角蒙版</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-outer"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box-inner"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Headline<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>CSS 也非常相似：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">width</span>: <span class="number">20em</span>;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#effce7</span> <span class="built_in">url</span>(/img/bottom-left.gif) no-repeat left bottom;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-outer</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/bottom-right.gif) no-repeat right bottom;</div><div class="line">   <span class="attribute">padding-bottom</span>: <span class="number">5%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box-inner</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top-left.gif) no-repeat left top;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/top-right.gif) no-repeat right top;</div><div class="line">   <span class="attribute">padding-top</span>: <span class="number">5%</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">h2</span>, <span class="selector-class">.box</span> <span class="selector-tag">p</span> &#123;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">5%</span>;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">5%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>除了使用不同的图像之外，主要的差异是在主框 <code>div</code> 上添加了背景颜色。如果要修改框的颜色，只需修改 CSS 中的颜色值，不必重新创建任何新图像。这个方法只适合创建非常简单的框，但是它提供了很大的灵活性，而且可以在不同的项目中重复使用。</p><h3 id="多个背景图像"><a href="#多个背景图像" class="headerlink" title="多个背景图像"></a>多个背景图像</h3><p>前面的示例，大多数都必须在代码中添加非语义标记。需要这些多余的标记是因为自一个元素中只能添加一个背景图像。如果可以添加多个背景图像，那不是很方便吗？</p><p>这可以通过 CSS3 实现，另外，语法十分简单，<strong>它采用与一般背景图像相同的形式。主要差异是，不是定义一个背景图像，而是可以使用任意数量的图像</strong>。具体做法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/top-left.gif),<span class="built_in">url</span>(img/top-right.gif),<span class="built_in">url</span>(/img/bottom-left.gif),<span class="built_in">url</span>(/img/bottom-right.gif);</div><div class="line">    <span class="attribute">background-repeat</span>: no-repeat,np-repeat,no-repeat,no-repeat;</div><div class="line">   <span class="attribute">background-position</span>: top left,top right,bottom left,bottom right; </div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box&gt;</span></span></div><div class="line"><span class="tag"><span class="string">   &lt;h2&gt;Headline&lt;/h2&gt;</span></span></div><div class="line"><span class="tag"><span class="string">   &lt;p&gt;Content&lt;/p&gt;</span></span></div><div class="line"><span class="tag"><span class="string">&lt;/div&gt;</span></span></div></pre></td></tr></table></figure><p>首先，使用 <code>background-image</code> 属性定义要使用的所有图像。接下来，指定它们是否应该重复显示。最后，使用 <code>background-position</code> 属性设置它们的位置。结果见下图。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.28.50.png" alt="屏幕截图 2017-11-23 23.28.50"></p><p><center>使用 CSS3 多背景特性实现的圆角框</center><br><br></p><p><code>Safari</code> 从 1.3 版开始支持多个背景图像，<code>Firefox</code> 和 <code>Opera</code> 的最新版本也支持这个特性。 <code>IE</code> 目前还不支持多个背景图像，但是这也并不妨碍使用这种技术，只是 <code>IE</code> 用户看到的是直角框。</p><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><p>目前有许多高水平的计算机游戏使用动态的纹理映射，图像技术已经普及到这种程度，所以，我们现在可以依靠 CSS3 的 <code>border-radius</code> 属性绘制简单的圆角框。我们只需要设定边角框的半径，浏览器就会实现这种效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.29.05.png" alt="屏幕截图 2017-11-23 23.29.05"></p><p><center>使用 CSS3 <code>border-radius</code> 属性实现的圆角框</center><br><br></p><p>这是一个新属性，对于它的实际实现方式还有争议。所以在这个属性得到广泛使用之前，需要使用与浏览器相关的拓展调用它。当前，<code>Firefox</code> 和 <code>Safari</code> 支持这个属性，所以我使用 <code>-moz</code> 和 <code>-webkit</code> 前缀。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">-moz-border-radius</span>: <span class="number">1em</span>;</div><div class="line">   <span class="attribute">-webkit-border-radius</span>: <span class="number">1em</span>;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">1em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>浏览器生产商一直在实验 CSS 的新扩展，一些生产商率先实现了 CSS 的新特性，其他的生产商还在努力中。一些扩展可能不会出现在正式规范中，比如那些用于在 <code>iPhone</code> 上显示 UI 元素的 <code>Safari</code> 扩展。<br>因此，为了避免与其他用户代理混淆或者破坏代码的有效性，可以通过在选择器、属性或值上添加与厂商相关的前缀来调用这些扩展。例如，<code>Mozilla</code> 使用 <code>-moz</code> 前缀，<code>Safari</code> 使用 <code>-webkit</code> 前缀。<code>IE</code>、<code>Opera</code> 和所有主流浏览器都有相似的前缀。可以使用这些前缀访问每种浏览器特有的特性，可能需要在厂商的开发人员站点上查阅可用的特性。<br>通过使用这种机制，可以在新的 CSS3 特性成为正式规范之前试用它们。但是，试用这些扩展时一定要小心，因为在不同的浏览器中，这些试验性特性的格式可能不一样，而且当正式规范发布时，它们可能有变化或取消了。</p><h3 id="border-image"><a href="#border-image" class="headerlink" title="border-image"></a>border-image</h3><p>CSS 3 中的 <code>border-iamge</code> 属性，这个新属性 <em>允许指定一个图像作为元素的边框</em> 。<strong>优点在于，可以根据一些简单的百分比规则把图像划分为 9 个单独的部分，浏览器会自动地使用适当的部分作为边框的对应部分</strong>。这种技术称为九分法缩放<code>（nine-slice scaling）</code>，它有助于避免在调整圆角框大小时通常会出现的失真。</p><p>假设有一个 100 像素高的曲线框图像，见上图。 <em>在距离框的顶边和底边 25% 的地方画两条线，再在距离左边和右边 25% 的地方画两条线，这个框就分成了 9 个部分</em> 。</p><p><br><br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/Group-5.png" alt="Group-5"></p><p><center>边框图像的源文件。为了说明，加上了分割线</center><br><br></p><p><strong><code>border-image</code> 属性自动地把图象分成了 9 个部分</strong>。因此，图像的左上部分用作左上边框，右边中间部分用作右边的边框。我希望边框的宽度为 <code>25 px</code>，所以在 CSS 中设置这个宽度。如果图像不够大，它们会自动地平铺，产生一个可拓展的框（见下图）。实现这种效果的代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">   <span class="attribute">-webkit-border-image</span>: <span class="built_in">url</span>(/img/corners.gif)</div><div class="line">   <span class="number">25%</span> <span class="number">25%</span> <span class="number">25%</span> <span class="number">25%</span> / <span class="number">25px</span> round round;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.29.20.png" alt="屏幕截图 2017-11-23 23.29.20"></p><p><center>使用 <code>border-image</code> 属性实现的圆角框</center><br><br></p><h1 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h1><p>投影是一种很流行、很具吸引力的设计特性，它给平淡的设计增加了深度，形成立体感。大多数人使用 Photoshop 这样的图形软件直接给图像添加投影。但是，可以使用 CSS 产生简单的投影效果，而不需要修改底层的图像。</p><p>这么做有几个原因。例如，你可能让非技术人员管理站点，而他不会使用 Photoshop，或者要从无法使用 Photoshop 的地方（例如网吧）上传图像。通过使用预定义的投影样式，只需上传常规图像，它在站点上就会显示投影。</p><p>使用 CSS 的最大好处之一是灵活性。如果之后想要去掉投影效果，那么只需要在 CSS 文件中修改几行代码，而不必重新处理所有图像。</p><h2 id="简单的-CSS-投影"><a href="#简单的-CSS-投影" class="headerlink" title="简单的 CSS 投影"></a>简单的 CSS 投影</h2><p>工作原理：<strong>将一个大的投影图像应用于容器 div 的背景。然后使用负的外边距偏移这个图像，从而显示出投影</strong>。<br>首先需要创建投影图像，我使用的是 Adobe Photoshop。 <em>创建一个新的 Photoshop 文件，其尺寸与图像的最大尺寸一样。然后打开背景层，并只填充一种颜色，投影放在这种颜色的上面</em> 。<br><em>让背景层保持白色，接着创建一个新的层并填充上白色。现在，将这个层向左上方移动 4 或 5 个像素，然后对这个层应用 4 或 5 像素宽的投影。保存这个文件并将它命名为 <code>shadow.gif</code> （见下图）</em> 。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.30.29.png" alt="屏幕截图 2017-11-23 23.30.29"></p><p><center>800x800像素的 <code>shadow.gif</code>，在放大图中可以看到 <code>5px</code> 像素宽的投影。</center><br><br></p><p>这种技术的代码十分简单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"img-wrapper"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"dunstan.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span> <span class="attr">alt</span>=<span class="string">"Dunstan Orchard"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>为了产生投影效果，<strong>首先需要将投影图像应用于容器 <code>div</code> 的背景。因为 <code>div</code> 是块级元素，所以他们会水平伸展，占据所有可用空间</strong>。<br>在这种情况下，我们希望 <code>div</code> 包围图像。可以显式地设置容器 <code>div</code> 的宽度，但是这么做会限制这种技术的用途。<strong>可以浮动 <code>div</code>，让它在现代浏览器上产生”收缩包围”的效果</strong>。<br>Mac 上的 <code>IE 5.x</code> 不支持这种技术，<strong>可以对 Mac 上的 <code>IE 5.x</code> 隐藏这些样式</strong>。关于对各种浏览器隐藏规则的更多信息，请参见第 8 章，那里会讨论各种 hack 和过滤器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.img-wrapper</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/shadow.gif) no-repeat bottom right;</div><div class="line">   <span class="attribute">clear</span>: right;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>为了露出投影图像并产生投影效果（见下图），需要使用负的外边距偏移这个图像：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.img-wrapper</span> <span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">margin</span>: -<span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> -<span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.30.50.png" alt="屏幕截图 2017-11-23 23.30.50"></p><p><center>应用了投影的图像</center><br><br></p><p>还可以给图像加上边框和一些内边距，从而产生类似照片边框的效果（见下图）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img-warpper</span> <span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#a9a9a9</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">4px</span>;</div><div class="line">   <span class="attribute">margin</span>: -<span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> -<span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.31.01.png" alt="屏幕截图 2017-11-23 23.31.01"></p><p><center>简单的投影技术的最终结果</center><br><br></p><p>这种技术对于大多数符合标准的现代浏览器都是有效的，但是，为了在 <code>IE6</code> 中产生正确的效果，还需要添加两个简单的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.img-warpper</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/shadow.gif) no-repeat bottom right;</div><div class="line">   <span class="attribute">clear</span>: right;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.img-wrapper</span> <span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#a9a9a9</span>;</div><div class="line">   <span class="attribute">paddding</span>: <span class="number">4px</span>;</div><div class="line">   <span class="attribute">display</span>: block;</div><div class="line">   <span class="attribute">margin</span>: -<span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> -<span class="number">5px</span>;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>投影效果现在可以在 <code>IE 6</code> 中实现了。</p><h2 id="来自-Clagnut-的投影方法"><a href="#来自-Clagnut-的投影方法" class="headerlink" title="来自 Clagnut 的投影方法"></a>来自 Clagnut 的投影方法</h2><p><strong>Clagnut 的投影方法不使用负的外边距，而是使用相对定位来偏移图像</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.img-wrapper</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(/img/shadow.gif) no-repeat bottom right;</div><div class="line">   <span class="attribute">float</span>: left;</div><div class="line">   <span class="attribute">line-height</span>: <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.img-wrapper</span> <span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="number">#fff</span>;</div><div class="line">   <span class="attribute">padding</span>: <span class="number">4px</span>;</div><div class="line">   <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#a9a9a9</span>;</div><div class="line">   <span class="attribute">position</span>: relative;</div><div class="line">   <span class="attribute">left</span>: -<span class="number">5px</span>;</div><div class="line">   <span class="attribute">top</span>: -<span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Box-shadow"><a href="#Box-shadow" class="headerlink" title="Box-shadow"></a>Box-shadow</h3><p>尽管前面的技术可以达到目的，但是很麻烦。如果浏览器本身可以创建投影，就不需要使用 Photoshop 滤镜和图像了，这会方便的多。CSS 3 也支持这种做法，即 <strong><code>box-shadow</code> 属性。这个属性需要 4 个值：垂直和水平偏移、投影的宽度（也就是模糊程度）和颜色</strong>。</p><p>在下面的示例中，把投影偏移 3 像素，宽度设置为 6 像素，颜色为中等灰色（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> <span class="number">#666</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.32.57.png" alt="屏幕截图 2017-11-23 23.32.57"></p><p><center>使用 <code>box-shadow</code> 属性实现的投影</center><br><br></p><p>这也是一个实验性的 CSS 3 属性，所以目前需要使用 Safari 和 Firefox 扩展。但是，这个属性可能很快就会得到广泛支持了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> <span class="number">#666</span>;</div><div class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> <span class="number">#666</span>;</div><div class="line">   <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">6px</span> <span class="number">#666</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>这个属性最让人兴奋的特点之一是它会与 <code>border-radius</code> 属性相互配合（见下图）</em> 。这意味着可以通过编程在圆角框上创建投影，根本不需要使用图形软件！</p><h1 id="不透明度"><a href="#不透明度" class="headerlink" title="不透明度"></a>不透明度</h1><p>适当地使用不透明度可以让设计的效果更丰富。对于相互重叠的元素，还可以用它显露下面的元素。除了这个很酷的用途外，它还可以改进站点的易用性。</p><h2 id="CSS-不透明度"><a href="#CSS-不透明度" class="headerlink" title="CSS 不透明度"></a>CSS 不透明度</h2><p>大多数现代浏览器支持 CSS 不透明度（opacity）已经有一段时间了，但是 <code>IE</code> 的老版本不支持它。专门针对 <code>IE</code> 的代码很容易解决这个问题。下面举一个例子。假设要弹出一个警告信息，它应该覆盖在现有文档上面，同时你仍然可以看到下面的东西（见下图）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.alert</span> &#123;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#000</span>;</div><div class="line">   <span class="attribute">border-radius</span>: <span class="number">2em</span>;</div><div class="line">   <span class="attribute">opacity</span>: <span class="number">0.8</span>;</div><div class="line">   <span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=80);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>CSS 不透明度的主要问题是，除了对背景生效外，应用它的元素的内容也会继承它</strong>。因此，如果仔细看看上图，会透过警告文本看到页面上的文本。</p><p>如果使用非常高的不透明度和高对比度的文本，这可能不是问题。但是，<strong>如果不透明度低，框的内容就会难以辨认。RGBa 就是为了解决这个问题而设计的</strong>。</p><h2 id="RGBa"><a href="#RGBa" class="headerlink" title="RGBa"></a>RGBa</h2><p><strong>RGBa 是一种同时设置颜色和不透明度的机制</strong>。<code>RGB</code> 代表红色、绿色和蓝色，a 代表 <code>alpha</code> 透明度。在前一个示例中使用 RGBa 的方法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.alert</span> &#123;</div><div class="line">    bakcground- color: rgba(0,0,0,0.8);</div><div class="line">    <span class="selector-tag">border-radius</span>: 2<span class="selector-tag">em</span></div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>前 3 个数字表示颜色的红、绿和蓝值。在这里，警告框是黑色的，所以这 3 个值都设置为 0 。与不透明度一样，最后一个数字是十进制的不透明值，所以 0.8 表示这个背景的不透明度是 80% ，换句话说，透明度是 20 %。值为 1 表示 100% 不透明，值为 0 的表示完全透明。这种技术的结果见下图</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.51.04.png" alt="屏幕截图 2017-11-23 23.51.04"></p><p><center>不透明度为 80% 的圆角警告框</center><br><br></p><h2 id="PNG-透明度"><a href="#PNG-透明度" class="headerlink" title="PNG 透明度"></a>PNG 透明度</h2><p><strong>PNG 文件格式最大的优点之一是它支持 <code>alpha 透明度</code></strong>。这可以使设计具备真正的创意。 <em>但是， IE 6 不直接支持 <code>PNG 透明度</code>，但是 IE 7 和 IE 8 支持</em> 。对于 IE 的老版本，有两种解决方法。</p><p>在 IE 6 中支持 <code>PNG 透明度</code> 的方法是使用专有的 AlphaImageLoader 过滤器。为此，需要在 CSS 中包括以下代码行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">filter</span><span class="selector-pseudo">:progid</span><span class="selector-pseudo">:DXImageTransform.Microsoft.AplhaImageLoader</span></div><div class="line">(src=/img/my-image.png', sizingMethod='crop');</div></pre></td></tr></table></figure><p>但是，使用这行代码会导致 CSS 无效，所以最好把它放在 <code>IE 6</code> 专用的样式表中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.img-wrapper</span> <span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">filter</span>: progid: DXImageTransform.Microsoft.AlphaImageLoader</div><div class="line">    (src=<span class="string">'/img/shadow2.png'</span>, sizingMethod=<span class="string">'corp'</span>);</div><div class="line">    <span class="attribute">bckgroun</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>第一个规则使用专有的过滤器加载 PNG 并应用 <code>alpha 透明度</code>。原来的背景图像仍然会显示，所以第二个规则隐藏原来的背景图像。</p><p><code>IE</code> 还有另一种称为 “有条件注释” 的专有代码，这让我们可以向 <code>IE</code> 的特定版本提供特定的样式表。这里希望只让 <code>IE 6</code> 看到这个新的样式表，所以可以在页面顶部添加以下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;!<span class="selector-tag">--</span><span class="selector-attr">[if ie 6]</span>&gt;</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ie6.css"/&gt;</div><div class="line">&lt;!<span class="selector-attr">[endif]</span><span class="selector-tag">--</span>&gt; </div></pre></td></tr></table></figure><p>这种技术的问题是，对于要使用的每个透明 PNG，都必须包含这行代码。因此使用起来有点儿麻烦。</p><p>另一种方法是使用 <code>IE PNG fix</code> 技术，。这需要使用一种不太为人所知的 <code>Microsoft</code> 专有 <code>CSS</code> 扩展 –行为（behavior）。下载合适的 .htc 文件并在 <code>IE 6</code> 专用的样式表中引用它，就可以在任何元素上启用 <code>PNG 透明度</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span>, <span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">behavior</span>: <span class="built_in">url</span>(iepngfix.htc);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="CSS-视差效果"><a href="#CSS-视差效果" class="headerlink" title="CSS 视差效果"></a>CSS 视差效果</h2><p>背景图像不仅可以创建圆角框和投影，还可以实现许多有趣的效果。例如这个网页<a href="http://keithclark.co.uk/articles/pure-css-parallax-websites/demo3/" target="_blank" rel="noopener">Pure CSS parallax scroll demo</a>。</p><p><strong>其中的背景图像会以稍微不同的速度移动，让人觉得这个页面有深度。这种现象被称为视差滚动</strong>，许多老式计算机游戏大量使用了这种技术。</p><p>要想实现这种效果， <em>首先需要创建几个不同的背景图像。一个图像是绿色背景上的藤蔓，另外两个图像是 alpha 透明背景上的藤蔓。这样中景和前景图像可以相互覆盖并盖在背景上，同时不会把视图弄得模糊</em> 。</p><p>主背景将应用在 <code>body</code> 元素上。但是，如果我们不使用 <code>CSS 3</code> 的多个背景图像特性，就需要添加两个新元素来应用背景。页面的内容需要出现在这些元素的前面，让用户可以与它交互。可以把前景 <code>div</code> 放在内容前面，但是这会挡住部分内容，用户很难与它交互。所以标记结构应该像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"midground"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"foreground"</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your content will go here!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>首先，需要在 <code>body</code> 元素上添加主背景。若希望这个图像水平平铺，就需要把 <code>image-repeat</code> 属性设置为 <code>repeat-x</code> 。还需要让 <code>body</code> 元素显示背景颜色（在这里是浅绿色）。 <em>最后，把图像相对于窗口大小水平偏移 20%，这是关键之处。当水平调整窗口大小时，背景图像的位置会改变，看起来像是移动了</em> 。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bg-rear.jpg);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#d3ff99</span>;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">20%</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在 <em>需要对中景和前景图像进行同样的处理，但是选择比较高的百分数，让它们相对移动的更快，产生有深度的感觉</em> 。我们把中景的位置设置为 40%，把前景位置设置为 150%。你可以调整这些位置，得到自己需要的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bg-rear.jpg);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">   <span class="attribute">background-color</span>: <span class="number">#d3ff99</span>;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">20%</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.midground</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bg-mid.png);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">   <span class="attribute">background-color</span>: transparent;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">40%</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.foreground</span> &#123;</div><div class="line">   <span class="attribute">background-image</span>: <span class="built_in">url</span>(/img/bg-front.png);</div><div class="line">   <span class="attribute">background-repeat</span>: repeat-x;</div><div class="line">   <span class="attribute">background-color</span>: transparent;</div><div class="line">   <span class="attribute">background-position</span>: <span class="number">150%</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/屏幕截图 2017-11-23 23.52.31.png" alt="屏幕截图 2017-11-23 23.52.31"></p><p><center>示意图</center><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;对 image 标签的滥用导致纯修饰性的图像把页面弄乱了。好在 CSS 使我们能够在页面上显示图像，而不需要让图像成为标记的一部分，即将图像作为背景添加到现有的元素中。本章将通过一系列实际示例讲解如何使使用背景图像创建各种有意思且有用的技术。&lt;/p&gt;
&lt;p&gt;本章将介绍以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;固定宽度和可变宽度的圆角框&lt;/li&gt;
&lt;li&gt;滑动门技术&lt;/li&gt;
&lt;li&gt;多个背景图像和 &lt;code&gt;border-radius&lt;/code&gt; 属性&lt;/li&gt;
&lt;li&gt;CSS 投影&lt;/li&gt;
&lt;li&gt;不透明度和 RGBa&lt;/li&gt;
&lt;li&gt;让 PNG 适用于 &lt;code&gt;IE&lt;/code&gt; 的老版本&lt;/li&gt;
&lt;li&gt;视差滚动&lt;/li&gt;
&lt;li&gt;图像替换&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>第三章--可视化格式模型</title>
    <link href="https://www.douglasdong.site/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://www.douglasdong.site/第三章-可视化格式模型.html</id>
    <published>2017-10-14T09:54:40.000Z</published>
    <updated>2018-08-06T15:02:50.760Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="盒模型概述"><a href="#盒模型概述" class="headerlink" title="盒模型概述"></a>盒模型概述</h1><p>盒模型是 CSS 的基石之一，<strong>它指定元素如何显示以及（在某种程度上）如何相互交互</strong>。页面上的每个元素被看作一个矩形框，这个框由元素的内容，内边距，边框和外边距组成。</p><a id="more"></a><h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>内边距常用用于在内容周围创建一个隔离带，使内容不会与背景混在一起。</p><h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>外边距是透明的，一般使用它控制元素之间的间隔。</p><h3 id="盒模型示意图"><a href="#盒模型示意图" class="headerlink" title="盒模型示意图"></a>盒模型示意图</h3><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-1.png" alt="3-1"></p><p>内边距，边框和外边距都是可选的，默认值为0。但是，许多元素将由用户代理样式表设置外边距和内边距。可以通过将元素的 <code>margin</code> 或 <code>padding</code> 设置为 0 来覆盖这些浏览器样式。这可以分别进行，也可以使用通用选择器对所有元素进行设置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>请记住，这种技术不区分元素，所以它对 <code>option</code> 等元素有不利影响。因此，使用全局把内边距和外边距显式地设置为 0 可能更安全。</strong></p><p>在 CSS 中，<code>width</code> 和 <code>height</code> 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。假设框的每个边上有 10 像素的外边距和 5 像素的内边距，如果希望这个框达到 100 像素宽，就需要将内容的宽度设置为 70 像素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> <span class="selector-id">#myBox</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">5px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>示意图如下：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-2.png" alt="3-2"></p><h1 id="IE-和盒模型"><a href="#IE-和盒模型" class="headerlink" title="IE 和盒模型"></a>IE 和盒模型</h1><p>令人遗憾的是，<code>IE</code> 的早期版本，包括 <code>IE6</code>，在混杂模式中使用自己的非标准盒模型。这些浏览器的 <code>width</code> 属性不是内容的宽度，而是内容、内边距和边框的宽度总和。例如，前面的示例，在 <code>IE 5.x</code> 中框的总宽度只有 90 像素。这是因为 <code>IE 5.x</code> 认为每个边上 <code>5px</code> 的内边距是 <code>70px</code> 的宽度额度一部分，而不是在宽度之外附加的。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-3.png" alt="3-3"></p><p>幸运的是，有几个方法可以解决这个问题，这些方法的细节可以在第九章找到。但是，目前最好的解决方案是回避这个问题。也就是，不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素或子元素。</p><h1 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h1><p>当一个元素出现在另一个元素上面时，第一个元素的底外边距与第二个元素的顶外边距发生叠加。</p><p>叠加之前</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-4.png" alt="3-4"></p><p>叠加之后</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-5.png" alt="3-5"></p><p>当一个元素包含在另一个元素中时（假设没有内边距或边框将外边距分隔开），它们的顶和或底外边距也会发生叠加。</p><p>叠加之前：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-7.png" alt="3-7"></p><p>叠加之后：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-8.png" alt="3-8"></p><p>外边距甚至可以与本身发生叠加。假设有一个空元素，它有外边距，但是没有边框或内边距。这种情况下，顶外边距与底内边距就碰到了一起，它们会发生叠加。</p><p>叠加之前：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-9.png" alt="3-9"></p><p>叠加之后：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-10.png" alt="3-10"></p><p>如果这个外边距碰到另一个元素的外边距，它还会发生叠加。</p><p>叠加之前：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-11.png" alt="3-11"></p><p>叠加之后：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-12.png" alt="3-12"></p><p>这就是一系列空的段落元素占用的空间非常小的原因，因为它们的所有外边距都叠加到一起，形成一个小的外边距。</p><p>外边距叠加的意义在于：防止段落之间的空间是页面顶部的两倍。如果发生外边距叠加，段落之间的顶外边距和底外边距就叠加在一起，这样各处的距离就一致了。<br><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-13.png" alt="3-13"></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-14.png" alt="3-14"></p><p>注意：只有普通文档流中<code>块框（block）</code>的垂直外边距才会发生外边距叠加。<code>行内框（inline）</code>、<code>浮动框（float）</code>或<code>绝对定位框（position：absolute）</code>之间的外边距不会叠加。</p><h1 id="定位概述"><a href="#定位概述" class="headerlink" title="定位概述"></a>定位概述</h1><h2 id="可视化格式模型"><a href="#可视化格式模型" class="headerlink" title="可视化格式模型"></a>可视化格式模型</h2><p><code>p</code> <code>h1</code> 或 <code>div</code> 元素常常被称为块级元素。这意味着这些元素显示为一些内容，即<code>“块框”（display: block）</code>。与之相反，<code>strong</code> 和 <code>span</code> 等元素被称为<strong>行内元素</strong>，因为它们的内容显示在行中，即<code>“行内框”（display: inline）</code>。</p><p>还可以通过将 <code>display</code> 设置为 <code>none</code>，让生成的元素根本没有框。这样，这个框的内容就不再显示，不占用文档中的空间。</p><h3 id="定位机制"><a href="#定位机制" class="headerlink" title="定位机制"></a>定位机制</h3><p>CSS 中有 3 种基本的定位机制：<code>普通流</code>，<code>浮动</code>和<code>绝对定位</code>。<strong>除非专门指定，否则所有框都会在普通流中进行定位。</strong></p><h3 id="块级框与行级框特性"><a href="#块级框与行级框特性" class="headerlink" title="块级框与行级框特性"></a>块级框与行级框特性</h3><p>块级框从上至下一个接一个的垂直排列，框之间的垂直距离由框的垂直外边距计算出来。<br>行内框在一行中水平排列，可以使用水平内边距、边框和外边距。但是，垂直内边距、边框和外边距不影响行内框的高度。同样，在行内框上设置显式的高度或宽度也没有影响。<br>行框的高度总是足以容纳它包含的所有行内框，但是，设置行高可以增加这个框的高度。因此，<strong>修改行内框尺寸的唯一方法就是修改行高 / 水平内边距、边框和外边距：</strong></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-15.png" alt="3-15"></p><p>CSS 2.1 允许把元素更改为 <code>display: inline-block</code>。这个声明让元素像行内框一样水平依次排列，但是，框的内容依旧符合块级框的行为，可以设置垂直内边距、边框和外边距。现在，<code>FireFox 3.0</code> 、<code>IE8</code>、<code>Safari</code> 和 <code>Opera</code> 的最新版本都支持 <code>inline-block</code>。</p><h3 id="匿名块框-行框"><a href="#匿名块框-行框" class="headerlink" title="匿名块框/行框"></a>匿名块框/行框</h3><p>将一些文本添加到一个块级元素（比如 <code>div</code> ）的开头时，即使没有把这些元素定义为块级元素，它也会被当成块级元素对待</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">   sometext</div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>Some more Text<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 在 p 之前添加的都被称为匿名块框 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </div></pre></td></tr></table></figure><p>这种情况下的框被称为<code>匿名块框</code>，因为它不与专门定义的元素相关联。<br>行内框情况类似，无法直接对匿名块或行框运用样式，除非利用不常见的 <code>:first-line</code> 伪元素。</p><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>可以通过设置垂直或水平位置，让这个元素“相对于”它的起点移动。如果将 <code>top</code> 设置为 <code>20px</code> ，那么框就会出现在原位置顶部下面 <code>20px</code> 的地方。如果将 <code>left</code> 设置为 <code>20px</code> ，那么会在元素左边创建 <code>20px</code> 的空间，也就是将元素向右移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#myBox</span>&#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">left</span>: <span class="number">20px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-16.png" alt="3-16"></p><p>注意：使用相对定位时，无论是否移动，元素都会占据原有的空间。因此，移动元素会导致覆盖其他框。</p><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>相对定位实际上被看做普通流定位模型的一部分，因为元素的位置是相对于它在普通流中的位置的。与之相反，绝对定位使元素的位置与文档流无关，因此不占据空间。普通文档流中的其他元素定位时就像绝对定位的元素不存在一样。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-18.png" alt="3-18"></p><p>绝对定位元素的位置是相对于距离它最近的那个已定位的祖先元素确定的。如果没有已定位的祖先元素，那么它的位置是相对于初始块的。根据浏览器不同，初始块可能是画布或 HTML 元素。</p><p>与相对定位一样，绝对定位的框可以从它的包含块向上、下、左、右移动。</p><p>因为绝对定位的框与文档流无关，因此它们可以覆盖页面上的其他元素。可以通过设置 <code>z-index</code> 来控制这些框的叠放顺序，<code>z-index</code> 值越高，框的位置就越高。</p><p>相对于最近的已定位祖先元素来定位绝对定位的元素，能够实现一些非常有意思的效果。例如，假设希望让一个文本段落对准一个大框的右下角，只需对包含框进行相对定位，然后相对于这个框对段落进行绝对定位：</p><p></p><p data-height="308" data-theme-id="0" data-slug-hash="wPqVKE" data-default-tab="css,result" data-user="Xeonice" data-embed-version="2" data-pen-title="wPqVKE" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/wPqVKE/" target="_blank" rel="noopener">wPqVKE</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>注意：因为绝对定位的元素和文档流无关，所以它们不会影响普通流中的框。如果扩大绝对定位的框（例如：增加字号），周围的框不会重新定位。因此，尺寸的任何改变都会导致绝对定位的框产生重叠，从而破坏布局。</p><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位是绝对定位的一种，差异在于固定元素的包含块是 <code>viewport</code>，这使得我们能够创建出总是出现在窗口相同位置的浮动元素。例如侧边栏。</p><p>不过，<code>IE 6</code> 和更低版本不支持固定定位。<code>IE 7</code> 部分支持这个属性，但是实现中有许多 bug，为了解决这个问题，Jonathan Snook 使用 Javascript 在 IE 中重现了这个效果。</p><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>最后一种定位模型是浮动模型。浮动的框可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘，<strong>因为浮动框不包括在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</strong></p><p>如下所示，当把框 1 向右浮动时，它脱离文档并向右浮动，直到它的右边框碰到包含框的右边缘。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-19.png" alt="3-19"></p><p>在下图中，当把框 1 向左浮动时，它脱离文档流并且向向左移动，因为它不再处于文档流中，所以它不占空间。实际上覆盖住了框 2 ，使框 2 从视图内消失。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-20.png" alt="3-20"></p><p>如果包含块太窄，不足以容纳 3 个浮动元素水平排列，那么其他浮动块向下移动，直到有足够空间的地方。如果浮动元素的高度不同，那么当它们向下移动时可能被其他浮动元素“卡住”。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-21.png" alt="3-21"></p><h2 id="行框和清除浮动"><a href="#行框和清除浮动" class="headerlink" title="行框和清除浮动"></a>行框和清除浮动</h2><p>浮动会让元素脱离文档流，周围的框会表现的和浮动元素不存在一样，但是，行框的内容会围绕浮动元素。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-22.png" alt="3-21"></p><p>为避免行框浮动在浮动元素周围，需要用到 <code>clear</code> 属性，<code>clear</code> 属性的值可以是 <code>left</code>, <code>right</code>, <code>both</code>, 和 <code>none</code>。它表示框的哪些边不应该挨着浮动框。<br>注：<code>clear</code> 并不是自动地抵消前面的浮动，而是在元素边上加上足够的外编剧。</p><p>对元素进行清理实际上为前面的浮动元素留出了垂直空间。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-23.png" alt="3-23"></p><p><code>clear</code> 让周围的元素为浮动元素留出了空间，解决了前面看到的问题 — 垂直高度的改变不影响周围的元素，从而破坏了设计。</p><p>希望让图片浮动到文本块的左边时</p><p>因为浮动元素脱离了文档流，所以包围图片和文本的 <code>div</code> 不占据空间。<br>浮动元素脱离了文档流，使包含图片和文本的 <code>div</code> 不占空间，使元素在视觉上包括浮动元素的方法是：在这个元素中的某个地方运用 <code>clear</code> 。本例中添加在了最后一个段落下面。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/3-24.png" alt="3-24"></p><p>还可以选择浮动容器 <code>div</code></p><p></p><p data-height="301" data-theme-id="0" data-slug-hash="vWJoxp" data-default-tab="css,result" data-user="Xeonice" data-embed-version="2" data-pen-title="vWJoxp" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/vWJoxp/" target="_blank" rel="noopener">vWJoxp</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>这也会产生我们想要的结果。但是，下一个元素会受到这个浮动元素的影响。为了解决这个问题，有些人选择浮动布局中的几乎所有东西，然后使用合适的元素（常常是站点的页脚）对这些浮动元素进行清理。这有助于减少或消除不必要的标记。但是，浮动会变得复杂，而且一些老式浏览器在处理有许多浮动元素布局时有困难。因此，许多人喜欢添加少量的额外标记。</p><p>利用 CSS 生成的内容对浮动元素进行处理：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"."</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">visibility</span>: hidden;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">clear</span>: both;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>CSS 方法，结合使用 <code>:after</code> 伪类和内容声明在指定的现有内容的末尾添加新的内容。</p><p><code>IE6</code> 和更低版本上使用需要 Holly hack，迫使 <code>IE5</code> 和 <code>IE6</code> 应用布局<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clear</span>&#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* Holly Hack Targets IE Win only \ */</span></div><div class="line">* <span class="selector-tag">html</span> <span class="selector-class">.clear</span> &#123;<span class="attribute">height</span>: <span class="number">1%</span>;&#125;</div><div class="line"><span class="selector-class">.clear</span> &#123;<span class="attribute">display</span>: block;&#125;</div><div class="line"><span class="comment">/* End Holly Hack */</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;盒模型概述&quot;&gt;&lt;a href=&quot;#盒模型概述&quot; class=&quot;headerlink&quot; title=&quot;盒模型概述&quot;&gt;&lt;/a&gt;盒模型概述&lt;/h1&gt;&lt;p&gt;盒模型是 CSS 的基石之一，&lt;strong&gt;它指定元素如何显示以及（在某种程度上）如何相互交互&lt;/strong&gt;。页面上的每个元素被看作一个矩形框，这个框由元素的内容，内边距，边框和外边距组成。&lt;/p&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>第二章--为样式找到应用目标</title>
    <link href="https://www.douglasdong.site/%E7%B2%BE%E9%80%9ACSS%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%BA%E6%A0%B7%E5%BC%8F%E6%89%BE%E5%88%B0%E5%BA%94%E7%94%A8%E7%9B%AE%E6%A0%87.html"/>
    <id>https://www.douglasdong.site/精通CSS笔记-第二章-为样式找到应用目标.html</id>
    <published>2017-10-02T18:40:06.000Z</published>
    <updated>2018-08-06T15:02:58.876Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="常用的选择器"><a href="#常用的选择器" class="headerlink" title="常用的选择器"></a>常用的选择器</h1><p>最常用的选择器类型是 <strong>类型选择器</strong> 和 <strong>后代选择器</strong> 。</p><h2 id="类型选择器"><a href="#类型选择器" class="headerlink" title="类型选择器"></a>类型选择器</h2><p>有时被称为 <em>元素选择器</em> 或 <em>简单选择器</em> 是用来寻找特定类型的选择器，例如，我们想要选择网页中所有的 <code>&lt;p&gt;</code> 或 <code>&lt;h1&gt;</code> ，只需按照如下示例进行指定。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">color</span>: black;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>可用来寻找特定元素或元素组的后代。后代选择器由其他两个选择器中间的空格表示。在此事例中，css 属性仅影响 <code>blockquote</code> 的后代的 <code>&lt;p&gt;</code> 元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">p</span> &#123;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>要想寻找更特定的元素，可以使用 <strong>ID选择器</strong> 和 <strong>类选择器</strong> 。顾名思义，这两种选择器用于寻找那些具有指定 <em>ID</em> 或 <em>类名</em> 的元素。下方示例，第一条选择 <code>ID = intro</code> 的元素，第二条选择 <code>class = data-posted</code> 的元素。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#intro</span> &#123;</div><div class="line">   <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.date-posted</span> &#123;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#ccc</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>注意：如果你发现自己在文档中添加了许多不必要的类，那么这可能是文档结构不合理的一个警告信号。<strong>因此，不要给这些元素指定不同的类，而应将一个 <em>类</em> 或 <em>ID</em> 应用于它们的祖先，然后使用后代选择器定位它们。</strong></p><a id="more"></a><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><p>用于根据 <em>DOM</em> 流外的条件对元素应用样式，例如表单元素或链接的状态。示例如下：</p><p></p><p data-height="265" data-theme-id="0" data-slug-hash="QqqbKY" data-default-tab="css,result" data-user="Xeonice" data-embed-version="2" data-pen-title="伪类" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/QqqbKY/" target="_blank" rel="noopener">伪类</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p><code>:link</code> 和 <code>:visited</code> 称为链接伪类， 只能应用于锚元素。 <code>:hover</code> <code>:active</code> 和 <code>:focus</code>称为动态伪类，理论上可应用于任何元素。 <strong>注意：<em>IE6</em> 只注意应用于锚链接的 <code>:active</code> 和 <code>:hover</code> 选择器，完全忽略 <code>:focus</code> 。<em>IE7</em> 在任何元素上都支持 <code>:hover</code> ，但是忽略 <code>:active</code> 和 <code>:focus</code>。</strong></p><h1 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h1><p>通用选择器就像是通配符，作用是对页面上所有的元素应用样式。例如，可以使用下列代码清除每个元素上默认的 <code>padding</code> 和 <code>margin</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">* &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h1><p><em>CSS 2.1</em> 和 <em>CSS 3</em> 有其他很多有用的选择器，不过 <em>IE6</em> 和更低版本不支持，好在创建 CSS 时考虑到了向后兼容性，如果浏览器不理解某个选择器，那么它会忽略整个规则。<strong>但是要记住，在对于站点功能或布局很重要的任何元素上，都应该避免使用这些高级选择器。</strong></p><h2 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h2><p>子选择器只选择元素的直接后代，即子元素。示例如下：</p><p></p><p data-height="265" data-theme-id="0" data-slug-hash="EwpYxZ" data-default-tab="html,result" data-user="Xeonice" data-embed-version="2" data-pen-title="EwpYxZ" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/EwpYxZ/" target="_blank" rel="noopener">EwpYxZ</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p><strong>注意：<em>IE7</em> 中存在 bug，如果父元素和子元素之间有 HTML 注释，就会出问题。</strong></p><p><em>IE6</em> 和更低版本中，可以使用通用选择器模拟子选择器的效果。即：先在所有后代上应用你希望子元素具有的样式。然后，使用通用选择器覆盖子元素的后代上的样式。例如，在 <em>IE6</em> 中实现子选择器效果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(folder.png) no-repeat left top;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-id">#nav</span> <span class="selector-tag">li</span> * &#123;</div><div class="line">   <span class="attribute">background</span>: none;</div><div class="line">   <span class="attribute">padding-left</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="相邻同胞选择器"><a href="#相邻同胞选择器" class="headerlink" title="相邻同胞选择器"></a>相邻同胞选择器</h2><p>相邻同胞选择器可用于定位同一个父元素下某个元素之后的元素。可以使用相邻同胞选择器让顶级标题后面的第一个段落显示为粗体，灰色，并且字号比后续段落略微大一点。</p><p><iframe height="265" scrolling="no" title="相邻同胞选择器" src="//codepen.io/Xeonice/embed/rGrBMj/?height=265&theme-id=dark&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/Xeonice/pen/rGrBMj/" target="_blank" rel="noopener">相邻同胞选择器</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><br><strong>注意：与子选择器一样，如果在目标元素之间有注释，这在 <em>IE7</em> 中也会出问题。</strong></p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>根据某个属性是否存在或属性的值来寻找元素。<br>例如：对具有 <em>title</em> 属性的 <em>acronym</em>元素应用与其他元素不同的样式：</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="yzqBbJ" data-default-tab="html,result" data-user="Xeonice" data-embed-version="2" data-pen-title="属性选择器" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/yzqBbJ/" target="_blank" rel="noopener">属性选择器</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>实际运用：使用 <em>rel</em> 属性值 <em>nofollow</em> 链接的站点无法从 Google 获得评级收益。以下规则在这种链接旁边显示一个图像，以此表示不推荐这个目标站点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span><span class="selector-attr">[rel="nofollow"]</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(nofollow.gif) no-repeat right center;</div><div class="line">   <span class="attribute">padding-right</span>: <span class="number">20px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意：包括 IE7 的现代浏览器都支持这些选择器。然而，由于 IE6 不支持属性选择器，可以利用它们对 IE6 应用一种样式，对更符合标准的浏览器应用另一种样式。例如，Andy Clarke 利用这种技术为 IE6 提供网站的黑白版本，为其他所有浏览器提供彩色版本：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#header</span> &#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(branding-bw.png) repeat-y left top;</div><div class="line">&#125;</div><div class="line"><span class="selector-attr">[id="header"]</span>&#123;</div><div class="line">   <span class="attribute">background</span>: <span class="built_in">url</span>(branding-color.png) repeat-y left top;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="层叠和特殊性"><a href="#层叠和特殊性" class="headerlink" title="层叠和特殊性"></a>层叠和特殊性</h1><h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>层叠采用以下重要度次序</p><ul><li>标有 <em>!important</em> 的用户（使用浏览器的人）样式。</li><li>标有 <em>!important</em> 的作者（开发者）样式。</li><li>作者样式。</li><li>用户样式。</li><li>浏览器/用户代理应用的样式</li></ul><p>然后根据选择器的特殊性决定规则的次序。<strong>具有更特殊选择器的规则优先于具有一般选择器的规则。如果两个选择器的特殊性相同，那么后定义的规则更优先。</strong></p><h2 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h2><p>选择器的特殊性分成4个成分等级：a, b, c 和 d。</p><ul><li>如果样式是行内样式，那么 a = 1；</li><li>b 等于 <strong>ID选择器</strong> 的总数。</li><li>c 等于类，伪类和属性选择器的数量。</li><li>d 等于类型选择器和伪元素选择器的数量。</li></ul><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:center">特殊性</th><th style="text-align:center">以10为基数的特殊性</th></tr></thead><tbody><tr><td style="text-align:left">Style=””</td><td style="text-align:center">1,0,0,0</td><td style="text-align:center">1000</td></tr><tr><td style="text-align:left">#wrapper #content {}</td><td style="text-align:center">0,2,0,0</td><td style="text-align:center">200</td></tr><tr><td style="text-align:left">#content .datePosted {}</td><td style="text-align:center">0,1,1,0</td><td style="text-align:center">110</td></tr><tr><td style="text-align:left">div#content {}</td><td style="text-align:center">0,1,0,1</td><td style="text-align:center">101</td></tr><tr><td style="text-align:left">#content {}</td><td style="text-align:center">0,1,0,0</td><td style="text-align:center">100</td></tr><tr><td style="text-align:left">p.comment dateposted {}</td><td style="text-align:center">0,0,2,1</td><td style="text-align:center">21</td></tr><tr><td style="text-align:left">p.comment {}</td><td style="text-align:center">0,0,1,1</td><td style="text-align:center">11</td></tr><tr><td style="text-align:left">div p {}</td><td style="text-align:center">0,0,0,2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">p {}</td><td style="text-align:center">0,0,0,1</td><td style="text-align:center">1</td></tr></tbody></table><p>总结：用 <em>style</em> 属性编写的规则总是比其他任何规则特殊。具有 ID选择器 的规则比没有 ID 选择器的规则特殊，具有类选择器的规则比只有类型选择器的规则特殊。最后，如果两个规则的特殊性相同，那么后定义的规则优先。</p><p>例如：假设有以下这两组规则，你认为两个标题会是什么颜色的？</p><p></p><p data-height="265" data-theme-id="dark" data-slug-hash="mBjbZN" data-default-tab="html,result" data-user="Xeonice" data-embed-version="2" data-pen-title="特殊性" class="codepen">See the Pen <a href="https://codepen.io/Xeonice/pen/mBjbZN/" target="_blank" rel="noopener">特殊性</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script><p>令人吃惊的是，两个标题都是灰色的，第一个选择器由两个 ID选择器 组成，因此它具有最高的特殊性。</p><h3 id="在样式表中使用特殊性"><a href="#在样式表中使用特殊性" class="headerlink" title="在样式表中使用特殊性"></a>在样式表中使用特殊性</h3><p>在编写 CSS 时特殊性非常有用，因为它可以对一般元素应用一般样式，然后在更特殊的元素上覆盖它们。例如，如果你希望站点上大多数文本是黑色的，但介绍说明文本是灰色的，可以这样做</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>: black&#125;</div><div class="line"><span class="selector-tag">p</span><span class="selector-class">.intro</span> &#123;<span class="attribute">color</span>: gray&#125;</div></pre></td></tr></table></figure><p>为了避免过度混乱，我尽量保持一般性样式非常一般，特殊样式尽可能特殊，这样就不需要覆盖特殊样式了。如果发现不得不多次覆盖一般样式，那么从更一般的规则中删除需要覆盖的声明，并且将它显式运用于需要它的每个元素，这样可能比较简单。</p><h3 id="在主体标签上添加类或者ID"><a href="#在主体标签上添加类或者ID" class="headerlink" title="在主体标签上添加类或者ID"></a>在主体标签上添加类或者ID</h3><p>一种有意思的特殊性用法是在主体（body）标签上应用 <em>类</em> 或 <em>ID</em> 。这样做以后，就可以根据页面或在站点范围内覆盖样式。例如，如果希望新的页面具有特殊的布局，那么就可以在主页的主题元素上添加一个类名，并且使用它覆盖样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-class">.news</span> &#123;</div><div class="line">   <span class="comment">/* do some stuff */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"news"</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>My, what a lovely body you have.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>有时候，在特殊页面上需要覆盖这些样式，比如在新闻存档页面上。在这种情况下，可以在主体标签上添加 <em>ID</em> 来标识这个页面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">body</span><span class="selector-class">.news</span> &#123;</div><div class="line">   <span class="comment">/* do some stuff */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span><span class="selector-id">#archive</span> &#123;</div><div class="line">   <span class="comment">/* do some stuff */</span></div><div class="line">&#125;   </div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"archive"</span> <span class="attr">class</span>"<span class="attr">news</span>"&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>My, what a lovely body you have.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </div></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是一个非常容易理解的概念。<strong>应用样式的元素的后代会继承样式的某些属性，比如颜色和字号。</strong><br>例如：如果将主体元素的文本颜色设置为黑色，那么主体元素的所有后代也显示黑色的文本。对于字号，也是这样的。如果将主体的字号设置为 <em>1.4 em</em>，那么页面上的所有内容应该会继承这个字号。</p><p><strong>“应该会” 是因为 Windows 的 <em>IE</em> 和 <em>Netscape</em> 在继承表格的字号方面有问题。为了解决这个问题，必须制定表格应该继承字号，或者在表格上单独设置。</strong></p><p>恰当地使用继承也可以减少代码中选择器的数量和复杂性。但是，如果大量元素继承各种样式，那么判断样式的来源就会变得困难。</p><h1 id="规划、组织和维护样式表"><a href="#规划、组织和维护样式表" class="headerlink" title="规划、组织和维护样式表"></a>规划、组织和维护样式表</h1><p>管理代码的方法，包括按逻辑对样式进行分组以及通过添加注释使代码更容易阅读</p><h2 id="对文档应用样式"><a href="#对文档应用样式" class="headerlink" title="对文档应用样式"></a>对文档应用样式</h2><ol><li>将样式放在 <em>style</em> 标签之间，从而直接在文档头上添加样式。但是，这不是对文档应用样式的好方法。如果要创建使用相同样式的另一个页面，那么就不得不在新页面上复制 CSS 。如果以后要修改样式，那么就不得不在两处都进行修改。</li><li>将样式放在一个或多个外部样式表中，附加到网页上的方法有两种。可以链接它们，也可以导入它们。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/css/basic.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> /&gt;</span> <span class="comment">&lt;!-- 链接 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">&lt;!--</span></div><div class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">"/css/advanced.css"</span>);</span></div><div class="line"><span class="undefined">--&gt;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span> <span class="comment">&lt;!-- 导入 --&gt;</span></div></pre></td></tr></table></figure></li><li>可以从 HTML 页面链接基本样式表，然后将复杂的样式表导入这个样式表。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@import url(/css/layout.css);</div><div class="line">@import url(/css/typography.css);</div><div class="line">@import url(/css/color.css);</div><div class="line"><span class="comment">&lt;!-- 导入 --&gt;</span></div></pre></td></tr></table></figure>注意：最新的浏览器基准测试已经表明，导入样式表比链接样式表慢。</li><li>使用多个 CSS 时，还有两个与速度相关的问题。首先：<strong>多个文件会导致从服务器发送更多数据包，数据包的数量会影响下载时间</strong>。另外：<strong>浏览器只能同时从一个域名下载数量有限的文件。对于老式浏览器，这个数字是两个，对于新式浏览器，这个数字是八个。</strong>因此，使用结构良好的单一 CSS 文件能有效提高下载速度。</li></ol><h2 id="设计代码的结构"><a href="#设计代码的结构" class="headerlink" title="设计代码的结构"></a>设计代码的结构</h2><p>为了方便维护，最好把整个样式表分为几大块，通常的文档结构如下所示：</p><ul><li>一般性样式<ul><li>主体样式</li><li>reset 样式</li><li>链接</li><li>标题</li><li>其他元素</li></ul></li><li>辅助样式<ul><li>表单</li><li>通知和错误</li><li>一致的条目</li></ul></li><li>页面结构<ul><li>标题、页脚和导航</li><li>布局</li><li>其他页面结构元素</li></ul></li><li>页面组件<ul><li>各个页面</li></ul></li><li>覆盖</li></ul><p>这里用一种风格统一的大代码块分割以下部分：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* @group general styles</span></div><div class="line"><span class="comment">-----------------------------------------------------*/</span></div><div class="line"><span class="comment">/* @group helper styles</span></div><div class="line"><span class="comment">-----------------------------------------------------*/</span></div><div class="line"><span class="comment">/* @group page structure</span></div><div class="line"><span class="comment">-----------------------------------------------------*/</span></div><div class="line"><span class="comment">/* @group components</span></div><div class="line"><span class="comment">-----------------------------------------------------*/</span></div><div class="line"><span class="comment">/* @group overrides</span></div><div class="line"><span class="comment">-----------------------------------------------------*/</span></div></pre></td></tr></table></figure><h2 id="自我提示"><a href="#自我提示" class="headerlink" title="自我提示"></a>自我提示</h2><p>注释可以提醒你在启动前需要完成哪些工作，或者提醒你提供列宽度等常用值的查询表。<br>例如，我可以运用注释在开头添加一个小的颜色查询表：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">@colordef #434343; dark gray</span></div><div class="line"><span class="comment">@colordef #f2f6e4; light green</span></div><div class="line"><span class="comment">@colordef #90b11f; dark green</span></div><div class="line"><span class="comment">@colordef #369; dark blue</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure><p>或者，运用 @todo 来表示某些东西需要在以后进行修改、修复或审查，用 @bugfix 表示代码或特定文件遇到的问题，用 @workaround 表示并不完善的权宜之计。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* :@todo Remember to remove this rule before the site goes live*/</span></div><div class="line"><span class="comment">/* @workaround: I managed to fix this problem in IE by setting a small negative margin but it's not pretty*/</span></div><div class="line"><span class="comment">/* @bugfix: Rule breaks in IE5.2 Mac*/</span></div></pre></td></tr></table></figure><h2 id="删除注释和优化样式表"><a href="#删除注释和优化样式表" class="headerlink" title="删除注释和优化样式表"></a>删除注释和优化样式表</h2><p>删除注释可以利用在线 CSS 优化器自动优化，或者使用自动化构建工具<br>优化样式表可以采用服务端压缩方法。<strong>如果使用 Apache 服务器，应该安装 mod_gzip 或 mod_deflate。</strong>所有现代浏览器都可以处理用 GZIP 压缩的文件并进行即时解压。这些 Apache 模块检测浏览器是否能处理这些文件，如果可以，就发送压缩过的版本。<strong>服务端压缩能将 HTML 和 CSS 文件减少大约 80% 。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常用的选择器&quot;&gt;&lt;a href=&quot;#常用的选择器&quot; class=&quot;headerlink&quot; title=&quot;常用的选择器&quot;&gt;&lt;/a&gt;常用的选择器&lt;/h1&gt;&lt;p&gt;最常用的选择器类型是 &lt;strong&gt;类型选择器&lt;/strong&gt; 和 &lt;strong&gt;后代选择器&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;类型选择器&quot;&gt;&lt;a href=&quot;#类型选择器&quot; class=&quot;headerlink&quot; title=&quot;类型选择器&quot;&gt;&lt;/a&gt;类型选择器&lt;/h2&gt;&lt;p&gt;有时被称为 &lt;em&gt;元素选择器&lt;/em&gt; 或 &lt;em&gt;简单选择器&lt;/em&gt; 是用来寻找特定类型的选择器，例如，我们想要选择网页中所有的 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; ，只需按照如下示例进行指定。&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: black;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;h1&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;font-weight&lt;/span&gt;: bold;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;后代选择器&quot;&gt;&lt;a href=&quot;#后代选择器&quot; class=&quot;headerlink&quot; title=&quot;后代选择器&quot;&gt;&lt;/a&gt;后代选择器&lt;/h2&gt;&lt;p&gt;可用来寻找特定元素或元素组的后代。后代选择器由其他两个选择器中间的空格表示。在此事例中，css 属性仅影响 &lt;code&gt;blockquote&lt;/code&gt; 的后代的 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 元素。&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;blockquote&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;p&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;padding-left&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2em&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;要想寻找更特定的元素，可以使用 &lt;strong&gt;ID选择器&lt;/strong&gt; 和 &lt;strong&gt;类选择器&lt;/strong&gt; 。顾名思义，这两种选择器用于寻找那些具有指定 &lt;em&gt;ID&lt;/em&gt; 或 &lt;em&gt;类名&lt;/em&gt; 的元素。下方示例，第一条选择 &lt;code&gt;ID = intro&lt;/code&gt; 的元素，第二条选择 &lt;code&gt;class = data-posted&lt;/code&gt; 的元素。&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-id&quot;&gt;#intro&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;font-weight&lt;/span&gt;: bold;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.date-posted&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;attribute&quot;&gt;color&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;#ccc&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;注意：如果你发现自己在文档中添加了许多不必要的类，那么这可能是文档结构不合理的一个警告信号。&lt;strong&gt;因此，不要给这些元素指定不同的类，而应将一个 &lt;em&gt;类&lt;/em&gt; 或 &lt;em&gt;ID&lt;/em&gt; 应用于它们的祖先，然后使用后代选择器定位它们。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="精通CSS-高级Web标准解决方案" scheme="https://www.douglasdong.site/categories/%E7%B2%BE%E9%80%9ACSS-%E9%AB%98%E7%BA%A7Web%E6%A0%87%E5%87%86%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>响应式表格分析</title>
    <link href="https://www.douglasdong.site/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%A1%A8%E6%A0%BC%E5%88%86%E6%9E%90.html"/>
    <id>https://www.douglasdong.site/响应式表格分析.html</id>
    <published>2017-09-28T05:26:55.000Z</published>
    <updated>2018-08-06T15:03:05.710Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>深入分析课程：<strong>响应式表格 - 没有更多表格了</strong> 后，对源码的分析如下：</p><p>test123</p><p><br></p><p><strong>源代码</strong>:</p><iframe height="265" scrolling="no" title="RWDF L5 No More Tables" src="//codepen.io/Xeonice/embed/dVWNRy/?height=265&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/Xeonice/pen/dVWNRy/" target="_blank" rel="noopener">RWDF L5 No More Tables</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用了 nth-child(odd) 选择器对下标是奇数或偶数的 <code>&lt;tr&gt;</code> 进行选择，并设置其背景颜色为 <code>#f9f9f9</code> 。相关文档可参见 <a href="http://www.w3school.com.cn/cssref/selector_nth-child.asp" target="_blank" rel="noopener">CSS3 :nth-child() 选择器</a>。</p><p><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">thead</span> <span class="selector-tag">tr</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: -<span class="number">9999px</span>;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">9999px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>mediaQuery</code> 被触发时，使 DOM 树中的 thead，tr 元素移至浏览器可视窗口之外。不使用 <code>display: none</code> 的原因有两点：</p><ul><li>搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略，不为隐藏的对象保留物理占位空间。</li><li>会被屏幕阅读器所忽略。</li></ul><a id="more"></a><p><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">td</span> &#123; </div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">padding-left</span>: <span class="number">50%</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>mediaQuery</code> 被触发时，设定 <code>padding-left</code> 为页面 <code>width</code> 的50%。</p><p><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">td</span><span class="selector-pseudo">:before</span> &#123; </div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">6px</span>;</div><div class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(data-th);</div><div class="line">    <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>mediaQuery</code> 被触发时，在 <code>td</code> 元素前设置文字，定位采用绝对定位，内容为 HTML 文档中 <code>data-th</code> 处的文字。详细文档可见 <a href="http://www.w3school.com.cn/cssref/selector_before.asp" target="_blank" rel="noopener">CSS :before 选择器</a> 。</p><p><br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">td</span><span class="selector-pseudo">:first-of-type</span> &#123;</div><div class="line">    <span class="attribute">font-weight</span>: bold;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当 <code>mediaQuery</code> 被触发时，设定 首个 <code>td</code> 元素的字重为 <code>bold</code> 。这里是指表格中的 <code>San Francisco</code> 与 <code>Toronto</code> 。 详细文档可见：  <a href="http://www.w3school.com.cn/cssref/selector_first-of-type.asp" target="_blank" rel="noopener">CSS3 :first-of-type 选择器</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;深入分析课程：&lt;strong&gt;响应式表格 - 没有更多表格了&lt;/strong&gt; 后，对源码的分析如下：&lt;/p&gt;
&lt;p&gt;test123&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码&lt;/strong&gt;:&lt;/p&gt;
&lt;iframe height=&quot;265&quot; scrolling=&quot;no&quot; title=&quot;RWDF L5 No More Tables&quot; src=&quot;//codepen.io/Xeonice/embed/dVWNRy/?height=265&amp;theme-id=0&amp;default-tab=html,result&amp;embed-version=2&quot; frameborder=&quot;no&quot; allowtransparency=&quot;true&quot; allowfullscreen=&quot;true&quot; style=&quot;width: 100%;&quot;&gt;See the Pen &lt;a href=&quot;https://codepen.io/Xeonice/pen/dVWNRy/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RWDF L5 No More Tables&lt;/a&gt; by DouglasDong (&lt;a href=&quot;https://codepen.io/Xeonice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@Xeonice&lt;/a&gt;) on &lt;a href=&quot;https://codepen.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodePen&lt;/a&gt;.&lt;br&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;tr&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:nth-child(odd)&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background-color&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;#f9f9f9&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用了 nth-child(odd) 选择器对下标是奇数或偶数的 &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; 进行选择，并设置其背景颜色为 &lt;code&gt;#f9f9f9&lt;/code&gt; 。相关文档可参见 &lt;a href=&quot;http://www.w3school.com.cn/cssref/selector_nth-child.asp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSS3 :nth-child() 选择器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;thead&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;tr&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;position&lt;/span&gt;: absolute;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;top&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;9999px&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;left&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;9999px&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当 &lt;code&gt;mediaQuery&lt;/code&gt; 被触发时，使 DOM 树中的 thead，tr 元素移至浏览器可视窗口之外。不使用 &lt;code&gt;display: none&lt;/code&gt; 的原因有两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略，不为隐藏的对象保留物理占位空间。&lt;/li&gt;
&lt;li&gt;会被屏幕阅读器所忽略。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://www.douglasdong.site/tags/CSS/"/>
    
  </entry>
  
</feed>
