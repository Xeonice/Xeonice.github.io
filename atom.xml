<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Helve&#39;s Blog</title>
  
  <subtitle>前端学习杂录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.douglasdong.site/"/>
  <updated>2019-03-28T14:58:07.617Z</updated>
  <id>https://www.douglasdong.site/</id>
  
  <author>
    <name>Helvetica.D</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React diff 算法</title>
    <link href="https://www.douglasdong.site/2019-02-17.html"/>
    <id>https://www.douglasdong.site/2019-02-17.html</id>
    <published>2019-02-17T15:45:39.000Z</published>
    <updated>2019-03-28T14:58:07.617Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="为什么要用-diff-算法？"><a href="#为什么要用-diff-算法？" class="headerlink" title="为什么要用 diff 算法？"></a>为什么要用 diff 算法？</h1><p><code>Web</code> 界面是由 <code>DOM</code> 树构成的，当页面发生变化时，对应到 <code>DOM</code> 树中就是某个节点发生了变化。传统的 <a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener">diff 算法</a> 通过循环递归对节点进行依次对比，时间复杂度为 <code>O(n^3)</code>。意味着如果我们展示 1000 个节点，就需要做 <code>1,000^3 = 1,000,000,000</code> 次操作。这种实现在数据量极大的情况下对前端是绝对不可接受的。而且其中考虑到的相当一部分特殊情况也属于前端大部分时候不需要去考虑的部分，比如<code>不相交路径问题</code>、<code>子林问题</code>、<code>NP 完全问题</code>。</p><p>也就是说，<code>React</code> 如果单纯引入正统的 <code>Diff</code> 算法，不仅会做很多冗余运算，而且还会极大程度上拖慢前端渲染的性能。因此，<code>React</code> 针对前端渲染的情况做了大胆假设与推断，运用正统 <code>Diff</code> 算法中的一部分子集完成了一套针对于前端的高效 <code>Diff</code> 算法。</p><h1 id="React-所实现的-Diff-算法"><a href="#React-所实现的-Diff-算法" class="headerlink" title="React 所实现的 Diff 算法"></a>React 所实现的 Diff 算法</h1><p><code>React</code> 这套算法的实现并不复杂，其时间复杂度仅为 O(n)，主要依赖于以下几条 <code>diff</code> 策略。</p><ol><li><code>Web UI</code> 中跨节点的操作很少，几乎可以忽略不计</li><li>拥有相同类的两个组件会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>对于同一层级的一组子节点，它们可以通过唯一 <code>Id</code> 进行区分</li></ol><p>基于以上三条策略，<code>React</code> 分别对 <code>tree-diff</code>、<code>component-diff</code>、<code>element-diff</code> 进行了优化。</p><h2 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree-diff"></a>tree-diff</h2><p>既然跨节点操作可以忽略不计，那么我们完全可以忽略跨节点操作的情况，仅考虑同一层的节点变化情况，这样的同层比较就将原先 <code>O(n^3)</code> 的算法复杂度缩减到了 <code>O(n)</code>（PS：<code>React</code> 所实现的 <code>diff</code> 算法高效的原因仅仅是因为其需要考虑的情况较少，并不是说正统的 <code>diff</code> 算法劣于 <code>React-diff</code> 算法）</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2022.49.13.png" alt="tree-diff-1"></p><p><code>React</code> 通过 <code>updateDepth</code> 对 <code>Virtul-DOM 树</code> 进行层级控制，只会对同一层级的节点进行比较，当发现节点已不存在，则该节点及其子节点都会被删掉，不会用于进一步的比较。这样只需要做一次遍历，就可以完成整个 <code>DOM树</code> 的比较。</p><p>那么，如果出现跨层级的 <code>DOM</code> 节点移动的话，<code>React</code> 会如何进行处理呢？</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2022.50.03.png" alt="tree-diff-2"></p><p>直觉上来说，上图的 <code>Diff</code> 操作应该只涉及两个节点，即 <code>A.parentNode.remove</code> 与 <code>B.append(A)</code>，但是由于 <code>React</code> 只监听同一层的节点变换，所以它会先删除整个 <code>A</code> 节点及其子树，然后在 <code>D</code> 节点上重新生成 <code>A</code> 节点与其整个子树。其操作应该是 <code>Create A</code> =&gt; <code>Create B</code> =&gt; <code>Create C</code> =&gt; <code>Delete A</code>。如果是跨层级移动一个调用栈很深的节点的话，就会导致很明显的性能问题。</p><blockquote><p>注意：保持稳定的 <code>DOM</code> 结构，不做跨层级 <code>DOM</code> 操作有助于性能提升。例如，用 <code>CSS</code> 隐藏或显示节点，而不是真的隐藏或添加 <code>DOM</code> 节点。</p></blockquote><h2 id="component-diff"><a href="#component-diff" class="headerlink" title="component-diff"></a>component-diff</h2><p><code>React</code> 基于组件构建应用，对于组件间的比较采用的策略也同样简单高效。</p><ul><li>如果是同一类型的组件，按照原先策略继续比较</li><li>如果不是，则将该组件判断为 <code>dirty component</code>，从而替换整个组件下的子节点</li><li>对于同一类型的组件，有可能其 <code>Virtual DOM</code> 没有任何变化，如果能够确切的知道这点那可以节省大量的 <code>diff</code> 运算时间，因此 React 允许用户通过 <code>shouldComponentUpdate()</code> 来判断该组件是否需要进行 <code>diff</code>。</li></ul><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2022.50.32.png" alt="component-diff-1"></p><p>如上图，当 <code>componentD</code> 转为 <code>componentG</code> 的时候，即使这两个组件结构相似，一旦 <code>React</code> 判断这两个组件为不同类型的组件，就不会比较两者的结构，而是直接删除 <code>componentD</code>，并新建 <code>componentG</code> 以及其子节点。（PS：这也许是使用 <code>React-beautiful-dnd</code> 时必须使用 <code>shouldComponentUpdate</code> 规避 <code>Draggable</code> 下的所有子组件渲染的原因。因为 <code>Draggable</code> 内的组件进行了变化）</p><h1 id="element-diff"><a href="#element-diff" class="headerlink" title="element-diff"></a>element-diff</h1><p>组件位于同一层级时，React-diff 提供了三种节点操作，分别为 <code>INSERT_MARKUP（插入）</code>、<code>MOVE_EXISTING（移动）</code> 和 <code>REMOVE_NODE（删除）</code>。</p><ul><li><code>INSERT_MARKUP</code>，新的节点不在老的节点集合中，即全新的节点，需要对新节点执行插入操作</li><li><code>MOVE_EXISTING</code>，在老集合中有 <code>component</code> 类型，且 <code>element</code> 是可更新的类型，<code>generateComponentChildern</code> 已调用 <code>receiveComponent</code>，这种情况下 <code>prevChild=nextChild</code>，就需要调用移动操作，可以复用以前的 <code>DOM</code> 节点</li><li><code>REMOVE_NODE</code>，老 <code>component</code> 类型，在新集合中也有，但对应的 <code>element</code> 不同则不能直接复用和更新，需要执行删除操作。或者老的 <code>component</code> 不在新集合里的，也需要执行删除操作。</li></ul><h2 id="为什么需要-element-diff-原则？"><a href="#为什么需要-element-diff-原则？" class="headerlink" title="为什么需要 element-diff 原则？"></a>为什么需要 element-diff 原则？</h2><p>如下图，老集合中包含节点：<code>A、B、C、D</code>，更新后的新集合包含节点 <code>B、A、D、C</code>，此时新老集合进行 <code>diff</code> 差异化对比，发现 <code>B != A</code>，则创建并插入 <code>B</code> 至新集合，删除老集合 <code>A</code>，以此类推，创建 <code>A</code>、<code>D</code> 和 <code>C</code>，删除 <code>B</code>、<code>C</code>、和 <code>D</code>。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2018.35.34-1.png" alt="element-diff-1"></p><p>React 发现这类操作繁琐冗余，因为这些都是相同的节点。但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实上只需要进行位置移动即可。</p><p>针对这一现象，React 提出优化策略，允许开发者对同一层级的同组子节点，添加唯一 <code>key</code> 进行区分，虽然只是小小的改动，性能上却发生了翻天覆地的变化。</p><p>如下图所示，新老集合进行 <code>diff</code> 差异化对比，通过 <code>key</code> 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 <code>diff</code> 结果为：<code>B、D 不进行任何操作，A、C 进行移动操作</code></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2018.36.12.png" alt="element-diff-2"></p><blockquote><p>PS：我们用 <code>map</code> 方法将一组节点集合加入页面时，如果贪图省事将 <code>key</code> 设定为数组的 <code>index</code>，React 就会立即在控制台爆出 <code>warning</code>，其主要原因就在于，当我们对该数组进行操作时，如果删除或移动数组中任意一个节点，都会无可避免的导致 <code>index</code> 的变动。如果用经常变动的 <code>index</code> 作为 <code>key</code> 来标示节点，每次对数组进行操作后就会导致几乎所有的 <code>key</code> 变动，从而误导 React 对所有节点进行更新。 </p></blockquote><h2 id="element-diff-是如何运作的？"><a href="#element-diff-是如何运作的？" class="headerlink" title="element-diff 是如何运作的？"></a>element-diff 是如何运作的？</h2><p>首先先对新集合的节点进行循环便利，<code>for(name in nextChildren)</code>,通过唯一 <code>key</code> 可以判断新老集合中是否存在相同的节点，<code>if (prefChild === nextChild)</code>，存在相同节点时，进行移动操作。</p><p>移动前需要将当前节点在老集合中的位置与 <code>lastIndex</code> 进行比较，<code>if(child._mountIndex &lt; lastIndex)</code> 则进行节点移动操作，否则不执行该操作。这是一种顺序优化手段，<code>lastIndex</code> 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置）。<strong>如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作。只有当访问的节点比 <code>lastIndex</code> 小的时候，才需要进行移动操作。</strong></p><p> PS：下文中的 <code>lastIndex</code> 均指原数组元素更新后生成的当前 <code>index</code></p><h3 id="新老集合中存在相同节点但位置不同"><a href="#新老集合中存在相同节点但位置不同" class="headerlink" title="新老集合中存在相同节点但位置不同"></a>新老集合中存在相同节点但位置不同</h3><p> 以上图为例，可以更为清晰直观的描述 diff 的差异对比流程</p><ul><li>从新集合中取得 B，判断老集合中存在相同节点 B，通过对比节点位置判断是否进行移动操作，B 在老集合中的位置 <code>B._mountIndex = 1</code>，此时 <code>lastIndex = 0</code>，不满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此不对 B 进行移动操作，更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，其中 <code>prevChild._mountIndex</code> 表示 B 在老集合中的位置，则 <code>lastIndex = 1</code>，并将 B 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>B._mountIndex = 0</code>，<code>nextIdnex ++</code> 进入下一个节点的判断</li><li>从新集合中取得 A，判断老集合中存在相同节点 A，通过对比节点位置判断是否进行移动操作，A 在老集合中的位置 <code>A._mountIndex = 0</code>，此时 <code>lastIndex = 1</code>，满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此对 A 进行移动操作 <code>enqueueMove(this, child._mountIndex, toIndex)</code>，其中 <code>toIndex</code> 其实就是 <code>nextIndex</code>，表示 A 需要移动到的位置；更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex = 1</code>，并将 A 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>A._mountIndex = 1</code>，<code>nextIndex++</code> 进入下一个节点的判断。</li><li><p>从新集合中取得 D，判断老集合中存在相同节点 D，通过对比节点位置判断是否进行移动操作，D 在老集合中的位置 <code>D._mountIndex = 3</code>，此时 <code>lastIndex = 1</code>，不满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此不对 D 进行移动操作；更新 <code>lastIndex = Math.max(prevChild._mountIndex = nextIndex)</code>，则 <code>lastIndex = 3</code>，并将 D 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>D._mountIndex = 2</code>，<code>nextIndex++</code> 进入下一个节点的判断</p></li><li><p>从新集合中取得 C，判断老集合中存在相同节点 C，通过对比节点位置判断是否进行移动操作，C 在老集合中的位置 <code>C._mountIndex = 2</code>，此时 <code>lastIndex = 3</code>，满足 <code>child._mountIndex &lt; lastIndex</code> 的条件，因此对 C 进行移动操作 <code>enqueueMove(this, child._mountIndex, toIndex)</code>；更新 <code>lastIndex = Math.max(prevChild._mountIndex, lastIndex)</code>，则 <code>lastIndex ＝ 3</code>，并将 C 的位置更新为新集合中的位置 <code>prevChild._mountIndex = nextIndex</code>，此时新集合中 <code>C._mountIndex = 3</code>，<code>nextIndex++</code> 进入下一个节点的判断，由于 C 已经是最后一个节点，因此 diff 到此完成。</p></li></ul><p>如果新集合中有新加入的节点且老集合中存在需要删除的节点，<code>React diff</code> 又是如何对比运作的呢？</p><h3 id="新集合有新加入节点，老集合中存在需要删除的节点"><a href="#新集合有新加入节点，老集合中存在需要删除的节点" class="headerlink" title="新集合有新加入节点，老集合中存在需要删除的节点"></a>新集合有新加入节点，老集合中存在需要删除的节点</h3><p>以下图为例：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2022.23.19.png" alt="element-diff-3"></p><ul><li><p>从新集合中取得 B，判断老集合中存在相同节点 B，由于 B 在老集合中的位置 <code>B._mountIndex = 1</code>，此时 <code>lastIndex = 0</code>，因此不对 B 进行移动操作；更新 <code>lastIndex ＝ 1</code>，并将 B 的位置更新为新集合中的位置 <code>B._mountIndex = 0</code>，<code>nextIndex++</code> 进入下一个节点的判断。</p></li><li><p>从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 E；更新 <code>lastIndex ＝ 1</code>，并将 E 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p></li><li><p>从新集合中取得 C，判断老集合中存在相同节点 C，由于 C 在老集合中的位置 <code>C._mountIndex = 2</code>，<code>lastIndex = 1</code>，此时 <code>C._mountIndex &gt; lastIndex</code>，因此不对 C 进行移动操作；更新 <code>lastIndex ＝ 2</code>，并将 C 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p></li><li><p>从新集合中取得 A，判断老集合中存在相同节点 A，由于 A 在老集合中的位置<code>A._mountIndex = 0</code>，<code>lastIndex = 2</code>，此时 <code>A._mountIndex &lt; lastIndex</code>，因此对 A 进行移动操作；更新 <code>lastIndex ＝ 2</code>，并将 A 的位置更新为新集合中的位置，<code>nextIndex++</code> 进入下一个节点的判断。</p></li><li><p>当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D，到此 diff 全部完成。</p></li></ul><h3 id="React-Diff-的不足"><a href="#React-Diff-的不足" class="headerlink" title="React Diff 的不足"></a>React Diff 的不足</h3><p>如下图所示，新集合的节点更新为：D、A、B、C，与老集合对比只有 D 节点移动，而 A、B、C 仍然保持原有的顺序，理论上 diff 应该只需对 D 进行移动操作，然而由于 D 在老集合中的位置是最大的，导致其他节点的 <code>_mountIndex &lt; lastIndex</code>，造成 D 没有执行移动操作，而是 A、B、C 全部移动到 D 节点后面。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2019-03-28-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202019-03-28%2022.57.15.png" alt="element-diff-4"></p><blockquote><p>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>React 通过制定大胆的 diff 策略，将 <code>O(n^3)</code> 复杂度的问题转换成 <code>O(n)</code> 复杂度的问题</li><li>React 通过分层求异的方法，对 <code>tree diff</code> 进行算法优化</li><li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 <code>component diff</code> 进行算法优化</li><li>React 通过设置唯一 key 的策略，对 <code>element diff</code> 进行算法优化</li><li>建议：在开发组件时，保持稳定的 DOM 结构会有助于性能的提升（前端铁则）</li><li>建议：在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能（可以将节点移动的操作转换为 CSS 位置变动的操作，如利用 <code>transform</code> 变动节点 <code>position</code> 坐标）</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本篇文章为阅读 Pure render 发布的 diff 算法解析后，在原有文章上添加了一些自有注解的产物，非原创文章。</p><p><a href="https://zhuanlan.zhihu.com/p/20346379" target="_blank" rel="noopener">React 源码剖析系列 － 不可思议的 react diff</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;React 作为一款流行于市面的框架，其内部逻辑并不是非常复杂。本篇文章我们先从 React 最为核心的 diff 算法入手，看看它是如何运作的&lt;/center&gt;
    
    </summary>
    
      <category term="自行动手 Diy React" scheme="https://www.douglasdong.site/categories/%E8%87%AA%E8%A1%8C%E5%8A%A8%E6%89%8B-Diy-React/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="React" scheme="https://www.douglasdong.site/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 重复渲染分析及优化</title>
    <link href="https://www.douglasdong.site/2018-12-17.html"/>
    <id>https://www.douglasdong.site/2018-12-17.html</id>
    <published>2018-12-16T07:06:37.000Z</published>
    <updated>2018-12-22T04:41:17.273Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在维护 Choerodon-agile 代码时，发现有一个数据量很大的页面存在显著的页面加载性能问题。具体情况大概是这个样子的：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-12-16-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202018-12-16%2015.38.16.png" alt="屏幕截图 2018-12-16 15.38.16"></p><p>可以从上图的 <code>Performance</code> 看到，原先的代码加载次数达到了 9 次之多，而其中的大部分渲染都是对于页面加载无用的渲染，白白占用了首屏渲染时间。而且这个问题会随着数据量的增加变的更加显著。那么我们应该如何解决这个问题呢？</p><h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><p>解决问题的第一步是先定位问题，项目的原代码中混用了 <code>Mobx</code> 与 <code>State</code>，导致我们很难追踪哪一次渲染是由 <code>State</code> 导致的，哪一次渲染是由 <code>Mobx</code> 导致的。因此，我们需要先利用 <code>shouldComponentUpdate</code> 追踪由 <code>State</code> 导致的渲染。</p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p><code>shouldComponentUpdate</code> 是 React 性能优化中重要的一环，它可以帮你决定哪些情况下组件是不需要被渲染的。具体的代码结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps,nextState)&#123;</span><br><span class="line">  <span class="keyword">if</span>(nextState.Number == <span class="keyword">this</span>.state.Number)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>shouldComponentUpdate</code> 在下一次渲染前传入下一个参数与状态，并返回一个 <code>Boolean</code> 值，用以决定是否要进行下一次渲染。如果 <code>Boolean</code> 值为 <code>false</code>，则不进行下一次的渲染。</p><p><code>Choerodon</code> 的整个前端基本都是运用 <code>Mobx</code> 在管理状态，因此这里用 <code>shouldComponentUpdate</code> 主要是为了判断哪些 <code>State</code> 会导致重渲染，并将这些会导致重渲染的状态都放进 <code>Mobx</code> 中进行管理。</p><h2 id="Mobx-渲染判断"><a href="#Mobx-渲染判断" class="headerlink" title="Mobx 渲染判断"></a>Mobx 渲染判断</h2><p>将所有的 <code>State</code> 放进 <code>Mobx</code> 进行管理后，还是能触发六次之多的渲染，这些渲染用 <code>shouldComponentUpdate</code> 都是追踪不到的，所以说这些内容都是由 <code>Mobx</code> 进行的重新渲染。那我们如何确定哪些 <code>Mobx</code> 的状态变化导致了重渲染？这里就需要利用 <code>Mobx</code> 自带的追踪函数 <code>trace</code> 了。</p><h3 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h3><p>trace 是 <code>Mobx</code> 提供的专门用于性能优化的函数。可以先利用 <code>import</code> 命令引入，然后在组件的 <code>render</code> 函数内添加 <code>trace(true)</code> 来开启 <code>trace</code> 功能。</p><p>开启 <code>trace</code> 功能后，<code>render</code> 在执行的时候就会自动在 <code>Mobx</code> 触发渲染时自动触发 <code>debugger</code>，如下图所示：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-12-16-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202018-12-16%2016.41.20.png" alt="屏幕截图 2018-12-16 16.41.20"></p><p>其中 <code>dependencies</code> 部分的代码用于提示你代码中的哪一个 <code>computed</code> 属性产生了变动，从而触发了 <code>Mobx</code> 的重渲染。顺着这条路径，我们可以找到项目中的诸多优化点。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a>Mobx</h2><p>通过分析 <code>trace</code> 提供的信息，我们可以看到原代码中这一部分代码在频繁的触发重渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">loadIssues(page = <span class="number">0</span>, size = <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setLoading(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> &#123; orderField = <span class="string">''</span>, orderType = <span class="string">''</span> &#125; = <span class="keyword">this</span>.order;</span><br><span class="line">    <span class="keyword">return</span> loadIssues(page, size, toJS(<span class="keyword">this</span>.getFilter), orderField, orderType)</span><br><span class="line">        .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setIssues(res.content);</span><br><span class="line">        <span class="keyword">const</span> arrAssignee = []; </span><br><span class="line">        _.forEach(res.content, (item) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.assigneeId &amp;&amp; item.assigneeName) &#123;</span><br><span class="line">            arrAssignee.push(&#123;</span><br><span class="line">            id: item.assigneeId,</span><br><span class="line">            realName: item.assigneeName,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setAssigneeProps(_.map(_.union(_.map(arrAssignee, <span class="built_in">JSON</span>.stringify)),<span class="built_in">JSON</span>.parse));</span><br><span class="line">    <span class="keyword">this</span>.setPagination(&#123;</span><br><span class="line">      current: res.number + <span class="number">1</span>,</span><br><span class="line">      pageSize: res.size,</span><br><span class="line">      total: res.totalElements,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setLoading(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段代码是用于刷新的逻辑，代码本身并不是 <code>@action</code>，但是在代码中频繁的调用了 <code>@action</code>。这导致 <code>Mobx</code> 中 <code>@observable</code> 属性频繁变动，从而造成了页面的多次渲染。解决方法是，将整个代码段变成一个 <code>@action</code> 函数，将其从 <code>@action</code> 的集合变成单个 <code>@action</code>，这样就可以显著减少 <code>@observable</code> 属性的变动次数，以达到减少渲染次数的目标。</p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>原代码结构中，各个组件的显示逻辑被紧密的耦合在了一起，从而导致一个组件中的属性变动，整个页面都要重新渲染。这并不符合 <code>React</code> 的设计风格，因此，在重构这一部分的时候，优化性能的重点就在于将整个页面的逻辑通通解耦到各个子组件中，让子组件自行管理自己的状态。</p><p>所以，整体的代码结构由之前的这种结构：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-12-16-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202018-12-16%2018.13.36.png" alt="屏幕截图 2018-12-16 18.13.36"></p><p>变成了这种结构：</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-12-16-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202018-12-16%2018.16.02.png" alt="屏幕截图 2018-12-16 18.16.02"></p><p>这样就成功的解耦了各个子组件，让其能够自行管理状态</p><h2 id="交互优化"><a href="#交互优化" class="headerlink" title="交互优化"></a>交互优化</h2><p>之前运用 <code>Mobx</code> 所进行的优化虽然大大减少了渲染次数，提升了首屏加载时间，但是在交互过程中依旧存在一个问题。</p><p>原先的代码中使用了 <code>Choerodon-UI</code> 提供的 <code>Table</code>，在渲染 200 条数据的时候，<code>Choerodon-UI</code> 的 <code>Table</code> 一旦重渲染就会造成 2s 时间的渲染延时。而 <code>Agile</code> 中的展开任务详情必须利用外部属性来控制 <code>Table</code> 的显示样式。</p><p>这就导致用户在操作 <code>Table</code> 时，如果设置了 200 条的分页，就会因为重渲染产生一个很明显的操作延时。而这 2s 的重渲染时间，大部分都用在了销毁原节点与新建新节点上。因此，这一部分的核心思路是如何规避渲染。</p><h3 id="CSS-注入"><a href="#CSS-注入" class="headerlink" title="CSS 注入"></a>CSS 注入</h3><p>这一块的解决方法十分神奇，我们新建了一个空组件，其中接收需要进行控制的属性。然后根据外部的属性来控制内部的 <code>className</code>，当属性符合当前需求时添加 <code>className</code>。然后利用 <code>CSS</code> 本身提供的<code>相邻兄弟选择器</code>，将这个空组件放置到需要控制的组件前面。</p><p>当空组件和目标组件同时拥有 <code>className</code> 时，<code>相邻兄弟选择器</code>触发，成功变动 CSS 样式。这种方法我们暂时称其为 CSS 注入</p><h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>至此，整个 <code>Agile</code> 页面的性能优化就告一段落了。目前为止，<code>Choerodon-Agile</code> 中依旧存在相当一部分性能问题，不过以上的这些方法已经成功的将原先的 8s 渲染时间压缩到了 2s 不到，交互时的延时也被很好的规避了。目前来看，<code>Mobx</code> 虽然是一种能够有效管理状态的工具，但是滥用 <code>@action</code> 依然会带来相当严重的重渲染问题，需要在日常开发中着重关注这一点。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Choerodon-Agile 中有相当一部分的代码存在多次渲染的问题，多次无用的渲染显著的拖慢了首屏加载时间。我们如何才能分辨出哪些渲染是 Mobx 导致的？哪些渲染是 state 变动导致的？怎么组织代码才能显著减少渲染次数？&lt;/center&gt;
    
    </summary>
    
      <category term="React 代码性能优化" scheme="https://www.douglasdong.site/categories/React-%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="React" scheme="https://www.douglasdong.site/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>create-react-app 源代码分析</title>
    <link href="https://www.douglasdong.site/2018-10-13.html"/>
    <id>https://www.douglasdong.site/2018-10-13.html</id>
    <published>2018-10-13T10:02:56.000Z</published>
    <updated>2018-12-22T04:41:20.263Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h1><p>分析一个项目的代码，首先从它的入口文件开始</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"workspaces"</span>: [</span><br><span class="line">    <span class="string">"packages/*"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"cd packages/react-scripts &amp;&amp; node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"changelog"</span>: <span class="string">"lerna-changelog"</span>,</span><br><span class="line">    <span class="attr">"create-react-app"</span>: <span class="string">"node tasks/cra.js"</span>,</span><br><span class="line">    <span class="attr">"e2e"</span>: <span class="string">"tasks/e2e-simple.sh"</span>,</span><br><span class="line">    <span class="attr">"e2e:docker"</span>: <span class="string">"tasks/local-test.sh"</span>,</span><br><span class="line">    <span class="attr">"postinstall"</span>: <span class="string">"cd packages/react-error-overlay/ &amp;&amp; yarn build:prod"</span>,</span><br><span class="line">    <span class="attr">"publish"</span>: <span class="string">"tasks/publish.sh"</span>,</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"cd packages/react-scripts &amp;&amp; node scripts/start.js"</span>,</span><br><span class="line">    <span class="attr">"screencast"</span>: <span class="string">"svg-term --cast hItN7sl5yfCPTHxvFg5glhhfp --out screencast.svg --window"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"cd packages/react-scripts &amp;&amp; node scripts/test.js --env=jsdom"</span>,</span><br><span class="line">    <span class="attr">"format"</span>: <span class="string">"prettier --trailing-comma es5 --single-quote --write 'packages/*/*.js' 'packages/*/!(node_modules)/**/*.js'"</span>,</span><br><span class="line">    <span class="attr">"precommit"</span>: <span class="string">"lint-staged"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"^4.4.1"</span>,</span><br><span class="line">    <span class="attr">"husky"</span>: <span class="string">"^0.13.2"</span>,</span><br><span class="line">    <span class="attr">"lerna"</span>: <span class="string">"2.6.0"</span>,</span><br><span class="line">    <span class="attr">"lerna-changelog"</span>: <span class="string">"^0.6.0"</span>,</span><br><span class="line">    <span class="attr">"lint-staged"</span>: <span class="string">"^3.3.1"</span>,</span><br><span class="line">    <span class="attr">"prettier"</span>: <span class="string">"1.6.1"</span>,</span><br><span class="line">    <span class="attr">"svg-term-cli"</span>: <span class="string">"^2.0.3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"*.js"</span>: [</span><br><span class="line">      <span class="string">"prettier --trailing-comma es5 --single-quote --write"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"yarn.lock"</span>: [</span><br><span class="line">      <span class="string">"git rm --cached"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h2><p>从整个入口文件中，我们可以看到，它所采用的开发依赖主要为</p><ul><li><code>eslint</code> – 用于规范代码的工具</li><li><code>husky</code> – <code>git commit</code> 的钩子函数</li><li><code>lerna</code> – 用于管理多 <code>package</code> 项目，具体使用可参见<a href="https://juejin.im/post/5a989fb451882555731b88c2" target="_blank" rel="noopener">lerna管理前端packages的最佳实践</a></li><li><code>lerna-changelog</code> – 同上</li><li><code>lint-staged</code> – 指定 <code>commit</code> 钩子函数应用于现有提交代码</li><li><code>prettier</code> – 代码格式化工具，它可以支持 <code>JS/JSX/TS/Flow/JSON/CSS/LESS</code> 等文件格式</li><li><code>svg-term-cli</code> –输出 <code>ASCII</code> 动画？</li></ul><p>接下来我们来直接分析它的主目录 – <code>packages</code></p><h1 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h1><p><code>packages</code> 文件夹下有 6 个进行过规范命名的子文件夹：</p><ul><li>babel-preset-react-app</li><li>create-react-app</li><li>eslint-config-react-app</li><li>react-dev-utils</li><li>react-error-overlay</li><li>react-scripts</li></ul><h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><p><code>create-react-app</code> 由入口文件 <code>index.js</code> 和 <code>create-react-app.js</code> 这两个文件组成</p><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><p><code>index.js</code> 省略上面一大段的注释后还是非常简短的，下面我们通过边调试边分析的方式来分析这整段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>); <span class="comment">// 一个将命令行中输出的命令变色的库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> currentNodeVersion = process.versions.node; <span class="comment">// 获取当前 node 版本号</span></span><br><span class="line"><span class="keyword">var</span> semver = currentNodeVersion.split(<span class="string">'.'</span>); </span><br><span class="line"><span class="keyword">var</span> major = semver[<span class="number">0</span>]; <span class="comment">// 取出第一位版本号，如 10.10.0 只取 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node 版本小于 4 直接跳出</span></span><br><span class="line"><span class="keyword">if</span> (major &lt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    chalk.red(</span><br><span class="line">      <span class="string">'You are running Node '</span> +</span><br><span class="line">        currentNodeVersion +</span><br><span class="line">        <span class="string">'.\n'</span> +</span><br><span class="line">        <span class="string">'Create React App requires Node 4 or higher. \n'</span> +</span><br><span class="line">        <span class="string">'Please update your version of Node.'</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./createReactApp'</span>);</span><br></pre></td></tr></table></figure><p>上述的代码涉及到两个 <code>Node</code> 提供的 API，<a href="http://nodejs.cn/api/process.html#process_process_versions" target="_blank" rel="noopener">process.versions</a>、<a href="http://nodejs.cn/api/process.html#process_process_exit_code" target="_blank" rel="noopener">process.exit</a>，简要的 API 说明如下：</p><ul><li><code>process.versions</code> – 返回一个对象，其中包含各种 <code>Node.js</code> 和其依赖的版本信息</li><li><code>process.exit</code> – 结束 <code>Node</code> 进程，<code>1</code> 是状态码，表示有异常没有处理</li></ul><p><code>Node.js</code> 用于错误处理的状态码可以参看这篇文档<a href="http://nodejs.cn/api/process.html#process_process_exit_code" target="_blank" rel="noopener">Exit Codes</a></p><h2 id="create-react-app-1"><a href="#create-react-app-1" class="headerlink" title="create-react-app"></a>create-react-app</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validateProjectName = <span class="built_in">require</span>(<span class="string">'validate-npm-package-name'</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="keyword">const</span> commander = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs-extra'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> execSync = <span class="built_in">require</span>(<span class="string">'child_process'</span>).execSync;</span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'cross-spawn'</span>);</span><br><span class="line"><span class="keyword">const</span> semver = <span class="built_in">require</span>(<span class="string">'semver'</span>);</span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"><span class="keyword">const</span> tmp = <span class="built_in">require</span>(<span class="string">'tmp'</span>);</span><br><span class="line"><span class="keyword">const</span> unpack = <span class="built_in">require</span>(<span class="string">'tar-pack'</span>).unpack;</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> hyperquest = <span class="built_in">require</span>(<span class="string">'hyperquest'</span>);</span><br><span class="line"><span class="keyword">const</span> envinfo = <span class="built_in">require</span>(<span class="string">'envinfo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> packageJson = <span class="built_in">require</span>(<span class="string">'./package.json'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> projectName; <span class="comment">// 定义了一个用来存储项目名称的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> program = <span class="keyword">new</span> commander.Command(packageJson.name) <span class="comment">// 构建 node 命令行工具的库</span></span><br><span class="line">  .version(packageJson.version) <span class="comment">// 输入 create-react-app -v 时读取所需的版本信息</span></span><br><span class="line">  .arguments(<span class="string">'&lt;project-directory&gt;'</span>) <span class="comment">// 传入 create-react-app &lt;my-project&gt; 中尖括号中的参数</span></span><br><span class="line">  .usage(<span class="string">`<span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span> [options]`</span>) <span class="comment">// 输入 create-react-app 时第一行打印的信息</span></span><br><span class="line">  .action(<span class="function"><span class="params">name</span> =&gt;</span> &#123; <span class="comment">// 初始化项目名称，就是之前 argument 中的 &lt;project-directory&gt;</span></span><br><span class="line">    projectName = name;</span><br><span class="line">  &#125;)</span><br><span class="line">  .option(<span class="string">'--verbose'</span>, <span class="string">'print additional logs'</span>) <span class="comment">// 配置 create-react-app -[option] 的选项，类似 --help、-V</span></span><br><span class="line">  .option(<span class="string">'--info'</span>, <span class="string">'print environment debug info'</span>) <span class="comment">// 打印本地相关开发环境</span></span><br><span class="line">  .option( <span class="comment">// 使用特殊的 react-scripts</span></span><br><span class="line">    <span class="string">'--scripts-version &lt;alternative-package&gt;'</span>,</span><br><span class="line">    <span class="string">'use a non-standard version of react-scripts'</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 默认使用 yarn，指定此参数使用 npm</span></span><br><span class="line">  .option(<span class="string">'--use-npm'</span>)</span><br><span class="line">  .allowUnknownOption() <span class="comment">// 允许无效的 option 键入</span></span><br><span class="line">  .on(<span class="string">'--help'</span>, () =&gt; &#123; <span class="comment">// --help 时打印的信息，这里省去</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 最后一行接受命令行参数</span></span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个开发者内部使用的方法，可以自定义输出的模版文件夹</span></span><br><span class="line"><span class="keyword">const</span> hiddenProgram = <span class="keyword">new</span> commander.Command()</span><br><span class="line">  .option(</span><br><span class="line">    <span class="string">'--internal-testing-template &lt;path-to-template&gt;'</span>,</span><br><span class="line">    <span class="string">'(internal usage only, DO NOT RELY ON THIS) '</span> +</span><br><span class="line">      <span class="string">'use a non-standard application template'</span></span><br><span class="line">  )</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"><span class="comment">// 如果执行时没有传入指定目录</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> projectName === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果带了 --info 参数就执行下列代码，不会跳出报错</span></span><br><span class="line">  <span class="keyword">if</span> (program.info) &#123;</span><br><span class="line">    <span class="comment">// 打印当前环境信息和 ‘react’、‘react-dom’、‘react-script’ 三个包的信息</span></span><br><span class="line">    envinfo.print(&#123;</span><br><span class="line">      packages: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-scripts'</span>],</span><br><span class="line">      noNativeIDE: <span class="literal">true</span>,</span><br><span class="line">      duplicates: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则就抛出错误和使用方法</span></span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Please specify the project directory:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'&lt;project-directory&gt;'</span>)&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'For example:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`  <span class="subst">$&#123;chalk.cyan(program.name())&#125;</span> <span class="subst">$&#123;chalk.green(<span class="string">'my-react-app'</span>)&#125;</span>`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`Run <span class="subst">$&#123;chalk.cyan(<span class="string">`<span class="subst">$&#123;program.name()&#125;</span> --help`</span>)&#125;</span> to see all options.`</span></span><br><span class="line">  );</span><br><span class="line">  process.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 符合条件时调用 createApp 函数</span></span><br><span class="line"><span class="comment">// 其中有五个参数，分别是 projectName，program.verbose，program.scriptsVersion，program.useNpm，hiddenProgram.internalTestingTemplate</span></span><br><span class="line"><span class="comment">// projectName -- 执行时传入的项目名称</span></span><br><span class="line"><span class="comment">// program.verbose -- 在 yarn 和 npm 安装的时候打印本地信息</span></span><br><span class="line"><span class="comment">// program.scriptsVersion -- 指定 react-scripts 版本</span></span><br><span class="line"><span class="comment">// program.useNpm -- 使用 npm 还是 yarn</span></span><br><span class="line"><span class="comment">// hiddenProgram.internalTestingTemplate -- 之前提到过的，指定初始化的模版</span></span><br><span class="line">createApp(</span><br><span class="line">  projectName,</span><br><span class="line">  program.verbose,</span><br><span class="line">  program.scriptsVersion,</span><br><span class="line">  program.useNpm,</span><br><span class="line">  hiddenProgram.internalTestingTemplate</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApp</span>(<span class="params">name, verbose, version, useNpm, template</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = path.resolve(name); <span class="comment">// 获取传入目录的绝对路径</span></span><br><span class="line">  <span class="keyword">const</span> appName = path.basename(root); <span class="comment">// 返回绝对路径的最后一部分</span></span><br><span class="line"></span><br><span class="line">  checkAppName(appName); <span class="comment">// 判断文件名是否合法</span></span><br><span class="line">  fs.ensureDirSync(name); <span class="comment">// 判断当前目录下是否有这个文件夹，没有就创建（PS：这里的 fs 调用的是 fs-extra 下的内容）https://juejin.im/post/5b52fd21e51d4519234468f1</span></span><br><span class="line">  <span class="comment">// 判断文件夹下是否有可能会造成冲突的文件 / 文件夹名称是否被占用</span></span><br><span class="line">  <span class="keyword">if</span> (!isSafeToCreateProjectIn(root, name)) &#123;</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提示已成功创建</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Creating a new React app in <span class="subst">$&#123;chalk.green(root)&#125;</span>.`</span>);</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="comment">// 初始化 package.json 基本内容</span></span><br><span class="line">  <span class="keyword">const</span> packageJson = &#123;</span><br><span class="line">    name: appName,</span><br><span class="line">    version: <span class="string">'0.1.0'</span>,</span><br><span class="line">    private: <span class="literal">true</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向创建文件夹内写入 package.json 文件</span></span><br><span class="line">  fs.writeFileSync(</span><br><span class="line">    path.join(root, <span class="string">'package.json'</span>),</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(packageJson, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 定义常量 useYarn，如果指定使用 npm 则定义为 false</span></span><br><span class="line">  <span class="comment">// 否则调用 shouldUseYarn 查询本机是否安装 yarn</span></span><br><span class="line">  <span class="keyword">const</span> useYarn = useNpm ? <span class="literal">false</span> : shouldUseYarn();</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">const</span> originalDirectory = process.cwd();</span><br><span class="line">  <span class="comment">// 变更 Node.js 进程的当前工作目录</span></span><br><span class="line">  process.chdir(root);</span><br><span class="line">  <span class="comment">// checkThatNpmCanReadCwd 这个函数的作用是检查进程目录是否是我们创建的目录</span></span><br><span class="line">  <span class="keyword">if</span> (!useYarn &amp;&amp; !checkThatNpmCanReadCwd()) &#123;</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较 node 版本，小于 6 的时候发出警告，并制定 react-scripts 版本为支持 6 以下的 0.9</span></span><br><span class="line">  <span class="keyword">if</span> (!semver.satisfies(process.version, <span class="string">'&gt;=6.0.0'</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      chalk.yellow(</span><br><span class="line">        <span class="string">`You are using Node <span class="subst">$&#123;process.version&#125;</span> so the project will be bootstrapped with an old unsupported version of tools.\n\n`</span> +</span><br><span class="line">          <span class="string">`Please update to Node 6 or higher for a better, fully supported experience.\n`</span></span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// Fall back to latest supported react-scripts on Node 4</span></span><br><span class="line">    version = <span class="string">'react-scripts@0.9.x'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果未使用 yarn，而且 npm 版本在 3 以下的时候进行提示</span></span><br><span class="line">  <span class="comment">// 如果 npm 版本在 3 以上，自动将 react-scripts 切到 0.9</span></span><br><span class="line">  <span class="keyword">if</span> (!useYarn) &#123;</span><br><span class="line">    <span class="keyword">const</span> npmInfo = checkNpmVersion();</span><br><span class="line">    <span class="keyword">if</span> (!npmInfo.hasMinNpm) &#123;</span><br><span class="line">      <span class="keyword">if</span> (npmInfo.npmVersion) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          chalk.yellow(</span><br><span class="line">            <span class="string">`You are using npm <span class="subst">$&#123;npmInfo.npmVersion&#125;</span> so the project will be boostrapped with an old unsupported version of tools.\n\n`</span> +</span><br><span class="line">              <span class="string">`Please update to npm 3 or higher for a better, fully supported experience.\n`</span></span><br><span class="line">          )</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Fall back to latest supported react-scripts for npm 3</span></span><br><span class="line">      version = <span class="string">'react-scripts@0.9.x'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 传入这些参数执行 run 函数</span></span><br><span class="line">  run(root, appName, version, verbose, originalDirectory, template, useYarn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在开始下一个核心函数之前，我们先来了解一下 <code>createApp</code> 所需要调用的依赖</p><p>外部依赖：</p><ul><li><code>fs-extra</code>：外部依赖，<code>Node</code> 自带文件模块的外部扩展模块</li><li><code>semver</code>：用于比较 npm 版本</li></ul><p>函数依赖：</p><ul><li><code>checkAppName</code> – 用于检测文件名是否合法</li><li><code>isSafeToCreateProjectIn</code> – 判断文件夹下是否有可能会造成冲突的文件 / 文件夹名称是否被占用</li><li><code>shouldUseYarn</code> – 检测 <code>yarn</code> 是否已经安装</li><li><code>CheckThatNpmCanReadCwd</code> – 检测 <code>npm</code> 是否在正确的目录下执行</li><li><code>checkNpmVersion</code> – 检测 <code>npm</code> 是否在本机安装</li></ul><h3 id="checkAppName"><a href="#checkAppName" class="headerlink" title="checkAppName()"></a>checkAppName()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAppName</span>(<span class="params">appName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 validateProjectName 检查包名是否返回结果，这个 validateProjectName 是外部依赖的引用</span></span><br><span class="line">  <span class="keyword">const</span> validationResult = validateProjectName(appName);</span><br><span class="line">  <span class="comment">// 如果对象中有错误则抛出并报错（不符合 npm 命名规范）</span></span><br><span class="line">  <span class="keyword">if</span> (!validationResult.validForNewPackages) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      <span class="string">`Could not create a project called <span class="subst">$&#123;chalk.red(</span></span></span><br><span class="line"><span class="string"><span class="subst">        <span class="string">`"<span class="subst">$&#123;appName&#125;</span>"`</span></span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span> because of npm naming restrictions:`</span></span><br><span class="line">    );</span><br><span class="line">    printValidationResults(validationResult.errors);</span><br><span class="line">    printValidationResults(validationResult.warnings);</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> there should be a single place that holds the dependencies</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-scripts'</span>].sort();</span><br><span class="line">  <span class="comment">// 和依赖重名时报错并跳出</span></span><br><span class="line">  <span class="keyword">if</span> (dependencies.indexOf(appName) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      chalk.red(</span><br><span class="line">        <span class="string">`We cannot create a project called <span class="subst">$&#123;chalk.green(</span></span></span><br><span class="line"><span class="string"><span class="subst">          appName</span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span> because a dependency with the same name exists.\n`</span> +</span><br><span class="line">          <span class="string">`Due to the way npm works, the following names are not allowed:\n\n`</span></span><br><span class="line">      ) +</span><br><span class="line">        chalk.cyan(dependencies.map(<span class="function"><span class="params">depName</span> =&gt;</span> <span class="string">`  <span class="subst">$&#123;depName&#125;</span>`</span>).join(<span class="string">'\n'</span>)) +</span><br><span class="line">        chalk.red(<span class="string">'\n\nPlease choose a different project name.'</span>)</span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是用了一个外部依赖来校验文件名是否符合 <code>npm</code> 包文件名的规范，并判断了一下和依赖重名时的情况</p><p>外部依赖：</p><ul><li><code>validate-npm-package-name</code> – 检查包名是否合法</li></ul><h3 id="isSafeToCreateProjectIn"><a href="#isSafeToCreateProjectIn" class="headerlink" title="isSafeToCreateProjectIn"></a>isSafeToCreateProjectIn</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSafeToCreateProjectIn</span>(<span class="params">root, name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是这些文件就不算冲突</span></span><br><span class="line">  <span class="keyword">const</span> validFiles = [</span><br><span class="line">    <span class="string">'.DS_Store'</span>,</span><br><span class="line">    <span class="string">'Thumbs.db'</span>,</span><br><span class="line">    <span class="string">'.git'</span>,</span><br><span class="line">    <span class="string">'.gitignore'</span>,</span><br><span class="line">    <span class="string">'.idea'</span>,</span><br><span class="line">    <span class="string">'README.md'</span>,</span><br><span class="line">    <span class="string">'LICENSE'</span>,</span><br><span class="line">    <span class="string">'web.iml'</span>,</span><br><span class="line">    <span class="string">'.hg'</span>,</span><br><span class="line">    <span class="string">'.hgignore'</span>,</span><br><span class="line">    <span class="string">'.hgcheck'</span>,</span><br><span class="line">    <span class="string">'.npmignore'</span>,</span><br><span class="line">    <span class="string">'mkdocs.yml'</span>,</span><br><span class="line">    <span class="string">'docs'</span>,</span><br><span class="line">    <span class="string">'.travis.yml'</span>,</span><br><span class="line">    <span class="string">'.gitlab-ci.yml'</span>,</span><br><span class="line">    <span class="string">'.gitattributes'</span>,</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在创建好的项目文件夹下搜索，除上述文件外，不包含其他文件就返回 true</span></span><br><span class="line">  <span class="keyword">const</span> conflicts = fs</span><br><span class="line">    .readdirSync(root)</span><br><span class="line">    .filter(<span class="function"><span class="params">file</span> =&gt;</span> !validFiles.includes(file));</span><br><span class="line">  <span class="keyword">if</span> (conflicts.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则依次打印冲突文件</span></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`The directory <span class="subst">$&#123;chalk.green(name)&#125;</span> contains files that could conflict:`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> conflicts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`  <span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log();</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">'Either try using a new directory name, or remove the files listed above.'</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上来说，这个函数就是判断创建的这个目录是否包含上述 <code>validFiles</code> 里面的文件</p><h3 id="shouldUseYarn"><a href="#shouldUseYarn" class="headerlink" title="shouldUseYarn()"></a>shouldUseYarn()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUseYarn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    execSync(<span class="string">'yarnpkg --version'</span>, &#123; <span class="attr">stdio</span>: <span class="string">'ignore'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>execSync</code> 是由 <code>node</code> 自身模块 <code>child_process</code> 引用而来，就是用来执行命令的</p><p>这几行代码也很好懂，就是判断是否安装了 <code>yarn</code>，如果没有安装 <code>yarn</code>，<code>shouldUseYarn</code> 也会返回 <code>false</code>，不管有没有指定 <code>--use-npm</code></p><ul><li><code>execSync</code> – 引用至 <code>child_process.execSync</code>，用于执行需要执行的子进程</li></ul><h3 id="checkThatNpmCanReadCwd"><a href="#checkThatNpmCanReadCwd" class="headerlink" title="checkThatNpmCanReadCwd"></a>checkThatNpmCanReadCwd</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkThatNpmCanReadCwd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cwd = process.cwd(); <span class="comment">// 取到当前的进程目录</span></span><br><span class="line">  <span class="keyword">let</span> childOutput = <span class="literal">null</span>; <span class="comment">// 定义一个变量来保存 npm 的信息</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Note: intentionally using spawn over exec since</span></span><br><span class="line">    <span class="comment">// the problem doesn't reproduce otherwise.</span></span><br><span class="line">    <span class="comment">// `npm config list` is the only reliable way I could find</span></span><br><span class="line">    <span class="comment">// to reproduce the wrong path. Just printing process.cwd()</span></span><br><span class="line">    <span class="comment">// in a Node process was not enough.</span></span><br><span class="line">    <span class="comment">// 相当于执行 npm config list，并将返回的信息组合成为一个字符串</span></span><br><span class="line">    childOutput = spawn.sync(<span class="string">'npm'</span>, [<span class="string">'config'</span>, <span class="string">'list'</span>]).output.join(<span class="string">''</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// Something went wrong spawning node.</span></span><br><span class="line">    <span class="comment">// Not great, but it means we can't do this check.</span></span><br><span class="line">    <span class="comment">// We might fail later on, but let's continue.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否是一个字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> childOutput !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将整个字符串以换行分隔</span></span><br><span class="line">  <span class="keyword">const</span> lines = childOutput.split(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="comment">// `npm config list` output includes the following line:</span></span><br><span class="line">  <span class="comment">// "; cwd = C:\path\to\current\dir" (unquoted)</span></span><br><span class="line">  <span class="comment">// I couldn't find an easier way to get it.</span></span><br><span class="line">  <span class="comment">// 定义一个我们需要的信息的前缀</span></span><br><span class="line">  <span class="keyword">const</span> prefix = <span class="string">'; cwd = '</span>;</span><br><span class="line">  <span class="comment">// 找整个 lines 里面有没有这个前缀的一行</span></span><br><span class="line">  <span class="keyword">const</span> line = lines.find(<span class="function"><span class="params">line</span> =&gt;</span> line.indexOf(prefix) === <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> line !== <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// Fail gracefully. They could remove it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取出后面的信息，即 npm 执行的目录（可以自己用 npm config list 试一试）</span></span><br><span class="line">  <span class="keyword">const</span> npmCWD = line.substring(prefix.length);</span><br><span class="line">  <span class="comment">// 判断当前目录和执行目录是否一致</span></span><br><span class="line">  <span class="keyword">if</span> (npmCWD === cwd) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不一致就打印如下信息</span></span><br><span class="line">  <span class="built_in">console</span>.error(</span><br><span class="line">    chalk.red(</span><br><span class="line">      <span class="string">`Could not start an npm process in the right directory.\n\n`</span> +</span><br><span class="line">        <span class="string">`The current directory is: <span class="subst">$&#123;chalk.bold(cwd)&#125;</span>\n`</span> +</span><br><span class="line">        <span class="string">`However, a newly started npm process runs in: <span class="subst">$&#123;chalk.bold(</span></span></span><br><span class="line"><span class="string"><span class="subst">          npmCWD</span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span>\n\n`</span> +</span><br><span class="line">        <span class="string">`This is probably caused by a misconfigured system terminal shell.`</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 给出了 win32 下通常会奏效的修复命令</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">'win32'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      chalk.red(<span class="string">`On Windows, this can usually be fixed by running:\n\n`</span>) +</span><br><span class="line">        <span class="string">`  <span class="subst">$&#123;chalk.cyan(</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="string">'reg'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span> delete "HKCU\\Software\\Microsoft\\Command Processor" /v AutoRun /f\n`</span> +</span><br><span class="line">        <span class="string">`  <span class="subst">$&#123;chalk.cyan(</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="string">'reg'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span> delete "HKLM\\Software\\Microsoft\\Command Processor" /v AutoRun /f\n\n`</span> +</span><br><span class="line">        chalk.red(<span class="string">`Try to run the above two lines in the terminal.\n`</span>) +</span><br><span class="line">        chalk.red(</span><br><span class="line">          <span class="string">`To learn more about this problem, read: https://blogs.msdn.microsoft.com/oldnewthing/20071121-00/?p=24433/`</span></span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分主要也就用了一个外部依赖，为了解决 <code>Node</code> 命令在各平台下的兼容性问题</p><ul><li><code>cross-spawn</code>：用来执行 node 进程（封装了跨平台兼容）</li></ul><h3 id="checkNpmVersion"><a href="#checkNpmVersion" class="headerlink" title="checkNpmVersion()"></a>checkNpmVersion()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNpmVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hasMinNpm = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> npmVersion = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    npmVersion = execSync(<span class="string">'npm --version'</span>)</span><br><span class="line">      .toString()</span><br><span class="line">      .trim();</span><br><span class="line">    hasMinNpm = semver.gte(npmVersion, <span class="string">'3.0.0'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// ignore</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hasMinNpm: hasMinNpm,</span><br><span class="line">    npmVersion: npmVersion,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分的代码基本一目了然，它返回的就是一个对象（<code>npm 版本号</code> 和 <code>是否由最小 npm 版本限制</code></p><p>分析完了 <code>createApp</code> 的所有函数和依赖，接着我们来分析后续执行的 <code>run</code> 函数</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p><code>run</code> 函数在 <code>createApp</code> 函数所有内容执行完毕后执行，它接收 7 个参数</p><ul><li><code>root</code>：创建的目录绝对路径</li><li><code>appName</code>：创建的目录名称</li><li><code>version</code>：<code>react-scripts</code> 的版本</li><li><code>verbose</code>：继续传递 <code>verbose</code></li><li><code>originalDirectory</code>：原始目录，即 <code>create-react-app</code> 在切换前的目录</li><li><code>template</code>：模版，不对外使用</li><li><code>useYarn</code>：是否使用 <code>yarn</code></li></ul><p>接下来看看 <code>run</code> 的源代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root,</span></span></span><br><span class="line"><span class="function"><span class="params">  appName,</span></span></span><br><span class="line"><span class="function"><span class="params">  version,</span></span></span><br><span class="line"><span class="function"><span class="params">  verbose,</span></span></span><br><span class="line"><span class="function"><span class="params">  originalDirectory,</span></span></span><br><span class="line"><span class="function"><span class="params">  template,</span></span></span><br><span class="line"><span class="function"><span class="params">  useYarn</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取依赖包信息（react-script）</span></span><br><span class="line">  <span class="keyword">const</span> packageToInstall = getInstallPackage(version, originalDirectory);</span><br><span class="line">  <span class="comment">// 定义所有依赖包信息</span></span><br><span class="line">  <span class="keyword">const</span> allDependencies = [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, packageToInstall];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 安装过程开始</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Installing packages. This might take a couple of minutes.'</span>);</span><br><span class="line">  getPackageName(packageToInstall)</span><br><span class="line">    .then(<span class="function"><span class="params">packageName</span> =&gt;</span></span><br><span class="line">      <span class="comment">// 是否离线模式，返回结果和包名</span></span><br><span class="line">      checkIfOnline(useYarn).then(<span class="function"><span class="params">isOnline</span> =&gt;</span> (&#123;</span><br><span class="line">        isOnline: isOnline,</span><br><span class="line">        packageName: packageName,</span><br><span class="line">      &#125;))</span><br><span class="line">    )</span><br><span class="line">    .then(<span class="function"><span class="params">info</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 接收上述的包名以及离线模式判断</span></span><br><span class="line">      <span class="keyword">const</span> isOnline = info.isOnline;</span><br><span class="line">      <span class="keyword">const</span> packageName = info.packageName;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Installing <span class="subst">$&#123;chalk.cyan(<span class="string">'react'</span>)&#125;</span>, <span class="subst">$&#123;chalk.cyan(</span></span></span><br><span class="line"><span class="string"><span class="subst">          <span class="string">'react-dom'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">        )&#125;</span>, and <span class="subst">$&#123;chalk.cyan(packageName)&#125;</span>...`</span></span><br><span class="line">      );</span><br><span class="line">      <span class="built_in">console</span>.log();</span><br><span class="line">      <span class="comment">// 安装依赖</span></span><br><span class="line">      <span class="keyword">return</span> install(root, useYarn, allDependencies, verbose, isOnline).then(</span><br><span class="line">        () =&gt; packageName</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">packageName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 检查当前 node 版本是否支持包</span></span><br><span class="line">      checkNodeVersion(packageName);</span><br><span class="line">      setCaretRangeForRuntimeDeps(packageName);</span><br><span class="line">      <span class="comment">// 找 init.js 的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> scriptsPath = path.resolve(</span><br><span class="line">        process.cwd(),</span><br><span class="line">        <span class="string">'node_modules'</span>,</span><br><span class="line">        packageName,</span><br><span class="line">        <span class="string">'scripts'</span>,</span><br><span class="line">        <span class="string">'init.js'</span></span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 引入 init.js</span></span><br><span class="line">      <span class="keyword">const</span> init = <span class="built_in">require</span>(scriptsPath);</span><br><span class="line">      <span class="comment">// 调用并执行目录拷贝</span></span><br><span class="line">      init(root, appName, verbose, originalDirectory, template);</span><br><span class="line">      <span class="comment">// react-script 0.9 报警告</span></span><br><span class="line">      <span class="keyword">if</span> (version === <span class="string">'react-scripts@0.9.x'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          chalk.yellow(</span><br><span class="line">            <span class="string">`\nNote: the project was boostrapped with an old unsupported version of tools.\n`</span> +</span><br><span class="line">              <span class="string">`Please update to Node &gt;=6 and npm &gt;=3 to get supported tools in new projects.\n`</span></span><br><span class="line">          )</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log();</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Aborting installation.'</span>);</span><br><span class="line">      <span class="comment">// 有具体信息则报具体信息</span></span><br><span class="line">      <span class="keyword">if</span> (reason.command) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`  <span class="subst">$&#123;chalk.cyan(reason.command)&#125;</span> has failed.`</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有就要求回报 bug</span></span><br><span class="line">        <span class="built_in">console</span>.log(chalk.red(<span class="string">'Unexpected error. Please report it as a bug:'</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log();</span><br><span class="line">      <span class="comment">// 出现异常时删除这些文件</span></span><br><span class="line">      <span class="comment">// On 'exit' we will delete these files from target directory.</span></span><br><span class="line">      <span class="keyword">const</span> knownGeneratedFiles = [</span><br><span class="line">        <span class="string">'package.json'</span>,</span><br><span class="line">        <span class="string">'npm-debug.log'</span>,</span><br><span class="line">        <span class="string">'yarn-error.log'</span>,</span><br><span class="line">        <span class="string">'yarn-debug.log'</span>,</span><br><span class="line">        <span class="string">'node_modules'</span>,</span><br><span class="line">      ];</span><br><span class="line">      <span class="keyword">const</span> currentFiles = fs.readdirSync(path.join(root));</span><br><span class="line">      <span class="comment">// 挨个删除</span></span><br><span class="line">      currentFiles.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">        knownGeneratedFiles.forEach(<span class="function"><span class="params">fileToMatch</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// This will catch `(npm-debug|yarn-error|yarn-debug).log*` files</span></span><br><span class="line">          <span class="comment">// and the rest of knownGeneratedFiles.</span></span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            (fileToMatch.match(<span class="regexp">/.log/g</span>) &amp;&amp; file.indexOf(fileToMatch) === <span class="number">0</span>) ||</span><br><span class="line">            file === fileToMatch</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Deleting generated file... <span class="subst">$&#123;chalk.cyan(file)&#125;</span>`</span>);</span><br><span class="line">            fs.removeSync(path.join(root, file));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 当前目录下是否还存在文件</span></span><br><span class="line">      <span class="keyword">const</span> remainingFiles = fs.readdirSync(path.join(root));</span><br><span class="line">      <span class="keyword">if</span> (!remainingFiles.length) &#123;</span><br><span class="line">        <span class="comment">// Delete target folder if empty</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`Deleting <span class="subst">$&#123;chalk.cyan(<span class="string">`<span class="subst">$&#123;appName&#125;</span> /`</span>)&#125;</span> from <span class="subst">$&#123;chalk.cyan(</span></span></span><br><span class="line"><span class="string"><span class="subst">            path.resolve(root, <span class="string">'..'</span>)</span></span></span><br><span class="line"><span class="string"><span class="subst">          )&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">        process.chdir(path.resolve(root, <span class="string">'..'</span>));</span><br><span class="line">        fs.removeSync(path.join(root));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Done.'</span>);</span><br><span class="line">      process.exit(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 这个函数中大量使用了 <code>Promise</code> 回调，这一部分的知识在之前的文章中也提到过。下面我们来拆解其中的每一句和每一个函数的作用</p><p>外部依赖都是和之前一样的，我们来看看内部调用了哪些函数</p><ul><li><code>getInstallPackage</code> – 获取要安装的 <code>react-script</code> 版本或者开发者自己定义的 <code>react-scripts</code></li><li><code>getPackageName</code> – 获取正式安装的 <code>react-scripts</code> 包名</li><li><code>checkIfOnline</code> – 检查网络连接是否正常</li><li><code>install</code> – 安装依赖包</li><li><code>checkNodeVersion</code> – 检查 <code>Node</code> 版本信息</li><li><code>setCaretRangeForRuntimeDeps</code> – 检查开发依赖是否正确安装，版本是否正确</li><li><code>init</code> – 将事先定义好的目录文件拷贝到我的项目中</li></ul><h3 id="getInstallPackage"><a href="#getInstallPackage" class="headerlink" title="getInstallPackage"></a>getInstallPackage</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstallPackage</span>(<span class="params">version, originalDirectory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> packageToInstall = <span class="string">'react-scripts'</span>; <span class="comment">// 默认 react-script 标准包名</span></span><br><span class="line">  <span class="keyword">const</span> validSemver = semver.valid(version); <span class="comment">// 校验版本号是否合法</span></span><br><span class="line">  <span class="keyword">if</span> (validSemver) &#123;</span><br><span class="line">    packageToInstall += <span class="string">`@<span class="subst">$&#123;validSemver&#125;</span>`</span>; <span class="comment">// 合法的话，就安装指定版本，在 npm install 安装的时候加上 ` @x.x.x` 版本号，安装指定版本的 react-scripts</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &amp;&amp; version.match(<span class="regexp">/^file:/</span>)) &#123;</span><br><span class="line">    <span class="comment">// 不合法且版本号带有 file:，执行以下代码，作用时安装我们自定义的包</span></span><br><span class="line">    packageToInstall = <span class="string">`file:<span class="subst">$&#123;path.resolve(</span></span></span><br><span class="line"><span class="string"><span class="subst">      originalDirectory,</span></span></span><br><span class="line"><span class="string"><span class="subst">      version.match(<span class="regexp">/^file:(.*)?$/</span>)[<span class="number">1</span>]</span></span></span><br><span class="line"><span class="string"><span class="subst">    )&#125;</span>`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version) &#123;</span><br><span class="line">    <span class="comment">// 以上条件都不满足就安装默认的文件</span></span><br><span class="line">    <span class="comment">// for tar.gz or alternative paths</span></span><br><span class="line">    packageToInstall = version;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终需要安装的 react-scripts 的信息</span></span><br><span class="line">  <span class="keyword">return</span> packageToInstall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数接收两个参数，<code>version</code> 和 <code>originalDictionary</code>，主要的作用根据参数是生成 <code>react-script</code> 的安装版本。一开始初始化的项目是可以指定 <code>react-script</code> 版本，甚至自定义这个包的，所以有了这几种校验机制</p><h3 id="getPackageName"><a href="#getPackageName" class="headerlink" title="getPackageName"></a>getPackageName</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Extract package name from tarball url or path.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageName</span>(<span class="params">installPackage</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据上面传回的安装版本来安装这个包，返回正规的包名</span></span><br><span class="line">  <span class="keyword">if</span> (installPackage.match(<span class="regexp">/^.+\.(tgz|tar\.gz)$/</span>)) &#123;</span><br><span class="line">    <span class="comment">// 创建了一个临时目录</span></span><br><span class="line">    <span class="keyword">return</span> getTemporaryDirectory()</span><br><span class="line">      .then(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> stream;</span><br><span class="line">        <span class="comment">// 线上安装情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/^http/</span>.test(installPackage)) &#123;</span><br><span class="line">          stream = hyperquest(installPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 本地读取情况</span></span><br><span class="line">          stream = fs.createReadStream(installPackage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 Node 的流处理返回</span></span><br><span class="line">        <span class="keyword">return</span> extractStream(stream, obj.tmpdir).then(<span class="function"><span class="params">()</span> =&gt;</span> obj);</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这段没太看懂……</span></span><br><span class="line">        <span class="keyword">const</span> packageName = <span class="built_in">require</span>(path.join(obj.tmpdir, <span class="string">'package.json'</span>)).name;</span><br><span class="line">        obj.cleanup();</span><br><span class="line">        <span class="keyword">return</span> packageName;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// The package name could be with or without semver version, e.g. react-scripts-0.2.0-alpha.1.tgz</span></span><br><span class="line">        <span class="comment">// However, this function returns package name only without semver version.</span></span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`Could not extract the package name from the archive: <span class="subst">$&#123;err.message&#125;</span>`</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">const</span> assumedProjectName = installPackage.match(</span><br><span class="line">          /^.+\/(.+?)(?:-\d+.+)?\.(tgz|tar\.gz)$/</span><br><span class="line">        )[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`Based on the filename, assuming it is "<span class="subst">$&#123;chalk.cyan(</span></span></span><br><span class="line"><span class="string"><span class="subst">            assumedProjectName</span></span></span><br><span class="line"><span class="string"><span class="subst">          )&#125;</span>"`</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(assumedProjectName);</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="comment">// 信息中包含 git+ 的情况</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installPackage.indexOf(<span class="string">'git+'</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Pull package name out of git urls e.g:</span></span><br><span class="line">    <span class="comment">// git+https://github.com/mycompany/react-scripts.git</span></span><br><span class="line">    <span class="comment">// git+ssh://github.com/mycompany/react-scripts.git#v1.2.3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(installPackage.match(<span class="regexp">/([^/]+)\.git(#.*)?$/</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// 只包含版本信息时的情况</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installPackage.match(<span class="regexp">/.+@/</span>)) &#123;</span><br><span class="line">    <span class="comment">// Do not match @scope/ when stripping off @version or @tag</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">      installPackage.charAt(<span class="number">0</span>) + installPackage.substr(<span class="number">1</span>).split(<span class="string">'@'</span>)[<span class="number">0</span>]</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">// 包含 file: 开头的情况    </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (installPackage.match(<span class="regexp">/^file:/</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> installPackagePath = installPackage.match(<span class="regexp">/^file:(.*)?$/</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> installPackageJson = <span class="built_in">require</span>(path.join(installPackagePath, <span class="string">'package.json'</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(installPackageJson.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 什么都没有直接返回包名</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(installPackage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数的目标就是返回一个正常的依赖包名，比如我们什么都不带就返回 <code>react-scripts</code>，是我们自定义的包就返回 <code>my-react-scripts</code>，接下来就采用 <code>Promise</code> 回调的方式一直执行到最后</p><p>先来看它的外部依赖：</p><ul><li><code>hyperquest</code>：用于生成流式 <code>http</code> 请求</li></ul><p>它还调用了两个函数依赖，这两个函数比较简单，所以不做详细解读：</p><ul><li><code>getTemporaryDirectory</code>：本身是一个回调函数，用来创建一个临时目录</li><li><code>extractStream</code>：利用流式传输下载数据，<code>Stream</code> 本身是为了减少内存开销，优化用户体验</li></ul><h3 id="checkIfOnline"><a href="#checkIfOnline" class="headerlink" title="checkIfOnline"></a>checkIfOnline</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkIfOnline</span>(<span class="params">useYarn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!useYarn) &#123;</span><br><span class="line">    <span class="comment">// Don't ping the Yarn registry.</span></span><br><span class="line">    <span class="comment">// We'll just assume the best case.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    dns.lookup(<span class="string">'registry.yarnpkg.com'</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> proxy;</span><br><span class="line">      <span class="comment">// 自定代理</span></span><br><span class="line">      <span class="keyword">if</span> (err != <span class="literal">null</span> &amp;&amp; (proxy = getProxy())) &#123;</span><br><span class="line">        <span class="comment">// If a proxy is defined, we likely can't resolve external hostnames.</span></span><br><span class="line">        <span class="comment">// Try to resolve the proxy name as an indication of a connection.</span></span><br><span class="line">        dns.lookup(url.parse(proxy).hostname, proxyErr =&gt; &#123;</span><br><span class="line">          resolve(proxyErr == <span class="literal">null</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">// 否则直接返回空错误信息</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(err == <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身接收一个是否使用 <code>yarn</code> 的参数来判断是否进行后续，如果使用的是 <code>npm</code> 直接返回 true，这个函数本身是为了调用 <code>yarn</code> 本身的离线安装功能</p><p>外部依赖：</p><ul><li><code>dns</code>：用来检测是否能够请求到指定的地址</li></ul><h3 id="install"><a href="#install" class="headerlink" title="install()"></a>install()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">root, useYarn, dependencies, verbose, isOnline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> command; <span class="comment">// 定义命令</span></span><br><span class="line">    <span class="keyword">let</span> args; <span class="comment">// 定义命令参数</span></span><br><span class="line">    <span class="comment">// 如果使用 yarn</span></span><br><span class="line">    <span class="keyword">if</span> (useYarn) &#123;</span><br><span class="line">      command = <span class="string">'yarnpkg'</span>; <span class="comment">// 命令名称</span></span><br><span class="line">      args = [<span class="string">'add'</span>, <span class="string">'--exact'</span>]; <span class="comment">// 基础命令参数</span></span><br><span class="line">      <span class="keyword">if</span> (!isOnline) &#123;</span><br><span class="line">        args.push(<span class="string">'--offline'</span>); <span class="comment">// 在命令参数上接一个函数，判断是否加入离线模式</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 组合参数 + 开发依赖 ‘react’ ’react-dom‘ ’react-scripts‘</span></span><br><span class="line">      [].push.apply(args, dependencies);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Explicitly set cwd() to work around issues like</span></span><br><span class="line">      <span class="comment">// https://github.com/facebookincubator/create-react-app/issues/3326.</span></span><br><span class="line">      <span class="comment">// Unfortunately we can only do this for Yarn because npm support for</span></span><br><span class="line">      <span class="comment">// equivalent --prefix flag doesn't help with this issue.</span></span><br><span class="line">      <span class="comment">// This is why for npm, we run checkThatNpmCanReadCwd() early instead.</span></span><br><span class="line">      args.push(<span class="string">'--cwd'</span>); <span class="comment">// 指定命令执行目录的地址</span></span><br><span class="line">      args.push(root); <span class="comment">// 执行目录绝对路径</span></span><br><span class="line">      <span class="comment">// 离线模式会给出警告，提示正在调用 yarn 本地缓存安装</span></span><br><span class="line">      <span class="keyword">if</span> (!isOnline) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'You appear to be offline.'</span>));</span><br><span class="line">        <span class="built_in">console</span>.log(chalk.yellow(<span class="string">'Falling back to the local Yarn cache.'</span>));</span><br><span class="line">        <span class="built_in">console</span>.log();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 否则就拼一套 npm 的命令</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      command = <span class="string">'npm'</span>;</span><br><span class="line">      args = [</span><br><span class="line">        <span class="string">'install'</span>,</span><br><span class="line">        <span class="string">'--save'</span>,</span><br><span class="line">        <span class="string">'--save-exact'</span>,</span><br><span class="line">        <span class="string">'--loglevel'</span>,</span><br><span class="line">        <span class="string">'error'</span>,</span><br><span class="line">      ].concat(dependencies);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为 yarn 和 npm 都可以带这个参数，所以单独拿了出来</span></span><br><span class="line">    <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">      args.push(<span class="string">'--verbose'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 组合命令并执行</span></span><br><span class="line">    <span class="keyword">const</span> child = spawn(command, args, &#123; <span class="attr">stdio</span>: <span class="string">'inherit'</span> &#125;);</span><br><span class="line">    <span class="comment">// 执行完毕后关闭</span></span><br><span class="line">    child.on(<span class="string">'close'</span>, code =&gt; &#123;</span><br><span class="line">      <span class="comment">// 不为 0 即非正常关闭，</span></span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 抛出错误</span></span><br><span class="line">        reject(&#123;</span><br><span class="line">          command: <span class="string">`<span class="subst">$&#123;command&#125;</span> <span class="subst">$&#123;args.join(<span class="string">' '</span>)&#125;</span>`</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 正常则继续往下执行</span></span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的作用就是组合一个 <code>yarn</code> 或者 <code>npm</code> 的安装命令，把这些模块装到项目的文件夹中</p><p>执行到这个流程，<code>create-react-app</code> 已经帮我们创建好了项目，<code>package.json</code> 安装了所有的依赖，<code>react</code>、<code>react-dom</code>、<code>react-scripts</code></p><h3 id="checkNodeVersion"><a href="#checkNodeVersion" class="headerlink" title="checkNodeVersion()"></a>checkNodeVersion()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNodeVersion</span>(<span class="params">packageName</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 找 react-scripts 的 package.json 路径</span></span><br><span class="line">  <span class="keyword">const</span> packageJsonPath = path.resolve(</span><br><span class="line">    process.cwd(),</span><br><span class="line">    <span class="string">'node_modules'</span>,</span><br><span class="line">    packageName,</span><br><span class="line">    <span class="string">'package.json'</span></span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// 在 package.json 中定义了一个 engines 其中放着 Node 版本的信息</span></span><br><span class="line">  <span class="keyword">const</span> packageJson = <span class="built_in">require</span>(packageJsonPath);</span><br><span class="line">  <span class="comment">// 在 package.json 中定义了一个 engines，其中放着 Node 版本的信息</span></span><br><span class="line">  <span class="keyword">if</span> (!packageJson.engines || !packageJson.engines.node) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较进程的 Node 版本信息，是否小于最小支持的版本</span></span><br><span class="line">  <span class="keyword">if</span> (!semver.satisfies(process.version, packageJson.engines.node)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(</span><br><span class="line">      chalk.red(</span><br><span class="line">        <span class="string">'You are running Node %s.\n'</span> +</span><br><span class="line">          <span class="string">'Create React App requires Node %s or higher. \n'</span> +</span><br><span class="line">          <span class="string">'Please update your version of Node.'</span></span><br><span class="line">      ),</span><br><span class="line">      process.version,</span><br><span class="line">      packageJson.engines.node</span><br><span class="line">    );</span><br><span class="line">    process.exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是检查 <code>Node</code> 版本，<code>react-scripts</code> 需要依赖 <code>Node</code> 版本，也就是说低版本的 <code>Node</code> 不支持</p><h3 id="setCaretRangeForRuntimeDeps"><a href="#setCaretRangeForRuntimeDeps" class="headerlink" title="setCaretRangeForRuntimeDeps"></a>setCaretRangeForRuntimeDeps</h3><h2 id="babel-preset-react-app"><a href="#babel-preset-react-app" class="headerlink" title="babel-preset-react-app"></a>babel-preset-react-app</h2><p>查询它的 <code>package.json</code> 可以发现，<code>babel-preset-react-app</code> 这个子模块是为了在输入指令不同时向整个项目加入不同的 <code>webpack</code> 配置</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;create-react-app 是我们最经常使用的脚手架工具，它的功能如何被实现？&lt;/center&gt;
    
    </summary>
    
      <category term="React 源码分析" scheme="https://www.douglasdong.site/categories/React-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="React" scheme="https://www.douglasdong.site/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（7）- Breadcrumb 组件</title>
    <link href="https://www.douglasdong.site/2018-10-08.html"/>
    <id>https://www.douglasdong.site/2018-10-08.html</id>
    <published>2018-10-08T03:46:14.000Z</published>
    <updated>2018-10-13T01:17:46.328Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Breadcrumb"><a href="#Breadcrumb" class="headerlink" title="Breadcrumb"></a>Breadcrumb</h1><p><code>AntD</code> 中的 <code>Breadcrumb</code> 组件用于显示当前页面在系统层级结构中的位置，其中对于路由的支持采用了 <code>react-router@3</code> 和 <code>react-router@4</code></p><h1 id="Breadcrumb-Props"><a href="#Breadcrumb-Props" class="headerlink" title="Breadcrumb Props"></a>Breadcrumb Props</h1><p>和之前一样，我们先从组件传入参数入手</p><table><thead><tr><th><div>参数</div></th><th><div>说明</div></th><th><div>类型</div></th><th><div>可选值</div></th><th><div>默认值</div></th></tr></thead><tbody><tr><td><div>itemRender</div></td><td><div>自定义链接函数，和 react-router 配置使用</div></td><td><div>(route, params, routes, paths) =&gt; ReactNode</div></td><td></td><td>-</td></tr><tr><td><div>params<span class="Apple-tab-span" style="white-space:pre"></span></div></td><td><div>路由的参数</div></td><td><div>object</div></td><td></td><td>-</td></tr><tr><td><div>routes</div></td><td><div>router 的路由栈信息</div></td><td><div>object[]</div></td><td></td><td>-</td></tr><tr><td>separator</td><td>分隔符自定义</td><td>string / ReactNode</td><td></td><td><span class="Apple-tab-span" style="white-space:pre">‘/‘</span></td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Route &#123;</span><br><span class="line">  <span class="comment">// 路由路径</span></span><br><span class="line">  path: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 面包屑名称</span></span><br><span class="line">  breadcrumbName: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BreadcrumbProps &#123;</span><br><span class="line">  <span class="comment">// 样式类前缀</span></span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 路由数组集合，采用的是上面的 Route 形式</span></span><br><span class="line">  routes?: Route[];</span><br><span class="line">  <span class="comment">// 路由传入参数</span></span><br><span class="line">  params?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 每个 item 之间的分隔符</span></span><br><span class="line">  separator?: React.ReactNode;</span><br><span class="line">  <span class="comment">// 自定义链接函数</span></span><br><span class="line">  itemRender?: <span class="function">(<span class="params">route: <span class="built_in">any</span>, params: <span class="built_in">any</span>, routes: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;, paths: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) =&gt;</span> React.ReactNode;</span><br><span class="line">  <span class="comment">// 行内样式</span></span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Render"><a href="#Render" class="headerlink" title="Render()"></a>Render()</h1><p>这个组件的入口点依旧是 <code>Render()</code> 函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">let</span> crumbs;</span><br><span class="line">    <span class="comment">//  取出参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      separator, prefixCls, style, className, routes, params = &#123;&#125;,</span><br><span class="line">      children, itemRender = defaultItemRender,</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// 如果 routes 这个参数存在，就需要利用 routes 来构造 item</span></span><br><span class="line">    <span class="keyword">if</span> (routes &amp;&amp; routes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 定义一个数组为空</span></span><br><span class="line">      <span class="keyword">const</span> paths: string[] = [];</span><br><span class="line">      <span class="comment">// 遍历传入的 routes</span></span><br><span class="line">      <span class="comment">// react-router@4 以下的时候，react-router 会给传入组件传递一些参数回来</span></span><br><span class="line">      <span class="comment">// react-router@4 时就需要自己构造这些参数，主要使用了 routes，params，childen</span></span><br><span class="line">      crumbs = routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        route.path = route.path || <span class="string">''</span>;</span><br><span class="line">        <span class="comment">// 将单个 item 路径按照 ‘/’ 分割成对应数组</span></span><br><span class="line">        <span class="keyword">let</span> path: string = route.path.replace(<span class="regexp">/^\//</span>, <span class="string">''</span>);</span><br><span class="line">        <span class="built_in">Object</span>.keys(params).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 将单个 item 的 path 中的对应参数换成传入参数对应的值</span></span><br><span class="line">          path = path.replace(<span class="string">`:<span class="subst">$&#123;key&#125;</span>`</span>, params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (path) &#123;</span><br><span class="line">          <span class="comment">// antd 官网的实例中，传入的 routes 数组的顺序是依次包含的关系</span></span><br><span class="line">          <span class="comment">// 也就是第一个 route 是第一层路由，剩下的依次包含层级，仅限 react-router@3</span></span><br><span class="line">          paths.push(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="comment">// 传入 itemrender 函数进行 items 的渲染</span></span><br><span class="line">          &lt;BreadcrumbItem separator=&#123;separator&#125; key=&#123;route.breadcrumbName || path&#125;&gt;</span><br><span class="line">            &#123;itemRender(route, params, routes, paths)&#125;</span><br><span class="line">          &lt;<span class="regexp">/BreadcrumbItem&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">      &#125;);</span></span><br><span class="line"><span class="regexp">    &#125; else if (children) &#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 如果存在孩子节点的时候就渲染孩子节点，使用的方法依旧是 React.Children.map+React.cloneElement()</span></span><br><span class="line"><span class="regexp">      </span></span><br><span class="line"><span class="regexp">      crumbs = React.Children.map(children, (element: any, index) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        if (!element) &#123;</span></span><br><span class="line"><span class="regexp">          return element;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ antd 根据 https:/</span><span class="regexp">/www.npmjs.cm/</span>package/warning</span><br><span class="line">        <span class="comment">// 封装了一个浏览器 console 框打印警告的工具函数</span></span><br><span class="line">        warning(</span><br><span class="line">          element.type &amp;&amp; element.type.__ANT_BREADCRUMB_ITEM,</span><br><span class="line">          <span class="string">'Breadcrumb only accepts Breadcrumb.Item as it\'s children'</span>,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> cloneElement(element, &#123;</span><br><span class="line">          separator,</span><br><span class="line">          key: index,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;classNames(className, prefixCls)&#125; style=&#123;style&#125;&gt;</span><br><span class="line">        &#123;crumbs&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="使用-react-router-3-需要的函数"><a href="#使用-react-router-3-需要的函数" class="headerlink" title="使用 react-router@3 需要的函数"></a>使用 react-router@3 需要的函数</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前路由上的名字</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBreadcrumbName</span>(<span class="params">route: Route, params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!route.breadcrumbName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将所有参数使用 ‘|’ 分割成字符串，用于下面的正则匹配</span></span><br><span class="line">  <span class="keyword">const</span> paramsKeys = <span class="built_in">Object</span>.keys(params).join(<span class="string">'|'</span>);</span><br><span class="line">  <span class="comment">// js 的 replace 第一个参数可以是一个字符串或者是一个正则匹配，</span></span><br><span class="line">  <span class="comment">// 第二个参数可以是一个字符串或者是一个函数返回替换的字符串</span></span><br><span class="line">  <span class="keyword">const</span> name = route.breadcrumbName.replace(</span><br><span class="line">    <span class="comment">// 正则匹配参数，例如 breadcrumbName = ‘Application:id|name'</span></span><br><span class="line">    <span class="comment">// 这里的匹配正则串是 ':id|name'</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`:(<span class="subst">$&#123;paramsKeys&#125;</span>)`</span>, <span class="string">'g'</span>),</span><br><span class="line">    <span class="comment">// 如果参数重有这个值就用这个值，没有就返回</span></span><br><span class="line">    (replacement, key) =&gt; params[key] || replacement,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染 item</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultItemRender</span>(<span class="params">route: Route, params: <span class="built_in">any</span>, routes: Route[], paths: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是最后一个 item 就不添加连接</span></span><br><span class="line">  <span class="keyword">const</span> isLastItem = routes.indexOf(route) === routes.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> name = getBreadcrumbName(route, params);</span><br><span class="line">  <span class="keyword">return</span> isLastItem</span><br><span class="line">    ? &lt;span&gt;&#123;name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    : &lt;a href=&#123;`#/</span>$&#123;paths.join(<span class="string">'/'</span>)&#125;<span class="string">`&#125;&gt;&#123;name&#125;&lt;/a&gt;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="BreadcrumbItem"><a href="#BreadcrumbItem" class="headerlink" title="BreadcrumbItem"></a>BreadcrumbItem</h1><p>单独的一个用来编写 <code>Breadcrumbs</code> 的 <code>items</code> 组件</p><h2 id="BreadcrumbItemProps"><a href="#BreadcrumbItemProps" class="headerlink" title="BreadcrumbItemProps"></a>BreadcrumbItemProps</h2><p>同样先从参数开始了解<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> BreadcrumbItemProps &#123;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>; <span class="comment">// 样式类的命名空间前缀</span></span><br><span class="line">  separator?: React.ReactNode; <span class="comment">// item 的分隔符</span></span><br><span class="line">  href?: <span class="built_in">string</span>; <span class="comment">// 连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Render-1"><a href="#Render-1" class="headerlink" title="Render()"></a>Render()</h2><p><code>render</code> 函数比较简单</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; prefixCls, separator, children, ...restProps &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">let</span> link;</span><br><span class="line">  <span class="comment">// 如果有 href 这个 props，就使用 a 标签</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'href'</span> <span class="keyword">in</span> <span class="keyword">this</span>.props) &#123;</span><br><span class="line">    link = &lt;a className=&#123;<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-link`</span>&#125; &#123;...restProps&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp">  &#125; else &#123;</span></span><br><span class="line"><span class="regexp">    link = &lt;span className=&#123;`$&#123;prefixCls&#125;-link`&#125; &#123;...restProps&#125;&gt;&#123;children&#125;&lt;/</span>span&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;span&gt;</span><br><span class="line">        &#123;link&#125;</span><br><span class="line">        &lt;span className=&#123;<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-separator`</span>&#125;&gt;&#123;separator&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>span&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件的身份证明"><a href="#组件的身份证明" class="headerlink" title="组件的身份证明"></a>组件的身份证明</h2><p>这个组件中有一个东西代表了他的身份</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> BreadcrumbItem <span class="keyword">extends</span> React.Component&lt;BreadcrumbItemProps, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> __ANT_BREADCRUMB_ITEM = <span class="literal">true</span>; <span class="comment">// 身份证明，代表他是一个antbreadcrumb的子元素</span></span><br></pre></td></tr></table></figure><p>接下来看看它是如何使用的，在上面的 <code>Breadcrumb</code> 的 <code>render</code> 代码中有一段代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">crumbs = React.Children.map(children, <span class="function">(<span class="params">element: <span class="built_in">any</span>, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!element) &#123;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br><span class="line">  warning(</span><br><span class="line">    <span class="comment">// 这里的 element.type 在 react 的官网上有解释</span></span><br><span class="line">    <span class="comment">// React.cloneElement() is almost equivalent to:</span></span><br><span class="line">    <span class="comment">// &lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt;</span></span><br><span class="line">    <span class="comment">// the type argument can be either a tag name string (such as 'div' or 'span'), </span></span><br><span class="line">    <span class="comment">// or a React component type (a class or a function).</span></span><br><span class="line">    <span class="comment">// 以后我们也可以这样标示自己制作的组件</span></span><br><span class="line">    element.type &amp;&amp; element.type.__ANT_BREADCRUMB_ITEM,</span><br><span class="line">    <span class="string">'Breadcrumb only accepts Breadcrumb.Item as it\'s children'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> cloneElement(element, &#123;</span><br><span class="line">    separator,</span><br><span class="line">    key: index,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Breadcrumb 是 AntD 用于显示页面系统层级结构的组件，它的实现功能有哪些值得我们学习的地方？&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（6）- Affix 组件</title>
    <link href="https://www.douglasdong.site/2018-10-05-1.html"/>
    <id>https://www.douglasdong.site/2018-10-05-1.html</id>
    <published>2018-10-05T14:33:35.000Z</published>
    <updated>2018-10-08T03:29:37.458Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Affix-组件"><a href="#Affix-组件" class="headerlink" title="Affix 组件"></a>Affix 组件</h1><p>这是一个使用 <code>fix</code> 布局的组件，其目的是为了将页面元素钉在可视范围。</p><h1 id="Affix-Props"><a href="#Affix-Props" class="headerlink" title="Affix Props"></a>Affix Props</h1><p>还是一样，首先让我们来看看组件的参数文档，以及代码中传入的实际参数</p><p>参数文档：</p><table><thead><tr><th><div>成员</div></th><th><div>说明</div></th><th><div>类型</div></th><th><div>默认值</div></th></tr></thead><tbody><tr><td><div>offsetBottom</div></td><td><div>距离窗口底部达到指定偏移量后触发</div></td><td><div>number</div></td><td></td></tr><tr><td><div>offsetTop</div></td><td><div>距离窗口顶部达到指定偏移量后触发<span class="Apple-tab span" style="white-space:pre"></span></div></td><td><div>number</div></td><td></td></tr><tr><td><div>target</div></td><td><div>设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数</div></td><td><div>() =&gt; HTMLElement</div></td><td><div>() =&gt; window</div></td></tr><tr><td>onChange</td><td>固定状态改变时触发的回调函数<span class="Apple-tab-span" style="white-space:pre"></span></td><td>Function(affixed)</td><td>无</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AffixProps &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 距离窗口顶部达到指定偏移量后触发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  offsetTop?: <span class="built_in">number</span>;</span><br><span class="line">  offset?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 距离窗口底部达到指定偏移量后触发 */</span></span><br><span class="line">  offsetBottom?: <span class="built_in">number</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">/** 固定状态改变时触发的回调函数 */</span></span><br><span class="line">  onChange?: <span class="function">(<span class="params">affixed?: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */</span></span><br><span class="line">  target?: <span class="function"><span class="params">()</span> =&gt;</span> Window | HTMLElement | <span class="literal">null</span>;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分也同样需要注意一下，这里设置的 <code>affixStyle</code> 和 <code>placeholderStyle</code> 状态直接起到组件的固定作用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AffixState &#123;</span><br><span class="line">  <span class="comment">// 要求传入值必须为 CSS（后续会在组件生命周期中生成）</span></span><br><span class="line">  affixStyle: React.CSSProperties | <span class="literal">undefined</span>;</span><br><span class="line">  placeholderStyle: React.CSSProperties | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h1><p>看完了组件传入的参数，我们再来看看它的 <code>Render</code> 函数是如何实现的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> className = classNames(&#123;</span><br><span class="line">    [<span class="keyword">this</span>.props.prefixCls || <span class="string">'ant-affix'</span>]: <span class="keyword">this</span>.state.affixStyle,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 清除不需要的值（这里并没有看到任何 offset 符合 HTML 规范的记录，难道是忘记去除了？）</span></span><br><span class="line">  <span class="keyword">const</span> props = omit(<span class="keyword">this</span>.props, [<span class="string">'prefixCls'</span>, <span class="string">'offsetTop'</span>, <span class="string">'offsetBottom'</span>, <span class="string">'target'</span>, <span class="string">'onChange'</span>]);</span><br><span class="line">  <span class="comment">// 整合固定图钉的 placeholder 样式，和自己设定的自定义样式</span></span><br><span class="line">  <span class="comment">// 这里的 placeholder 样式负责让 Affix 组件下的 DOM 元素脱离文档流</span></span><br><span class="line">  <span class="keyword">const</span> placeholderStyle = &#123; ...this.state.placeholderStyle, ...this.props.style &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div &#123;...props&#125; style=&#123;placeholderStyle&#125;&gt;</span><br><span class="line">      <span class="comment">// 这一部分，组件脱离文档流后，放了一个占位元素，以防止脱离文档流操作影响原来 DOM 的结构，宽高等</span></span><br><span class="line">      &lt;div className=&#123;className&#125; ref=&#123;<span class="keyword">this</span>.saveFixedNode&#125; style=&#123;<span class="keyword">this</span>.state.affixStyle&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是最重要的部分，<code>render</code> 函数中可以看到，控制当前组件的主要因素是两层 <code>div</code> 上的 <code>style</code> 属性，即其中的 <code>placceholderStyle</code> 和 <code>affixStyle</code>，也就是我们之前看到的组件状态。那么接下来我们就看看这两个style是如果构造的</p><h1 id="从生命周期开始"><a href="#从生命周期开始" class="headerlink" title="从生命周期开始"></a>从生命周期开始</h1><p>这个组件有很多代码用于处理状态，逐条分析很容易凌乱。因此我们可以从这个组件的生命周期着手，分析整个组件的运行模式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单讲讲这三个生命周期函数都在干什么吧</span></span><br><span class="line"><span class="comment">// componentDidMount =&gt; 这个方法会在组件加载完毕之后立即执行。在这个时候之后组件已经生成了对应的DOM结构，可以通过 this.getDOMNode() 来进行访问。</span></span><br><span class="line"><span class="comment">// 这个组件中，我们在 DidMount 中设置了一个监听器，用于监听目标元素（默认为 window）</span></span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">this</span>.props.target || getDefaultTarget;</span><br><span class="line">  <span class="comment">// Wait for parent component ref has its value</span></span><br><span class="line">  <span class="keyword">this</span>.timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setTargetEventListeners(target);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在组件接收到一个新的prop时被执行。这个方法在初始化 render 时不会被调用，旧的 props 可以通过 this.props 来获取</span></span><br><span class="line"><span class="comment">// 当传入 target 时（和默认目标 window 不一样），重设监听器，更新当前组件的位置</span></span><br><span class="line">componentWillReceiveProps(nextProps: AffixProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.props.target !== nextProps.target) &#123;</span><br><span class="line">    <span class="keyword">this</span>.clearEventListeners();</span><br><span class="line">    <span class="keyword">this</span>.setTargetEventListeners(nextProps.target!);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mock Event object.</span></span><br><span class="line">    <span class="keyword">this</span>.updatePosition(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写组件的时候要是有事件监听器，一定要记得删除，否则会引发不必要的报错</span></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.clearEventListeners();</span><br><span class="line">  clearTimeout(<span class="keyword">this</span>.timeout);</span><br><span class="line">  (<span class="keyword">this</span>.updatePosition <span class="keyword">as</span> <span class="built_in">any</span>).cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来看看整个生命周期中所调用的函数具体实现：</p><figure class="highlight typescript"><figcaption><span>getDefaultTarget</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过查阅 Gitlog，发现这一部分是为了完善组件的限定类型，保证 window 类型不为 undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> ?</span><br><span class="line">    <span class="built_in">window</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>setTargetEventListeners</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定自定义目标监听器</span></span><br><span class="line"><span class="comment">// 首先定义一个传入函数，默认值类型由用户自定 =&gt; Window =&gt; null</span></span><br><span class="line">setTargetEventListeners(getTarget: <span class="function"><span class="params">()</span> =&gt;</span> HTMLElement | Window | <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> target = getTarget();</span><br><span class="line"><span class="comment">// 没有值传入就不定义 target</span></span><br><span class="line"><span class="keyword">if</span> (!target) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先清空监听器</span></span><br><span class="line"><span class="keyword">this</span>.clearEventListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环给当前元素绑定每一个事件类型</span></span><br><span class="line"><span class="comment">// events =['resize','scroll','touchstart','touchmove','touchend','pageshow','load']</span></span><br><span class="line"><span class="keyword">this</span>.events.forEach(<span class="function"><span class="params">eventName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.eventHandlers[eventName] = addEventListener(target, eventName, <span class="keyword">this</span>.updatePosition);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>getTargetRect</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getBoundingClientRect：返回值是一个 DOMRect 对象，包含了一组用于描述边框的只读属性——left、top、right 和 bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetRect</span>(<span class="params">target: HTMLElement | Window | <span class="literal">null</span></span>): <span class="title">ClientRect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> target !== <span class="built_in">window</span> ?</span><br><span class="line">    (target <span class="keyword">as</span> HTMLElement).getBoundingClientRect() :</span><br><span class="line">    &#123; top: <span class="number">0</span>, left: <span class="number">0</span>, bottom: <span class="number">0</span> &#125; <span class="keyword">as</span> ClientRect; <span class="comment">// 这一部分不太理解？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>getOffset</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOffset</span>(<span class="params">element: HTMLElement, target</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的getBoundingClientRect()是一个很有用的函数，获取页面元素位置</span></span><br><span class="line">  <span class="comment">// document.body.getBoundingClientRect()</span></span><br><span class="line">  <span class="comment">// DOMRect &#123;x: 0, y: -675, width: 1280, height: 8704, top: -675, …&#125;</span></span><br><span class="line">  <span class="keyword">const</span> elemRect = element.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">const</span> targetRect = getTargetRect(target);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pageXOffset 和 pageYOffset 属性返回文档在窗口左上角水平和垂直方向滚动的像素。</span></span><br><span class="line">  <span class="keyword">const</span> scrollTop = getScroll(target, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> scrollLeft = getScroll(target, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> docElem = <span class="built_in">window</span>.document.body;</span><br><span class="line">  <span class="comment">// 一个元素顶部边框的宽度（以像素表示）。不包括顶部外边距或内边距</span></span><br><span class="line">  <span class="keyword">const</span> clientTop = docElem.clientTop || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> clientLeft = docElem.clientLeft || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: elemRect.top - targetRect.top + scrollTop - clientTop,</span><br><span class="line">    left: elemRect.left - targetRect.left + scrollLeft - clientLeft,</span><br><span class="line">    width: elemRect.width,</span><br><span class="line">    height: elemRect.height,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是本篇的重头戏，<code>updatePosition</code> 函数</p><p>这个函数在开头有一个装饰器，对装饰器不了解的同学可以看这篇文章<a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">ECMAScript 6 入门 - 修饰器</a></p><figure class="highlight typescript"><figcaption><span>updatePosition</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@throttleByAnimationFrameDecorator</span>()</span><br><span class="line">updatePosition(e: <span class="built_in">any</span>) &#123;</span><br><span class="line">  <span class="comment">// 从 props 中获取参数，target 用 getDefaultTarget 设为默认值</span></span><br><span class="line">  <span class="keyword">let</span> &#123; offsetTop, offsetBottom, offset, target = getDefaultTarget &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> targetNode = target();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Backwards support</span></span><br><span class="line">  <span class="comment">// 为了向后兼容而设置的 offset</span></span><br><span class="line">  offsetTop = offsetTop || offset;</span><br><span class="line">  <span class="comment">// 获取到当前固定节点容器的滚动的距离</span></span><br><span class="line">  <span class="comment">// getScroll 函数的第一参数是获取滚动事件的 DOM 节点</span></span><br><span class="line">  <span class="comment">// 第二个参数判定 x 轴还是 y 轴上的滚动， y 轴上的为 true</span></span><br><span class="line">  <span class="keyword">const</span> scrollTop = getScroll(targetNode, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 找到当前组件的 DOM 节点</span></span><br><span class="line">  <span class="keyword">const</span> affixNode = ReactDOM.findDOMNode(<span class="keyword">this</span>) <span class="keyword">as</span> HTMLElement;</span><br><span class="line">  <span class="comment">// 获取当前组件 DOM 节点和当前固定节点的一个相对位置</span></span><br><span class="line">  <span class="keyword">const</span> elemOffset = getOffset(affixNode, targetNode);</span><br><span class="line">  <span class="comment">// 将当前的节点的宽高设置暂存，等会需要赋值给 placeholder 的样式</span></span><br><span class="line">  <span class="keyword">const</span> elemSize = &#123;</span><br><span class="line">    width: <span class="keyword">this</span>.fixedNode.offsetWidth,</span><br><span class="line">    height: <span class="keyword">this</span>.fixedNode.offsetHeight,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 定义一个固定模式</span></span><br><span class="line">  <span class="keyword">const</span> offsetMode = &#123;</span><br><span class="line">    top: <span class="literal">false</span>,</span><br><span class="line">    bottom: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// Default to `offsetTop=0`.</span></span><br><span class="line">  <span class="comment">// 判断固定在顶部还是底部</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> offsetTop !== <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> offsetBottom !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    offsetMode.top = <span class="literal">true</span>;</span><br><span class="line">    offsetTop = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    offsetMode.top = <span class="keyword">typeof</span> offsetTop === <span class="string">'number'</span>;</span><br><span class="line">    offsetMode.bottom = <span class="keyword">typeof</span> offsetBottom === <span class="string">'number'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取固定节点容器</span></span><br><span class="line">  <span class="keyword">const</span> targetRect = getTargetRect(targetNode);</span><br><span class="line">  <span class="comment">// 获取固定节点容器内部高度</span></span><br><span class="line">  <span class="keyword">const</span> targetInnerHeight =</span><br><span class="line">    (targetNode <span class="keyword">as</span> Window).innerHeight || (targetNode <span class="keyword">as</span> HTMLElement).clientHeight;</span><br><span class="line">    <span class="comment">// 如果滚动条的距离大于组件位置高度减去传入参数的高度，并且偏移模式为向上的时候，这时候就是固定在顶部</span></span><br><span class="line">  <span class="keyword">if</span> (scrollTop &gt; elemOffset.top - (offsetTop <span class="keyword">as</span> <span class="built_in">number</span>) &amp;&amp; offsetMode.top) &#123;</span><br><span class="line">    <span class="comment">// Fixed Top</span></span><br><span class="line">    <span class="keyword">const</span> width = elemOffset.width;</span><br><span class="line">    <span class="keyword">const</span> top = targetRect.top + (offsetTop <span class="keyword">as</span> <span class="built_in">number</span>);</span><br><span class="line">    <span class="keyword">this</span>.setAffixStyle(e, &#123;</span><br><span class="line">      position: <span class="string">'fixed'</span>,</span><br><span class="line">      top,</span><br><span class="line">      left: targetRect.left + elemOffset.left,</span><br><span class="line">      width,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setPlaceholderStyle(&#123;</span><br><span class="line">      width,</span><br><span class="line">      height: elemSize.height,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 如果滚动距离小于组件位置高度减去组件高度和传入参数的高度并且偏移模式为向下的时候，为固定在底部</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    scrollTop &lt; elemOffset.top + elemSize.height + (offsetBottom <span class="keyword">as</span> <span class="built_in">number</span>) - targetInnerHeight &amp;&amp;</span><br><span class="line">      offsetMode.bottom</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// Fixed Bottom</span></span><br><span class="line">    <span class="keyword">const</span> targetBottomOffet = targetNode === <span class="built_in">window</span> ? <span class="number">0</span> : (<span class="built_in">window</span>.innerHeight - targetRect.bottom);</span><br><span class="line">    <span class="keyword">const</span> width = elemOffset.width;</span><br><span class="line">    <span class="keyword">this</span>.setAffixStyle(e, &#123;</span><br><span class="line">      position: <span class="string">'fixed'</span>,</span><br><span class="line">      bottom: targetBottomOffet + (offsetBottom <span class="keyword">as</span> <span class="built_in">number</span>),</span><br><span class="line">      left: targetRect.left + elemOffset.left,</span><br><span class="line">      width,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">this</span>.setPlaceholderStyle(&#123;</span><br><span class="line">      width,</span><br><span class="line">      height: elemOffset.height,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; affixStyle &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="comment">// 如果上面两者都是不的时候，但是如果窗口resize了，那就重新计算，然后赋值给组件</span></span><br><span class="line">    <span class="keyword">if</span> (e.type === <span class="string">'resize'</span> &amp;&amp; affixStyle &amp;&amp; affixStyle.position === <span class="string">'fixed'</span> &amp;&amp; affixNode.offsetWidth) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAffixStyle(e, &#123; ...affixStyle, width: affixNode.offsetWidth &#125;);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 如果以上情况都不是，那就样式不变</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setAffixStyle(e, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setPlaceholderStyle(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h1><p>这里有几个外部辅助函数写的比较具有参考价值，正是我们应该学习的地方</p><p><code>getScroll()</code>, <code>throttleByAnimationFrameDecorator</code> 装饰器，这两个部分比较有意思，我们会在讲解这两个外部辅助函数的同时顺带讲解一下装饰器模式</p><h2 id="getScrool"><a href="#getScrool" class="headerlink" title="getScrool()"></a>getScrool()</h2><p>这个函数主要是获取到传入的dom节点的滚动事件，其中需要讲解的是 <code>window.document.documentElement</code></p><p>它可以返回一个当前文档的一个根节点，详情可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/documentElement" target="_blank" rel="noopener">这篇文章</a></p><figure class="highlight typescript"><figcaption><span>getScroll</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getScroll</span>(<span class="params">target: <span class="built_in">any</span>, top: <span class="built_in">boolean</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 兼容 Firefox 浏览器</span></span><br><span class="line">  <span class="keyword">const</span> prop = top ? <span class="string">'pageYOffset'</span> : <span class="string">'pageXOffset'</span>;</span><br><span class="line">  <span class="keyword">const</span> method = top ? <span class="string">'scrollTop'</span> : <span class="string">'scrollLeft'</span>;</span><br><span class="line">  <span class="keyword">const</span> isWindow = target === <span class="built_in">window</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ret = isWindow ? target[prop] : target[method];</span><br><span class="line">  <span class="comment">// ie6,7,8 standard mode</span></span><br><span class="line">  <span class="keyword">if</span> (isWindow &amp;&amp; <span class="keyword">typeof</span> ret !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    ret = <span class="built_in">window</span>.document.documentElement[method];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throttleByAnimationFrameDecorator-装饰器"><a href="#throttleByAnimationFrameDecorator-装饰器" class="headerlink" title="throttleByAnimationFrameDecorator 装饰器"></a>throttleByAnimationFrameDecorator 装饰器</h2><p>装饰器模式是为了动态的增减某一个类的功能而存在的，关于装饰器模式的详情可以查看<a href="https://segmentfault.com/a/1190000005331132" target="_blank" rel="noopener">这篇文章</a></p><figure class="highlight typescript"><figcaption><span>getRequestAnimationFrame</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> availablePrefixs = [<span class="string">'moz'</span>, <span class="string">'ms'</span>, <span class="string">'webkit'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// throttleByAnimationFrameDecorator 中调用了这个辅助函数 '../_util/getRequestAnimationFrame'</span></span><br><span class="line"><span class="comment">// 这个函数用来生成一个定时器的或者监听器 ID，如果当前定时器不是 window</span></span><br><span class="line"><span class="comment">// 上面的 requestAnimationFrame 那就自己生成一个，用于以后清除定时器使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestAnimationFramePolyfill</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">  return function(callback: (n: number) =&gt; void) &#123;</span><br><span class="line">    <span class="keyword">const</span> currTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">const</span> timeToCall = <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">16</span> - (currTime - lastTime));</span><br><span class="line">    <span class="keyword">const</span> id = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; callback(currTime + timeToCall); &#125;, timeToCall);</span><br><span class="line">    lastTime = currTime + timeToCall;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数返回一个定时器或者监听器ID</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getRequestAnimationFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 兼容 IE</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.requestAnimationFrame) &#123;</span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue/issues/4465</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame.bind(<span class="built_in">window</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浏览器兼容</span></span><br><span class="line">  <span class="keyword">const</span> prefix = availablePrefixs.filter(<span class="function"><span class="params">key</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;key&#125;</span>RequestAnimationFrame`</span> <span class="keyword">in</span> <span class="built_in">window</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prefix</span><br><span class="line">    ? (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="string">`<span class="subst">$&#123;prefix&#125;</span>RequestAnimationFrame`</span>]</span><br><span class="line">    : requestAnimationFramePolyfill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用来根据 ID 删除对应的定时器或者监听器</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cancelRequestAnimationFrame</span>(<span class="params">id: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.cancelAnimationFrame(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> prefix = availablePrefixs.filter(<span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">    <span class="string">`<span class="subst">$&#123;key&#125;</span>CancelAnimationFrame`</span> <span class="keyword">in</span> <span class="built_in">window</span> || <span class="string">`<span class="subst">$&#123;key&#125;</span>CancelRequestAnimationFrame`</span> <span class="keyword">in</span> <span class="built_in">window</span>,</span><br><span class="line">  )[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> prefix ?</span><br><span class="line">    (</span><br><span class="line">      (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="string">`<span class="subst">$&#123;prefix&#125;</span>CancelAnimationFrame`</span>] ||</span><br><span class="line">      (<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>)[<span class="string">`<span class="subst">$&#123;prefix&#125;</span>CancelRequestAnimationFrame`</span>]</span><br><span class="line">    ).call(<span class="keyword">this</span>, id) : clearTimeout(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><figcaption><span>throttleByAnimationFrame</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> getRequestAnimationFrame, &#123; cancelRequestAnimationFrame &#125; <span class="keyword">from</span> <span class="string">'../_util/getRequestAnimationFrame'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得一个定时器或者监听器</span></span><br><span class="line"><span class="keyword">const</span> reqAnimFrame = getRequestAnimationFrame();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数收到一个函数 返回一个被放入监听其或者定时器额函数，</span></span><br><span class="line"><span class="comment">// 也就是说给这个传入的函数绑定了一个id，让他成为唯一的一个，</span></span><br><span class="line"><span class="comment">// 这样在消除他的时候也很方便</span></span><br><span class="line">export default function throttleByAnimationFrame(fn: () =&gt; void) &#123;</span><br><span class="line">  <span class="keyword">let</span> requestId: <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function">(<span class="params">args: <span class="built_in">any</span>[]</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">    requestId = <span class="literal">null</span>;</span><br><span class="line">    fn(...args);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> throttled = <span class="function">(<span class="params">...args: <span class="built_in">any</span>[]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (requestId == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取定时器或者监听器ID，将监听事件传入</span></span><br><span class="line">      requestId = reqAnimFrame(later(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给这个函数添加上一个取消的函数</span></span><br><span class="line">  (throttled <span class="keyword">as</span> <span class="built_in">any</span>).cancel = <span class="function"><span class="params">()</span> =&gt;</span> cancelRequestAnimationFrame(requestId!);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回构造完成的新函数</span></span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于装饰器的详细参数定义，可以查阅 https://juejin.im/post/59f1c484f265da431c6f8940#heading-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// target: 当前函数（属性）属于的类</span></span><br><span class="line"><span class="comment">// key: 当前函数（属性）名</span></span><br><span class="line"><span class="comment">// dedescriptor： 当前属性的描述</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">throttleByAnimationFrameDecorator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, descriptor: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = descriptor.value;</span><br><span class="line">    <span class="keyword">let</span> definingProperty = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 这个get函数会在类被实例化的时候就进行调用，所以就能够将这些属性赋给外部的target</span></span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (definingProperty || <span class="keyword">this</span> === target.prototype || <span class="keyword">this</span>.hasOwnProperty(key)) &#123;</span><br><span class="line">          <span class="keyword">return</span> fn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> boundFn = throttleByAnimationFrame(fn.bind(<span class="keyword">this</span>));</span><br><span class="line">        definingProperty = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">          value: boundFn,</span><br><span class="line">          configurable: <span class="literal">true</span>,</span><br><span class="line">          writable: <span class="literal">true</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        definingProperty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> boundFn;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对辅助函数的大致分析如以上代码所示，接下来我们还要分析一下 <code>rc-util</code> 中的 <code>addEventListener</code></p><h1 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h1><p>这一部分的实现方式并不复杂，主要就调用了 <code>add-dom-event-listener</code> 这个库进行事件监听器的设置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> addDOMEventListener <span class="keyword">from</span> <span class="string">'add-dom-event-listener'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">addEventListenerWrap</span>(<span class="params">target, eventType, cb</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint camelcase: 2 */</span></span><br><span class="line">  <span class="comment">// 批量更新，防止多次调用 render？</span></span><br><span class="line">  <span class="keyword">const</span> callback = ReactDOM.unstable_batchedUpdates ? <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    ReactDOM.unstable_batchedUpdates(cb, e);</span><br><span class="line">  &#125; : cb;</span><br><span class="line">  <span class="keyword">return</span> addDOMEventListener(target, eventType, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> addEventListener <span class="keyword">from</span> <span class="string">'rc-util/lib/Dom/addEventListener'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> shallowequal <span class="keyword">from</span> <span class="string">'shallowequal'</span>;</span><br><span class="line"><span class="keyword">import</span> omit <span class="keyword">from</span> <span class="string">'omit.js'</span>;</span><br><span class="line"><span class="keyword">import</span> getScroll <span class="keyword">from</span> <span class="string">'../_util/getScroll'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; throttleByAnimationFrameDecorator &#125; <span class="keyword">from</span> <span class="string">'../_util/throttleByAnimationFrame'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTargetRect</span>(<span class="params">target: HTMLElement | Window | <span class="literal">null</span></span>): <span class="title">ClientRect</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> target !== <span class="built_in">window</span> ?</span><br><span class="line">    (target <span class="keyword">as</span> HTMLElement).getBoundingClientRect() :</span><br><span class="line">    &#123; top: <span class="number">0</span>, left: <span class="number">0</span>, bottom: <span class="number">0</span> &#125; <span class="keyword">as</span> ClientRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOffset</span>(<span class="params">element: HTMLElement, target: HTMLElement | Window | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> elemRect = element.getBoundingClientRect();</span><br><span class="line">  <span class="keyword">const</span> targetRect = getTargetRect(target);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> scrollTop = getScroll(target, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">const</span> scrollLeft = getScroll(target, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> docElem = <span class="built_in">window</span>.document.body;</span><br><span class="line">  <span class="keyword">const</span> clientTop = docElem.clientTop || <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> clientLeft = docElem.clientLeft || <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    top: elemRect.top - targetRect.top +</span><br><span class="line">      scrollTop - clientTop,</span><br><span class="line">    left: elemRect.left - targetRect.left +</span><br><span class="line">      scrollLeft - clientLeft,</span><br><span class="line">    width: elemRect.width,</span><br><span class="line">    height: elemRect.height,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noop</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultTarget</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> ?</span><br><span class="line">    <span class="built_in">window</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Affix</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AffixProps &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 距离窗口顶部达到指定偏移量后触发</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  offsetTop?: <span class="built_in">number</span>;</span><br><span class="line">  offset?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">/** 距离窗口底部达到指定偏移量后触发 */</span></span><br><span class="line">  offsetBottom?: <span class="built_in">number</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  <span class="comment">/** 固定状态改变时触发的回调函数 */</span></span><br><span class="line">  onChange?: <span class="function">(<span class="params">affixed?: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">/** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */</span></span><br><span class="line">  target?: <span class="function"><span class="params">()</span> =&gt;</span> Window | HTMLElement | <span class="literal">null</span>;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AffixState &#123;</span><br><span class="line">  affixStyle: React.CSSProperties | <span class="literal">undefined</span>;</span><br><span class="line">  placeholderStyle: React.CSSProperties | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Affix <span class="keyword">extends</span> React.Component&lt;AffixProps, AffixState&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    offsetTop: PropTypes.number,</span><br><span class="line">    offsetBottom: PropTypes.number,</span><br><span class="line">    target: PropTypes.func,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  scrollEvent: <span class="built_in">any</span>;</span><br><span class="line">  resizeEvent: <span class="built_in">any</span>;</span><br><span class="line">  timeout: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  events = [</span><br><span class="line">    <span class="string">'resize'</span>,</span><br><span class="line">    <span class="string">'scroll'</span>,</span><br><span class="line">    <span class="string">'touchstart'</span>,</span><br><span class="line">    <span class="string">'touchmove'</span>,</span><br><span class="line">    <span class="string">'touchend'</span>,</span><br><span class="line">    <span class="string">'pageshow'</span>,</span><br><span class="line">    <span class="string">'load'</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  eventHandlers: &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">  &#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  state: AffixState = &#123;</span><br><span class="line">    affixStyle: <span class="literal">undefined</span>,</span><br><span class="line">    placeholderStyle: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> fixedNode: HTMLElement;</span><br><span class="line"></span><br><span class="line">  setAffixStyle(e: <span class="built_in">any</span>, affixStyle: React.CSSProperties | <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; onChange = noop, target = getDefaultTarget &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> originalAffixStyle = <span class="keyword">this</span>.state.affixStyle;</span><br><span class="line">    <span class="keyword">const</span> isWindow = target() === <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">if</span> (e.type === <span class="string">'scroll'</span> &amp;&amp; originalAffixStyle &amp;&amp; affixStyle &amp;&amp; isWindow) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shallowequal(affixStyle, originalAffixStyle)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; affixStyle: affixStyle <span class="keyword">as</span> React.CSSProperties &#125;, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> affixed = !!<span class="keyword">this</span>.state.affixStyle;</span><br><span class="line">      <span class="keyword">if</span> ((affixStyle &amp;&amp; !originalAffixStyle) ||</span><br><span class="line">          (!affixStyle &amp;&amp; originalAffixStyle)) &#123;</span><br><span class="line">        onChange(affixed);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPlaceholderStyle(placeholderStyle: React.CSSProperties | <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> originalPlaceholderStyle = <span class="keyword">this</span>.state.placeholderStyle;</span><br><span class="line">    <span class="keyword">if</span> (shallowequal(placeholderStyle, originalPlaceholderStyle)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; placeholderStyle: placeholderStyle <span class="keyword">as</span> React.CSSProperties &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@throttleByAnimationFrameDecorator</span>()</span><br><span class="line">  updatePosition(e: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; offsetTop, offsetBottom, offset, target = getDefaultTarget &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> targetNode = target();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Backwards support</span></span><br><span class="line">    offsetTop = offsetTop || offset;</span><br><span class="line">    <span class="keyword">const</span> scrollTop = getScroll(targetNode, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> affixNode = ReactDOM.findDOMNode(<span class="keyword">this</span>) <span class="keyword">as</span> HTMLElement;</span><br><span class="line">    <span class="keyword">const</span> elemOffset = getOffset(affixNode, targetNode);</span><br><span class="line">    <span class="keyword">const</span> elemSize = &#123;</span><br><span class="line">      width: <span class="keyword">this</span>.fixedNode.offsetWidth,</span><br><span class="line">      height: <span class="keyword">this</span>.fixedNode.offsetHeight,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> offsetMode = &#123;</span><br><span class="line">      top: <span class="literal">false</span>,</span><br><span class="line">      bottom: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Default to `offsetTop=0`.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> offsetTop !== <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> offsetBottom !== <span class="string">'number'</span>) &#123;</span><br><span class="line">      offsetMode.top = <span class="literal">true</span>;</span><br><span class="line">      offsetTop = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      offsetMode.top = <span class="keyword">typeof</span> offsetTop === <span class="string">'number'</span>;</span><br><span class="line">      offsetMode.bottom = <span class="keyword">typeof</span> offsetBottom === <span class="string">'number'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> targetRect = getTargetRect(targetNode);</span><br><span class="line">    <span class="keyword">const</span> targetInnerHeight =</span><br><span class="line">      (targetNode <span class="keyword">as</span> Window).innerHeight || (targetNode <span class="keyword">as</span> HTMLElement).clientHeight;</span><br><span class="line">    <span class="keyword">if</span> (scrollTop &gt; elemOffset.top - (offsetTop <span class="keyword">as</span> <span class="built_in">number</span>) &amp;&amp; offsetMode.top) &#123;</span><br><span class="line">      <span class="comment">// Fixed Top</span></span><br><span class="line">      <span class="keyword">const</span> width = elemOffset.width;</span><br><span class="line">      <span class="keyword">const</span> top = targetRect.top + (offsetTop <span class="keyword">as</span> <span class="built_in">number</span>);</span><br><span class="line">      <span class="keyword">this</span>.setAffixStyle(e, &#123;</span><br><span class="line">        position: <span class="string">'fixed'</span>,</span><br><span class="line">        top,</span><br><span class="line">        left: targetRect.left + elemOffset.left,</span><br><span class="line">        width,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.setPlaceholderStyle(&#123;</span><br><span class="line">        width,</span><br><span class="line">        height: elemSize.height,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      scrollTop &lt; elemOffset.top + elemSize.height + (offsetBottom <span class="keyword">as</span> <span class="built_in">number</span>) - targetInnerHeight &amp;&amp;</span><br><span class="line">        offsetMode.bottom</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// Fixed Bottom</span></span><br><span class="line">      <span class="keyword">const</span> targetBottomOffet = targetNode === <span class="built_in">window</span> ? <span class="number">0</span> : (<span class="built_in">window</span>.innerHeight - targetRect.bottom);</span><br><span class="line">      <span class="keyword">const</span> width = elemOffset.width;</span><br><span class="line">      <span class="keyword">this</span>.setAffixStyle(e, &#123;</span><br><span class="line">        position: <span class="string">'fixed'</span>,</span><br><span class="line">        bottom: targetBottomOffet + (offsetBottom <span class="keyword">as</span> <span class="built_in">number</span>),</span><br><span class="line">        left: targetRect.left + elemOffset.left,</span><br><span class="line">        width,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.setPlaceholderStyle(&#123;</span><br><span class="line">        width,</span><br><span class="line">        height: elemOffset.height,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; affixStyle &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">      <span class="keyword">if</span> (e.type === <span class="string">'resize'</span> &amp;&amp; affixStyle &amp;&amp; affixStyle.position === <span class="string">'fixed'</span> &amp;&amp; affixNode.offsetWidth) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setAffixStyle(e, &#123; ...affixStyle, width: affixNode.offsetWidth &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setAffixStyle(e, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.setPlaceholderStyle(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="keyword">this</span>.props.target || getDefaultTarget;</span><br><span class="line">    <span class="comment">// Wait for parent component ref has its value</span></span><br><span class="line">    <span class="keyword">this</span>.timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setTargetEventListeners(target);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps: AffixProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.target !== nextProps.target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.clearEventListeners();</span><br><span class="line">      <span class="keyword">this</span>.setTargetEventListeners(nextProps.target!);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Mock Event object.</span></span><br><span class="line">      <span class="keyword">this</span>.updatePosition(&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.clearEventListeners();</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeout);</span><br><span class="line">    (<span class="keyword">this</span>.updatePosition <span class="keyword">as</span> <span class="built_in">any</span>).cancel();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setTargetEventListeners(getTarget: <span class="function"><span class="params">()</span> =&gt;</span> HTMLElement | Window | <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = getTarget();</span><br><span class="line">    <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.clearEventListeners();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.events.forEach(<span class="function"><span class="params">eventName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.eventHandlers[eventName] = addEventListener(target, eventName, <span class="keyword">this</span>.updatePosition);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clearEventListeners() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events.forEach(<span class="function"><span class="params">eventName</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> handler = <span class="keyword">this</span>.eventHandlers[eventName];</span><br><span class="line">      <span class="keyword">if</span> (handler &amp;&amp; handler.remove) &#123;</span><br><span class="line">        handler.remove();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  saveFixedNode = <span class="function">(<span class="params">node: HTMLDivElement</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.fixedNode = node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> className = classNames(&#123;</span><br><span class="line">      [<span class="keyword">this</span>.props.prefixCls || <span class="string">'ant-affix'</span>]: <span class="keyword">this</span>.state.affixStyle,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> props = omit(<span class="keyword">this</span>.props, [<span class="string">'prefixCls'</span>, <span class="string">'offsetTop'</span>, <span class="string">'offsetBottom'</span>, <span class="string">'target'</span>, <span class="string">'onChange'</span>]);</span><br><span class="line">    <span class="keyword">const</span> placeholderStyle = &#123; ...this.state.placeholderStyle, ...this.props.style &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div &#123;...props&#125; style=&#123;placeholderStyle&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;className&#125; ref=&#123;<span class="keyword">this</span>.saveFixedNode&#125; style=&#123;<span class="keyword">this</span>.state.affixStyle&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Affix</code> 组件相对于其他的组件稍微复杂一些，具体体现在如何根据状态更新组件的样式，以及对 <code>Decorator</code> 的一些运用，后续会更新几篇关于 <code>Decorator</code> 和生命周期的文章</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/59e8d66f518825619b4e0d9a#heading-7" target="_blank" rel="noopener">antd源码解读（6）- Affix</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Affix 是 React 提供的一个图钉组件，它可以固定在页面的固定位置，我们来看看它的实现方式是怎样的？&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（5）- Grid 组件</title>
    <link href="https://www.douglasdong.site/2018-10-05.html"/>
    <id>https://www.douglasdong.site/2018-10-05.html</id>
    <published>2018-10-05T11:26:24.000Z</published>
    <updated>2018-10-08T03:29:42.389Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Grid-组件"><a href="#Grid-组件" class="headerlink" title="Grid 组件"></a>Grid 组件</h1><p><code>Grid</code> 组件是 <code>AntD</code> 使用的一套栅格布局系统，它的大致表现形式与 <code>Bootstrap</code> 相同，主要依赖 <code>Col</code> 和 <code>Row</code> 两个组件构成</p><p>整个栅格布局系统使用 <code>flex</code> 布局完成，如果对 <code>flex</code> 布局不了解可以参看<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">这篇文章</a></p><h1 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h1><p>我们首先来看看文档对每个参数的解读：</p><table><thead><tr><th><div>成员</div></th><th><div>说明</div></th><th>类型</th><th><div>默认值</div></th></tr></thead><tbody><tr><td><div>align</div></td><td><div>flex 布局下的垂直对齐方式：top middle bottom</div></td><td><div>string</div></td><td><div>top</div></td></tr><tr><td><div>gutter</div></td><td><div>栅格间隔，可以写成像素值或支持响应式的对象写法 { xs: 8, sm: 16, md: 24}</div></td><td><div>number/object</div></td><td><div>0</div></td></tr><tr><td><div>justify</div></td><td><div>flex 布局下的水平排列方式：start end center space-around space-between<span class="Apple-tab-span" style="white-space:pre"></span></div></td><td><div>string</div></td><td><div>start</div></td></tr><tr><td>type</td><td>布局模式，可选 flex，现代浏览器 下有效</td><td>string<span class="Apple-tab-span" style="white-space:pre"></span></td></tr></tbody></table><p><code>Row</code> 组件中有一个比较特殊的参数 <code>gutter</code>，这个参数指的是每个栅格元素之间的间隔</p><p>这里还有两个需要注意的点：<code>React.children</code>，<code>React.cloneElement()</code>，在 React 对子元素操作中非常管用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// matchMedia polyfill for</span></span><br><span class="line"><span class="comment">// https://github.com/WickyNilliams/enquire.js/issues/82</span></span><br><span class="line"><span class="comment">// matchMedia 的 Polyfill</span></span><br><span class="line"><span class="keyword">let</span> enquire: <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> matchMediaPolyfill = (mediaQuery: <span class="built_in">string</span>): <span class="function"><span class="params">MediaQueryList</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      media: mediaQuery,</span><br><span class="line">      matches: <span class="literal">false</span>,</span><br><span class="line">      addListener() &#123;</span><br><span class="line">      &#125;,</span><br><span class="line">      removeListener() &#123;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.matchMedia = <span class="built_in">window</span>.matchMedia || matchMediaPolyfill;</span><br><span class="line">  enquire = <span class="built_in">require</span>(<span class="string">'enquire.js'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Children, cloneElement &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同的设备调用不同的 CSS  样式（弹性布局）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> Breakpoint = <span class="string">'xxl'</span> | <span class="string">'xl'</span> | <span class="string">'lg'</span> | <span class="string">'md'</span> | <span class="string">'sm'</span> | <span class="string">'xs'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> BreakpointMap = &#123;</span><br><span class="line">  xs?: <span class="built_in">string</span>;</span><br><span class="line">  sm?: <span class="built_in">string</span>;</span><br><span class="line">  md?: <span class="built_in">string</span>;</span><br><span class="line">  lg?: <span class="built_in">string</span>;</span><br><span class="line">  xl?: <span class="built_in">string</span>;</span><br><span class="line">  xxl?: <span class="built_in">string</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入 Row 的参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RowProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  gutter?: <span class="built_in">number</span> | BreakpointMap;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="string">'flex'</span>;</span><br><span class="line">  align?: <span class="string">'top'</span> | <span class="string">'middle'</span> | <span class="string">'bottom'</span>;</span><br><span class="line">  justify?: <span class="string">'start'</span> | <span class="string">'end'</span> | <span class="string">'center'</span> | <span class="string">'space-around'</span> | <span class="string">'space-between'</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独处理的 BreakpointMap，用于适配弹性布局</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RowState &#123;</span><br><span class="line">  screens: BreakpointMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responsiveArray: Breakpoint[] = [<span class="string">'xxl'</span>, <span class="string">'xl'</span>, <span class="string">'lg'</span>, <span class="string">'md'</span>, <span class="string">'sm'</span>, <span class="string">'xs'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> responsiveMap: BreakpointMap = &#123;</span><br><span class="line">  xs: <span class="string">'(max-width: 575px)'</span>,</span><br><span class="line">  sm: <span class="string">'(min-width: 576px)'</span>,</span><br><span class="line">  md: <span class="string">'(min-width: 768px)'</span>,</span><br><span class="line">  lg: <span class="string">'(min-width: 992px)'</span>,</span><br><span class="line">  xl: <span class="string">'(min-width: 1200px)'</span>,</span><br><span class="line">  xxl: <span class="string">'(min-width: 1600px)'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Row <span class="keyword">extends</span> React.Component&lt;RowProps, RowState&gt; &#123;</span><br><span class="line">  <span class="comment">// 设定默认参数</span></span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    gutter: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="keyword">type</span>: PropTypes.string,</span><br><span class="line">    align: PropTypes.string,</span><br><span class="line">    justify: PropTypes.string,</span><br><span class="line">    className: PropTypes.string,</span><br><span class="line">    children: PropTypes.node,</span><br><span class="line">    gutter: PropTypes.oneOfType([PropTypes.object, PropTypes.number]),</span><br><span class="line">    prefixCls: PropTypes.string,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  state: RowState = &#123;</span><br><span class="line">    screens: &#123;&#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 利用 enquire 做动态媒体查询</span></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// enquire.register 注册 responsiveMap 相关的媒体查询事件</span></span><br><span class="line">    <span class="comment">// match 做匹配，当条件满足时执行内容</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(responsiveMap)</span><br><span class="line">      .map(<span class="function">(<span class="params">screen: Breakpoint</span>) =&gt;</span> enquire.register(responsiveMap[screen], &#123;</span><br><span class="line">          <span class="comment">// 匹配查询条件时</span></span><br><span class="line">          match: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 输入 gutter 不为对象时不做反馈</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.props.gutter !== <span class="string">'object'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输入为对象时</span></span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">              screens: &#123;</span><br><span class="line">                ...prevState.screens,</span><br><span class="line">                [screen]: <span class="literal">true</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;));</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 当窗口从匹配调整到不匹配时</span></span><br><span class="line">          unmatch: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.props.gutter !== <span class="string">'object'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">              screens: &#123;</span><br><span class="line">                ...prevState.screens,</span><br><span class="line">                [screen]: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;));</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// Keep a empty destory to avoid triggering unmatch when unregister</span></span><br><span class="line">          destroy() &#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ));</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="comment">// 注销媒体查询事件</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(responsiveMap)</span><br><span class="line">      .map(<span class="function">(<span class="params">screen: Breakpoint</span>) =&gt;</span> enquire.unregister(responsiveMap[screen]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理拿到的 gutter</span></span><br><span class="line">  getGutter() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; gutter &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gutter === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= responsiveArray.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> breakpoint: Breakpoint = responsiveArray[i];</span><br><span class="line">        <span class="comment">// 传入过 gutter（object），而且满足媒体查询条件的时候</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.state.screens[breakpoint] &amp;&amp; gutter[breakpoint] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> gutter[breakpoint];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则直接返回（number）</span></span><br><span class="line">    <span class="keyword">return</span> gutter;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">type</span>, justify, align, className, style, children,</span><br><span class="line">      prefixCls = <span class="string">'ant-row'</span>, ...others,</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> gutter = <span class="keyword">this</span>.getGutter();</span><br><span class="line">    <span class="keyword">const</span> classes = classNames(&#123;</span><br><span class="line">      [prefixCls]: !<span class="keyword">type</span>,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="keyword">type</span>,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;type&#125;</span>-<span class="subst">$&#123;justify&#125;</span>`</span>]: <span class="keyword">type</span> &amp;&amp; justify,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;type&#125;</span>-<span class="subst">$&#123;align&#125;</span>`</span>]: <span class="keyword">type</span> &amp;&amp; align,</span><br><span class="line">    &#125;, className);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有 gutter 这个参数，就是需要添加间距，他的实现方法是给每一个Item添加左右的pading，</span></span><br><span class="line">    <span class="comment">// 但是又不想让第一个和最后一个 Item 也有这个内边距，所以在父级元素上面设置左右相同负值</span></span><br><span class="line">    <span class="comment">// 的margin，就能够抵消两端的padding。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> rowStyle = (gutter <span class="keyword">as</span> <span class="built_in">number</span>) &gt; <span class="number">0</span> ? &#123;</span><br><span class="line">      marginLeft: (gutter <span class="keyword">as</span> <span class="built_in">number</span>) / <span class="number">-2</span>,</span><br><span class="line">      marginRight: (gutter <span class="keyword">as</span> <span class="built_in">number</span>) / <span class="number">-2</span>,</span><br><span class="line">      ...style,</span><br><span class="line">    &#125; : style;</span><br><span class="line">    <span class="comment">// 查询子元素（类型：ReactElement）</span></span><br><span class="line">    <span class="comment">// React.Children使用的时候不必担心内部子元素是否有嵌套关系</span></span><br><span class="line">    <span class="keyword">const</span> cols = Children.map(children, <span class="function">(<span class="params">col: React.ReactElement&lt;HTMLDivElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在子元素</span></span><br><span class="line">      <span class="keyword">if</span> (!col) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 存在属性，且 gutter（number）&gt; 0 时，增加子元素的属性</span></span><br><span class="line">      <span class="keyword">if</span> (col.props &amp;&amp; (gutter <span class="keyword">as</span> <span class="built_in">number</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回一个新的组件，会新增添加的其余的props或者修改过后的props</span></span><br><span class="line">        <span class="keyword">return</span> cloneElement(col, &#123;</span><br><span class="line">          style: &#123;</span><br><span class="line">            paddingLeft: (gutter <span class="keyword">as</span> <span class="built_in">number</span>) / <span class="number">2</span>,</span><br><span class="line">            paddingRight: (gutter <span class="keyword">as</span> <span class="built_in">number</span>) / <span class="number">2</span>,</span><br><span class="line">            ...col.props.style,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 否则直接返回子元素</span></span><br><span class="line">      <span class="keyword">return</span> col;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 收集剩余的属性，删去不符合规范的 gutter 属性</span></span><br><span class="line">    <span class="keyword">const</span> otherProps = &#123; ...others &#125;;</span><br><span class="line">    <span class="keyword">delete</span> otherProps.gutter;</span><br><span class="line">    <span class="keyword">return</span> &lt;div &#123;...otherProps&#125; className=&#123;classes&#125; style=&#123;rowStyle&#125;&gt;&#123;cols&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure><h1 id="Col"><a href="#Col" class="headerlink" title="Col"></a>Col</h1><p><code>Col</code> 这个组件全部都是用的 <code>CSS</code> 以及flex实现的，唯一需要讲解的大概应该是 <code>&#39;xs&#39;</code>, <code>&#39;sm&#39;</code>, <code>&#39;md&#39;</code>, <code>&#39;lg&#39;</code>, <code>&#39;xl&#39;</code> 的使用，为什么会有传入对象的参数，因为这样子可以自定义自己的一个栅格布局，实现更加灵活的栅格布局，这样也使得 <code>Col</code> 这个组件更加灵活。</p><p>先来看看它的参数文档：</p><table><thead><tr><th><div>成员</div></th><th><div> 说明 </div></th><th><div> 类型 </div></th><th><div>     默认值 </div></th></tr></thead><tbody><tr><td><div>offset</div></td><td><div>栅格左侧的间隔格数，间隔内不可以有栅格</div></td><td><div>number</div></td><td><div>0</div></td></tr><tr><td><div>order</div></td><td><div>栅格顺序，flex 布局模式下有效</div></td><td><div>number</div></td><td><div>0</div></td></tr><tr><td><div>pull</div></td><td><div>栅格向左移动格数</div></td><td><div>number</div></td><td><div>0</div></td></tr><tr><td><div>push</div></td><td><div>栅格向右移动格数</div></td><td><div>number</div></td><td><div>0</div></td></tr><tr><td><div>span</div></td><td><div>栅格占位格数，为 0 时相当于 display: none<span class="Apple-tab-span" style="white-space:pre"></span></div></td><td><div>number</div></td><td><div>-</div></td></tr><tr><td><div>xs</div></td><td><div><576px 响应式栅格，可为栅格数或一个包含其他属性的对象<="" div=""></576px></div></td><td><div>number / object</div></td><td><div>-</div></td></tr><tr><td><div>sm</div></td><td><div>≥576px 响应式栅格，可为栅格数或一个包含其他属性的对象</div></td><td><div>number / object</div></td><td><div>-</div></td></tr><tr><td><div>md</div></td><td><div>≥768px 响应式栅格，可为栅格数或一个包含其他属性的对象</div></td><td><div>number / object</div></td><td><div>-</div></td></tr><tr><td><div>lg</div></td><td><div>≥992px 响应式栅格，可为栅格数或一个包含其他属性的对象</div></td><td><div>number / object</div></td><td><div>-</div></td></tr><tr><td><div>xl</div></td><td><div>≥1200px 响应式栅格，可为栅格数或一个包含其他属性的对象</div></td><td><div>number / object</div></td><td><div>-</div></td></tr><tr><td>xxl</td><td>≥1600px 响应式栅格，可为栅格数或一个包含其他属性的对象<span class="Apple-tab-span" style="white-space:pre"></span></td><td>number / object</td><td>-</td></tr></tbody></table><p><code>Col</code> 组件源代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里使用了 PropTypys.oneOfType()，这个函数的意思就是使用其数组中指定的的任意的一种类型都返回真</span></span><br><span class="line"><span class="keyword">const</span> stringOrNumber = PropTypes.oneOfType([PropTypes.string, PropTypes.number]);</span><br><span class="line"><span class="keyword">const</span> objectOrNumber = PropTypes.oneOfType([PropTypes.object, PropTypes.number]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColSize &#123;</span><br><span class="line">  span?: <span class="built_in">number</span>;</span><br><span class="line">  order?: <span class="built_in">number</span>;</span><br><span class="line">  offset?: <span class="built_in">number</span>;</span><br><span class="line">  push?: <span class="built_in">number</span>;</span><br><span class="line">  pull?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ColProps &#123;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  span?: <span class="built_in">number</span>;</span><br><span class="line">  order?: <span class="built_in">number</span>;</span><br><span class="line">  offset?: <span class="built_in">number</span>;</span><br><span class="line">  push?: <span class="built_in">number</span>;</span><br><span class="line">  pull?: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 为了让 Col 组件的其他属性也能嵌套到响应式属性中使用</span></span><br><span class="line">  xs?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  sm?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  md?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  lg?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  xl?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  xxl?: <span class="built_in">number</span> | ColSize;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Col <span class="keyword">extends</span> React.Component&lt;ColProps, &#123;&#125;&gt; &#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    span: stringOrNumber,</span><br><span class="line">    order: stringOrNumber,</span><br><span class="line">    offset: stringOrNumber,</span><br><span class="line">    push: stringOrNumber,</span><br><span class="line">    pull: stringOrNumber,</span><br><span class="line">    className: PropTypes.string,</span><br><span class="line">    children: PropTypes.node,</span><br><span class="line">    xs: objectOrNumber,</span><br><span class="line">    sm: objectOrNumber,</span><br><span class="line">    md: objectOrNumber,</span><br><span class="line">    lg: objectOrNumber,</span><br><span class="line">    xl: objectOrNumber,</span><br><span class="line">    xxl: objectOrNumber,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props: <span class="built_in">any</span> = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; span, order, offset, push, pull, className, children, prefixCls = <span class="string">'ant-col'</span>, ...others &#125; = props;</span><br><span class="line">    <span class="keyword">let</span> sizeClassObj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 设定 xs / sm / md / lg / xl / xxl 被设定时的样式</span></span><br><span class="line">    [<span class="string">'xs'</span>, <span class="string">'sm'</span>, <span class="string">'md'</span>, <span class="string">'lg'</span>, <span class="string">'xl'</span>, <span class="string">'xxl'</span>].forEach(<span class="function"><span class="params">size</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> sizeProps: ColSize = &#123;&#125;;</span><br><span class="line">      <span class="comment">// 当传入参数为对象的时候，就不仅可以定义 span，还可以定义其他的参数,push, pull, older, offset </span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> props[size] === <span class="string">'number'</span>) &#123;</span><br><span class="line">        sizeProps.span = props[size];</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 传入对象时，将整个 sizeProps 重设为传入值</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> props[size] === <span class="string">'object'</span>) &#123;</span><br><span class="line">        sizeProps = props[size] || &#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">delete</span> others[size];</span><br><span class="line"></span><br><span class="line">      sizeClassObj = &#123;</span><br><span class="line">        ...sizeClassObj,</span><br><span class="line">        [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;size&#125;</span>-<span class="subst">$&#123;sizeProps.span&#125;</span>`</span>]: sizeProps.span !== <span class="literal">undefined</span>,</span><br><span class="line">        [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;size&#125;</span>-order-<span class="subst">$&#123;sizeProps.order&#125;</span>`</span>]: sizeProps.order || sizeProps.order === <span class="number">0</span>,</span><br><span class="line">        [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;size&#125;</span>-offset-<span class="subst">$&#123;sizeProps.offset&#125;</span>`</span>]: sizeProps.offset || sizeProps.offset === <span class="number">0</span>,</span><br><span class="line">        [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;size&#125;</span>-push-<span class="subst">$&#123;sizeProps.push&#125;</span>`</span>]: sizeProps.push || sizeProps.push === <span class="number">0</span>,</span><br><span class="line">        [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;size&#125;</span>-pull-<span class="subst">$&#123;sizeProps.pull&#125;</span>`</span>]: sizeProps.pull || sizeProps.pull === <span class="number">0</span>,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> classes = classNames(&#123;</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;span&#125;</span>`</span>]: span !== <span class="literal">undefined</span>,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-order-<span class="subst">$&#123;order&#125;</span>`</span>]: order,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-offset-<span class="subst">$&#123;offset&#125;</span>`</span>]: offset,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-push-<span class="subst">$&#123;push&#125;</span>`</span>]: push,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-pull-<span class="subst">$&#123;pull&#125;</span>`</span>]: pull,</span><br><span class="line">    &#125;, className, sizeClassObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &lt;div &#123;...others&#125; className=&#123;classes&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Grid 部分在整个框架中的逻辑并不算复杂，媒体查询是其中比较重要的部分，实现方式也十分值得借鉴</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/59e4cdeef265da43070254f9" target="_blank" rel="noopener">antd源码解读（5）- Grid</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Grid 组件是 Ant-Design 做页面实现是最常调用的部分，它的实现逻辑又是怎样的？&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（4）- ButtonGroup 组件</title>
    <link href="https://www.douglasdong.site/2018-10-04.html"/>
    <id>https://www.douglasdong.site/2018-10-04.html</id>
    <published>2018-10-04T06:52:53.000Z</published>
    <updated>2018-10-08T03:29:46.520Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Button-Group"><a href="#Button-Group" class="headerlink" title="Button Group"></a>Button Group</h1><p>作为 Button 的配套组件，<code>ButtonGroup</code> 的内部逻辑非常简单，毕竟只是一个将 <code>Button</code> 组件包裹起来的一个容器，我们在这里只需要了解其中一个部分即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ButtonSize &#125; <span class="keyword">from</span> <span class="string">'./button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ButtonGroupProps &#123;</span><br><span class="line">  size?: ButtonSize;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">  className?: <span class="built_in">string</span>;</span><br><span class="line">  prefixCls?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无状态组件，组件内部不保存任何状态，也被称为纯函数组件</span></span><br><span class="line"><span class="comment">// Typescript 中用 SFC 进行定义</span></span><br><span class="line"><span class="keyword">const</span> ButtonGroup: React.SFC&lt;ButtonGroupProps&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; prefixCls = <span class="string">'ant-btn-group'</span>, size, className, ...others &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// large =&gt; lg</span></span><br><span class="line">  <span class="comment">// small =&gt; sm</span></span><br><span class="line">  <span class="keyword">let</span> sizeCls = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'large'</span>:</span><br><span class="line">      sizeCls = <span class="string">'lg'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'small'</span>:</span><br><span class="line">      sizeCls = <span class="string">'sm'</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> classes = classNames(prefixCls, &#123;</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;sizeCls&#125;</span>`</span>]: sizeCls,</span><br><span class="line">  &#125;, className);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &lt;div &#123;...others&#125; className=&#123;classes&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ButtonGroup;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/59e1a608518825489732c054" target="_blank" rel="noopener">antd源码解读（4）- ButtonGroup</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Button 组件的配套组件 ButtonGroup 内部的逻辑又是如何运行的？&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（3）- Button 组件</title>
    <link href="https://www.douglasdong.site/2018-10-03-1.html"/>
    <id>https://www.douglasdong.site/2018-10-03-1.html</id>
    <published>2018-10-03T08:04:38.000Z</published>
    <updated>2018-10-08T03:29:51.140Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><p><code>Button</code> 用了两个组件：<code>Button</code> 和 <code>ButtonGroup</code></p><h1 id="Button-参数"><a href="#Button-参数" class="headerlink" title="Button 参数"></a>Button 参数</h1><p>看一个组件首先观察它的传参，所以我们先看 <code>Button</code> 组件中的 <code>ButtonProps</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ButtonType = <span class="string">'primary'</span> | <span class="string">'ghost'</span> | <span class="string">'dashed'</span> | <span class="string">'danger'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ButtonShape = <span class="string">'circle'</span> | <span class="string">'circle-outline'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ButtonSize = <span class="string">'small'</span> | <span class="string">'large'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ButtonProps &#123;</span><br><span class="line">  <span class="keyword">type</span>?: ButtonType; <span class="comment">// 按钮类型</span></span><br><span class="line">  htmlType?: <span class="built_in">string</span>; <span class="comment">// 设置 button 原生的 type 值（HTML 标准）</span></span><br><span class="line">  icon?: <span class="built_in">string</span>; <span class="comment">// 设置按钮图标类型</span></span><br><span class="line">  shape?: ButtonShape; <span class="comment">// 设置按钮形状（circle 或不设）</span></span><br><span class="line">  size?: ButtonSize; <span class="comment">// 设置按钮大小</span></span><br><span class="line">  onClick?: React.FormEventHandler&lt;<span class="built_in">any</span>&gt;; <span class="comment">// click 事件处理</span></span><br><span class="line">  onMouseUp?: React.FormEventHandler&lt;<span class="built_in">any</span>&gt;; <span class="comment">// 鼠标划过</span></span><br><span class="line">  onMouseDown?: React.FormEventHandler&lt;<span class="built_in">any</span>&gt;; <span class="comment">// 鼠标点击</span></span><br><span class="line">  loading?: <span class="built_in">boolean</span> | &#123; delay?: <span class="built_in">number</span> &#125;; <span class="comment">// 载入状态</span></span><br><span class="line">  disabled?: <span class="built_in">boolean</span>; <span class="comment">// 让按钮处于不可用状态</span></span><br><span class="line">  style?: React.CSSProperties; <span class="comment">// 内联样式</span></span><br><span class="line">  prefixCls?: <span class="built_in">string</span>; <span class="comment">// 预置字符串，用于拼接样式</span></span><br><span class="line">  className?: <span class="built_in">string</span>; <span class="comment">// 输出自定义 CSS 类</span></span><br><span class="line">  ghost?: <span class="built_in">boolean</span>; <span class="comment">// 幽灵属性，使按钮背景透明（2.7+）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数文档"><a href="#参数文档" class="headerlink" title="参数文档"></a>参数文档</h2><table><thead><tr><th>属性</th><th>说明</th><th>类型</th><th>默认值</th></tr></thead><tbody><tr><td>ghost</td><td>幽灵属性，使按钮背景透明，版本 2.7 中增加</td><td>boolean</td><td>false</td></tr><tr><td>htmlType</td><td>设置 button 原生的 type 值，可选值请参考 HTML 标准<span class="Apple-tab-span" style="white-space:pre"></span></td><td>string<span class="Apple-tab-span" style="white-space:pre"></span></td><td>button</td></tr><tr><td>icon</td><td>设置按钮的图标类型<span class="Apple-tab-span" style="white-space:pre"></span></td><td>string</td><td>-</td></tr><tr><td>loading<span class="Apple-tab-span" style="white-space:pre"></span></td><td>设置按钮载入状态</td><td>boolean / { delay: number }<span class="Apple-tab-span" style="white-space:pre"></span></td><td>false</td></tr><tr><td>shape</td><td>设置按钮形状，可选值为 circle 或者不设<span class="Apple-tab-span" style="white-space:pre"></span></td><td>string</td><td>-</td></tr><tr><td>size</td><td>设置按钮大小，可选值为 small large 或者不设<span class="Apple-tab-span" style="white-space:pre"></span></td><td>string<span class="Apple-tab-span" style="white-space:pre"></span></td><td>default</td></tr><tr><td>type<span class="Apple-tab-span" style="white-space:pre"></span></td><td>设置按钮类型，可选值为 primary dashed danger(版本 2.7 中增加) 或者不设<span class="Apple-tab-span" style="white-space:pre"></span></td><td>string<span class="Apple-tab-span" style="white-space:pre"></span></td><td>-</td></tr><tr><td>onClick</td><td>click 事件的 handler<span class="Apple-tab-span" style="white-space:pre"></span></td><td>function</td><td>-</td></tr></tbody></table><p>接下来，我们先跳过组件内部的逻辑，先来看看 <code>Render</code> 部分的内容</p><h1 id="渲染函数（Render）"><a href="#渲染函数（Render）" class="headerlink" title="渲染函数（Render）"></a>渲染函数（Render）</h1><p>首先看看这部分的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是为了规范传入参数的类型</span></span><br><span class="line"><span class="comment">// React.Component 第一个参数是 Props，第二个是 state</span></span><br><span class="line"><span class="comment">// 然后利用 typescript 的类型检查机制明确 Props 类型为上面传入的 ButtonProps</span></span><br><span class="line"><span class="comment">// state 这里不做类型检查</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Button <span class="keyword">extends</span> React.Component&lt;ButtonProps, <span class="built_in">any</span>&gt; </span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="comment">// 解构接口 ButtonProps 传入的参数</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">type</span>, shape, size, className, htmlType, children, icon, prefixCls, ghost, ...others,</span><br><span class="line">  &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="comment">// 从 this.state 解构 loading，clicked，hasTwoCNChar</span></span><br><span class="line">  <span class="comment">// hasTwoCNChar 是为了修正两个汉字之间没有添加空格的问题</span></span><br><span class="line">  <span class="keyword">const</span> &#123; loading, clicked, hasTwoCNChar &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// large =&gt; lg</span></span><br><span class="line">  <span class="comment">// small =&gt; sm</span></span><br><span class="line">  <span class="keyword">let</span> sizeCls = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// 定义 size 所对应的 CSS</span></span><br><span class="line">  <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'large'</span>:</span><br><span class="line">      sizeCls = <span class="string">'lg'</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'small'</span>:</span><br><span class="line">      sizeCls = <span class="string">'sm'</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 传入 href 标记时可作为 &lt;a&gt; 标签使用</span></span><br><span class="line">  <span class="keyword">const</span> ComponentProp = others.href ? <span class="string">'a'</span> : <span class="string">'button'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组建样式</span></span><br><span class="line">  <span class="keyword">const</span> classes = classNames(prefixCls, className, &#123;</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="keyword">type</span>,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;shape&#125;</span>`</span>]: shape,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;sizeCls&#125;</span>`</span>]: sizeCls,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-icon-only`</span>]: !children &amp;&amp; icon,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-loading`</span>]: loading,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-clicked`</span>]: clicked,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-background-ghost`</span>]: ghost,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-two-chinese-chars`</span>]: hasTwoCNChar,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 传入 icon 与 loading 时，生成相应的 Icon 组件</span></span><br><span class="line">  <span class="keyword">const</span> iconType = loading ? <span class="string">'loading'</span> : icon;</span><br><span class="line">  <span class="keyword">const</span> iconNode = iconType ? &lt;Icon <span class="keyword">type</span>=&#123;iconType&#125; /&gt; : <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里引用了 React.Children.map 这个函数来渲染包裹在 Button 组件中的内容</span></span><br><span class="line">  <span class="comment">// 当组件有子节点时调用 insertSpace</span></span><br><span class="line">  <span class="comment">// children === 0 是为了修复 &lt;Button&gt;&#123;0&#125;&lt;/Button&gt; 显示异常的bug</span></span><br><span class="line">  <span class="comment">// insertSpace 这个函数主要是为了判断输入是否是中文汉字？如果是的话在中间加入空格，不是则直接返回一个 span</span></span><br><span class="line">  <span class="comment">// 不用 letter-space 是为了不在英文中加入空格</span></span><br><span class="line">  <span class="comment">// &lt;Button&gt;Hello world!&lt;/Button&gt; 最终会被渲染为 &lt;button&gt;&lt;span&gt;Hello world!&lt;/span&gt;&lt;/button&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> kids = (children || children === <span class="number">0</span>)</span><br><span class="line">    ? React.Children.map(children, <span class="function"><span class="params">child</span> =&gt;</span> insertSpace(child, <span class="keyword">this</span>.isNeedInserted())) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// 同之前的 Icon 组件，删去 others 属性在 HTML 规范中不存在的内容</span></span><br><span class="line">    &lt;ComponentProp</span><br><span class="line">      &#123;...omit(others, [<span class="string">'loading'</span>])&#125;</span><br><span class="line">      <span class="keyword">type</span>=&#123;others.href ? <span class="literal">undefined</span> : (htmlType || <span class="string">'button'</span>)&#125;</span><br><span class="line">      className=&#123;classes&#125;</span><br><span class="line">      onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br><span class="line">    &gt;</span><br><span class="line">      <span class="comment">// 渲染子元素</span></span><br><span class="line">      &#123;iconNode&#125;&#123;kids&#125;</span><br><span class="line">    &lt;<span class="regexp">/ComponentProp&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="InsertSpace-isNeedInserted"><a href="#InsertSpace-isNeedInserted" class="headerlink" title="InsertSpace / isNeedInserted"></a>InsertSpace / isNeedInserted</h1><p>接下来看看上面用到的 <code>InsertSpace</code> 和 <code>isNeedInserted</code> 是如何调用的</p><p>首先看看组件修复 bug 时引入的两个新变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式，判断是否为汉字（\u4e00 - \u9fa5 代表 unicode 中所有汉字）</span></span><br><span class="line"><span class="keyword">const</span> rxTwoCNChar = <span class="regexp">/^[\u4e00-\u9fa5]&#123;2&#125;$/</span>;</span><br><span class="line"><span class="comment">// 以布尔类型返回判断结果</span></span><br><span class="line"><span class="keyword">const</span> isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);</span><br></pre></td></tr></table></figure><p>接下来看看用于判断的 <code>isNeedInserted</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isNeedInserted() &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; loading, icon, children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">  <span class="keyword">const</span> iconType = loading ? <span class="string">'loading'</span> : icon;</span><br><span class="line">  <span class="comment">// 仅有一个子节点，且 icon 不为空时返回真</span></span><br><span class="line">  <span class="keyword">return</span> React.Children.count(children) === <span class="number">1</span> &amp;&amp; (!iconType || iconType === <span class="string">'loading'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件被加载时，会从 DOM 节点中取出文本，然后对字符进行判断，如果为两个中文字符，则会将 hasTwoCNChar 置真</p><p>最后再来看看 <code>insertSpace</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSpace</span>(<span class="params">child: React.ReactChild, needInserted: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check the child if is undefined or null.</span></span><br><span class="line">  <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要添加空格时设为空格</span></span><br><span class="line">  <span class="keyword">const</span> SPACE = needInserted ? <span class="string">' '</span> : <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// strictNullChecks oops.</span></span><br><span class="line">  <span class="comment">// 非严格意义检查，实际上判断的是这种情况（所以才会说不是严格意义检查，权衡之计……）</span></span><br><span class="line">  <span class="comment">// &lt;Button&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;div&gt;你好啊&lt;/div&gt;</span></span><br><span class="line">  <span class="comment">// &lt;/Button&gt;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child !== <span class="string">'string'</span> &amp;&amp; <span class="keyword">typeof</span> child !== <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    isString(child.type) &amp;&amp; isTwoCNChar(child.props.children)) &#123;</span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(child, &#123;&#125;,</span><br><span class="line">      child.props.children.split(<span class="string">''</span>).join(SPACE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断组件中文本是不是中文</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTwoCNChar(child)) &#123;</span><br><span class="line">      child = child.split(<span class="string">''</span>).join(SPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;span&gt;&#123;child&#125;&lt;<span class="regexp">/span&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return child;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h1><p>接下来的逻辑比较简单，不需要过多的讲解了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="keyword">import</span> omit <span class="keyword">from</span> <span class="string">'omit.js'</span>;</span><br><span class="line"><span class="keyword">import</span> Icon <span class="keyword">from</span> <span class="string">'../icon'</span>;</span><br><span class="line"><span class="keyword">import</span> Group <span class="keyword">from</span> <span class="string">'./button-group'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rxTwoCNChar = <span class="regexp">/^[\u4e00-\u9fa5]&#123;2&#125;$/</span>;</span><br><span class="line"><span class="keyword">const</span> isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">str: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> str === <span class="string">'string'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert one space between two chinese characters automatically.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSpace</span>(<span class="params">child: React.ReactChild, needInserted: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check the child if is undefined or null.</span></span><br><span class="line">  <span class="keyword">if</span> (child == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> SPACE = needInserted ? <span class="string">' '</span> : <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// strictNullChecks oops.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child !== <span class="string">'string'</span> &amp;&amp; <span class="keyword">typeof</span> child !== <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    isString(child.type) &amp;&amp; isTwoCNChar(child.props.children)) &#123;</span><br><span class="line">    <span class="keyword">return</span> React.cloneElement(child, &#123;&#125;,</span><br><span class="line">      child.props.children.split(<span class="string">''</span>).join(SPACE));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTwoCNChar(child)) &#123;</span><br><span class="line">      child = child.split(<span class="string">''</span>).join(SPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &lt;span&gt;&#123;child&#125;&lt;<span class="regexp">/span&gt;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  return child;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export type ButtonType = 'primary' | 'ghost' | 'dashed' | 'danger';</span></span><br><span class="line"><span class="regexp">export type ButtonShape = 'circle' | 'circle-outline';</span></span><br><span class="line"><span class="regexp">export type ButtonSize = 'small' | 'default' | 'large';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export interface ButtonProps &#123;</span></span><br><span class="line"><span class="regexp">  type?: ButtonType;</span></span><br><span class="line"><span class="regexp">  htmlType?: string;</span></span><br><span class="line"><span class="regexp">  icon?: string;</span></span><br><span class="line"><span class="regexp">  shape?: ButtonShape;</span></span><br><span class="line"><span class="regexp">  size?: ButtonSize;</span></span><br><span class="line"><span class="regexp">  onClick?: React.FormEventHandler&lt;any&gt;;</span></span><br><span class="line"><span class="regexp">  onMouseUp?: React.FormEventHandler&lt;any&gt;;</span></span><br><span class="line"><span class="regexp">  onMouseDown?: React.FormEventHandler&lt;any&gt;;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 后期添加，为了判断键盘点击事件</span></span><br><span class="line"><span class="regexp">  onKeyPress?: React.KeyboardEvent&lt;any&gt;;</span></span><br><span class="line"><span class="regexp">  onKeyDown?: React.KeyboardEvent&lt;any&gt;;</span></span><br><span class="line"><span class="regexp">  tabIndex?: number;</span></span><br><span class="line"><span class="regexp">  loading?: boolean | &#123; delay?: number &#125;;</span></span><br><span class="line"><span class="regexp">  disabled?: boolean;</span></span><br><span class="line"><span class="regexp">  style?: React.CSSProperties;</span></span><br><span class="line"><span class="regexp">  prefixCls?: string;</span></span><br><span class="line"><span class="regexp">  className?: string;</span></span><br><span class="line"><span class="regexp">  ghost?: boolean;</span></span><br><span class="line"><span class="regexp">  target?: string;</span></span><br><span class="line"><span class="regexp">  href?: string;</span></span><br><span class="line"><span class="regexp">  download?: string;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default class Button extends React.Component&lt;ButtonProps, any&gt; &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 为了方便写 Button.Group 来引用 ButtonGroup 这个组件</span></span><br><span class="line"><span class="regexp">  static Group: typeof Group;</span></span><br><span class="line"><span class="regexp">  static __ANT_BUTTON = true;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 组件默认属性</span></span><br><span class="line"><span class="regexp">  static defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    prefixCls: 'ant-btn',</span></span><br><span class="line"><span class="regexp">    loading: false,</span></span><br><span class="line"><span class="regexp">    ghost: false,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  static propTypes = &#123;</span></span><br><span class="line"><span class="regexp">    type: PropTypes.string,</span></span><br><span class="line"><span class="regexp">    shape: PropTypes.oneOf(['circle', 'circle-outline']),</span></span><br><span class="line"><span class="regexp">    size: PropTypes.oneOf(['large', 'default', 'small']),</span></span><br><span class="line"><span class="regexp">    htmlType: PropTypes.oneOf(['submit', 'button', 'reset']),</span></span><br><span class="line"><span class="regexp">    onClick: PropTypes.func,</span></span><br><span class="line"><span class="regexp">    loading: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),</span></span><br><span class="line"><span class="regexp">    className: PropTypes.string,</span></span><br><span class="line"><span class="regexp">    icon: PropTypes.string,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  timeout: number;</span></span><br><span class="line"><span class="regexp">  delayTimeout: number;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 内部需要使用的状态：点击状态，加载状态</span></span><br><span class="line"><span class="regexp">  constructor(props: ButtonProps) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      loading: props.loading,</span></span><br><span class="line"><span class="regexp">      clicked: false,</span></span><br><span class="line"><span class="regexp">      hasTwoCNChar: false,</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Fix for HOC usage like &lt;FormatMessage /</span>&gt;</span><br><span class="line">    <span class="keyword">const</span> buttonText = (findDOMNode(<span class="keyword">this</span>) <span class="keyword">as</span> HTMLElement).innerText;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isNeedInserted() &amp;&amp; isTwoCNChar(buttonText)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        hasTwoCNChar: <span class="literal">true</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新加载状态，传入的属性变化时对加载状态进行更新</span></span><br><span class="line">  componentWillReceiveProps(nextProps: ButtonProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentLoading = <span class="keyword">this</span>.props.loading;</span><br><span class="line">    <span class="keyword">const</span> loading = nextProps.loading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentLoading) &#123;</span><br><span class="line">      clearTimeout(<span class="keyword">this</span>.delayTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> loading !== <span class="string">'boolean'</span> &amp;&amp; loading &amp;&amp; loading.delay) &#123;</span><br><span class="line">      <span class="keyword">this</span>.delayTimeout = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; loading &#125;), loading.delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; loading &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.timeout) &#123;</span><br><span class="line">      clearTimeout(<span class="keyword">this</span>.timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delayTimeout) &#123;</span><br><span class="line">      clearTimeout(<span class="keyword">this</span>.delayTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理点击事件</span></span><br><span class="line">  handleClick = <span class="function">(<span class="params">e: React.MouseEvent&lt;HTMLButtonElement&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Add click effect</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; clicked: <span class="literal">true</span> &#125;);</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timeout);</span><br><span class="line">    <span class="keyword">this</span>.timeout = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; clicked: <span class="literal">false</span> &#125;), <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> onClick = <span class="keyword">this</span>.props.onClick;</span><br><span class="line">    <span class="keyword">if</span> (onClick) &#123;</span><br><span class="line">      onClick(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isNeedInserted() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; loading, icon, children &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> iconType = loading ? <span class="string">'loading'</span> : icon;</span><br><span class="line">    <span class="keyword">return</span> React.Children.count(children) === <span class="number">1</span> &amp;&amp; (!iconType || iconType === <span class="string">'loading'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">type</span>, shape, size, className, htmlType, children, icon, prefixCls, ghost, ...others,</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; loading, clicked, hasTwoCNChar &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// large =&gt; lg</span></span><br><span class="line">    <span class="comment">// small =&gt; sm</span></span><br><span class="line">    <span class="keyword">let</span> sizeCls = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'large'</span>:</span><br><span class="line">        sizeCls = <span class="string">'lg'</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'small'</span>:</span><br><span class="line">        sizeCls = <span class="string">'sm'</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ComponentProp = others.href ? <span class="string">'a'</span> : <span class="string">'button'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> classes = classNames(prefixCls, className, &#123;</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="keyword">type</span>,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;shape&#125;</span>`</span>]: shape,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-<span class="subst">$&#123;sizeCls&#125;</span>`</span>]: sizeCls,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-icon-only`</span>]: !children &amp;&amp; icon,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-loading`</span>]: loading,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-clicked`</span>]: clicked,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-background-ghost`</span>]: ghost,</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;prefixCls&#125;</span>-two-chinese-chars`</span>]: hasTwoCNChar,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> iconType = loading ? <span class="string">'loading'</span> : icon;</span><br><span class="line">    <span class="keyword">const</span> iconNode = iconType ? &lt;Icon <span class="keyword">type</span>=&#123;iconType&#125; /&gt; : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> kids = (children || children === <span class="number">0</span>)</span><br><span class="line">      ? React.Children.map(children, <span class="function"><span class="params">child</span> =&gt;</span> insertSpace(child, <span class="keyword">this</span>.isNeedInserted())) : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ComponentProp</span><br><span class="line">        &#123;...omit(others, [<span class="string">'loading'</span>])&#125;</span><br><span class="line">        <span class="keyword">type</span>=&#123;others.href ? <span class="literal">undefined</span> : (htmlType || <span class="string">'button'</span>)&#125;</span><br><span class="line">        className=&#123;classes&#125;</span><br><span class="line">        onClick=&#123;<span class="keyword">this</span>.handleClick&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;iconNode&#125;&#123;kids&#125;</span><br><span class="line">      &lt;<span class="regexp">/ComponentProp&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.im/post/59dfa57ef265da430e4e2a15" target="_blank" rel="noopener">antd源码解读（3）- Button</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;在调用 Button 组件时，组件内部是如何处理我们传入的这些状态的？&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（2）- Icon 组件</title>
    <link href="https://www.douglasdong.site/2018-10-03.html"/>
    <id>https://www.douglasdong.site/2018-10-03.html</id>
    <published>2018-10-03T02:07:30.000Z</published>
    <updated>2018-10-13T09:34:22.544Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h1><p><code>Icon</code> 组件作为日常开发中经常使用的组件，实现也相对简单很多，较为复杂的部分是自行制作 icon-font。这一部分可以在<a href="https://segmentfault.com/a/1190000008374352" target="_blank" rel="noopener">这篇文章</a>中找到相关信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="comment">// 特定条件下激活样式（处理事件触发的样式变化）</span></span><br><span class="line"><span class="keyword">import</span> classNames <span class="keyword">from</span> <span class="string">'classnames'</span>;</span><br><span class="line"><span class="comment">// 做一些删除操作的 npm 模块</span></span><br><span class="line"><span class="keyword">import</span> omit <span class="keyword">from</span> <span class="string">'omit.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IconProps 接口</span></span><br><span class="line"><span class="keyword">export</span> interface IconProps &#123;</span><br><span class="line">  type: string;</span><br><span class="line">  className?: string;</span><br><span class="line">  title?: string;</span><br><span class="line">  onClick?: React.MouseEventHandler&lt;any&gt;;</span><br><span class="line">  spin?: boolean;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Icon = <span class="function">(<span class="params">props: IconProps</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, className = <span class="string">''</span>, spin &#125; = props;</span><br><span class="line">  <span class="comment">// 调用 classNames 库进行样式拼接，先调用自带标准样式，后引入自定义样式</span></span><br><span class="line">  <span class="comment">// 返回完整的样式</span></span><br><span class="line">  <span class="keyword">const</span> classString = classNames(&#123;</span><br><span class="line">    <span class="comment">// 启动 icon 标准样式 anticon</span></span><br><span class="line">    anticon: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 判断 spin 是否为真？或者类似是否为 loading？为真时进行调用</span></span><br><span class="line">    <span class="string">'anticon-spin'</span>: !!spin || type === <span class="string">'loading'</span>,</span><br><span class="line">    <span class="comment">// 调用 type 所对应的样式</span></span><br><span class="line">    [<span class="string">`anticon-<span class="subst">$&#123;type&#125;</span>`</span>]: <span class="literal">true</span>,</span><br><span class="line">  &#125;, className);</span><br><span class="line">  <span class="comment">// 去除 type 和 spin 这两个 &lt;i&gt; 标签不支持的属性</span></span><br><span class="line">  <span class="comment">// html的&lt;i&gt;标签，其标准标签属性只有六种：id、class、title、style、dir、lang</span></span><br><span class="line">  <span class="comment">// type、spin不属于上述六种。onClick为事件属性，可以被调用</span></span><br><span class="line">  <span class="keyword">return</span> &lt;i &#123;...omit(props, ['type', 'spin'])&#125; className=&#123;classString&#125; /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Icon;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;AntD 中的组件有很多，我们先从最简单的 Icon 组件开始分析&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI99999" scheme="https://www.douglasdong.site/tags/Choerodon-UI99999/"/>
    
  </entry>
  
  <entry>
    <title>AntD/Choerodon-UI 源码分析（1）- index.js</title>
    <link href="https://www.douglasdong.site/2018-09-29.html"/>
    <id>https://www.douglasdong.site/2018-09-29.html</id>
    <published>2018-10-02T11:24:36.000Z</published>
    <updated>2018-10-08T03:30:01.859Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h1><p>分析一个项目的源码，首先应该从它的入口文件看起，所以我们需要先从项目中的 <code>index.js</code> 文件开始</p><h1 id="分析开始"><a href="#分析开始" class="headerlink" title="分析开始"></a>分析开始</h1><p>整个 <code>index.js</code> 只有 28 行代码，其中包含了一个 <code>camelCase</code> 函数，一个 <code>req</code> 变量，对 <code>req</code> 变量的操作和 <code>export</code> 操作。</p><p>通过追踪 <code>AntD</code> 的 <code>Gitlog</code> 提交记录，我们可以发现，<code>index.js</code> 这个文件进行过两次大的重构</p><h2 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h2><p><code>AntD</code> 的初始版本中，<code>index.js</code> 这个文件的引入和导出是完全手工操作的。由于项目初期规模并不是很大，因此初期尚能满足项目需要</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> antd = &#123;</span><br><span class="line">  Rate: <span class="built_in">require</span>(<span class="string">'./components/rate'</span>),</span><br><span class="line">  Affix: <span class="built_in">require</span>(<span class="string">'./components/affix'</span>),</span><br><span class="line">  DatePicker: <span class="built_in">require</span>(<span class="string">'./components/date-picker'</span>),</span><br><span class="line">  Tooltip: <span class="built_in">require</span>(<span class="string">'./components/tooltip'</span>),</span><br><span class="line">  Carousel: <span class="built_in">require</span>(<span class="string">'./components/carousel'</span>),</span><br><span class="line">  Tabs: <span class="built_in">require</span>(<span class="string">'./components/tabs'</span>),</span><br><span class="line">  Modal: <span class="built_in">require</span>(<span class="string">'./components/modal'</span>),</span><br><span class="line">  Dropdown: <span class="built_in">require</span>(<span class="string">'./components/dropdown'</span>),</span><br><span class="line">  Progress: <span class="built_in">require</span>(<span class="string">'./components/progress'</span>),</span><br><span class="line">  Popover: <span class="built_in">require</span>(<span class="string">'./components/popover'</span>),</span><br><span class="line">  Select: <span class="built_in">require</span>(<span class="string">'./components/select'</span>),</span><br><span class="line">  Breadcrumb: <span class="built_in">require</span>(<span class="string">'./components/breadcrumb'</span>),</span><br><span class="line">  Popconfirm: <span class="built_in">require</span>(<span class="string">'./components/popconfirm'</span>),</span><br><span class="line">  Pagination: <span class="built_in">require</span>(<span class="string">'./components/pagination'</span>),</span><br><span class="line">  Steps: <span class="built_in">require</span>(<span class="string">'./components/steps'</span>),</span><br><span class="line">  InputNumber: <span class="built_in">require</span>(<span class="string">'./components/input-number'</span>),</span><br><span class="line">  Switch: <span class="built_in">require</span>(<span class="string">'./components/switch'</span>),</span><br><span class="line">  Checkbox: <span class="built_in">require</span>(<span class="string">'./components/checkbox'</span>),</span><br><span class="line">  Table: <span class="built_in">require</span>(<span class="string">'./components/table'</span>),</span><br><span class="line">  Tag: <span class="built_in">require</span>(<span class="string">'./components/tag'</span>),</span><br><span class="line">  Collapse: <span class="built_in">require</span>(<span class="string">'./components/collapse'</span>),</span><br><span class="line">  message: <span class="built_in">require</span>(<span class="string">'./components/message'</span>),</span><br><span class="line">  Slider: <span class="built_in">require</span>(<span class="string">'./components/slider'</span>),</span><br><span class="line">  QueueAnim: <span class="built_in">require</span>(<span class="string">'./components/queue-anim'</span>),</span><br><span class="line">  Radio: <span class="built_in">require</span>(<span class="string">'./components/radio'</span>),</span><br><span class="line">  notification: <span class="built_in">require</span>(<span class="string">'./components/notification'</span>),</span><br><span class="line">  Alert: <span class="built_in">require</span>(<span class="string">'./components/alert'</span>),</span><br><span class="line">  Validation: <span class="built_in">require</span>(<span class="string">'./components/validation'</span>),</span><br><span class="line">  Tree: <span class="built_in">require</span>(<span class="string">'./components/tree'</span>),</span><br><span class="line">  TreeSelect: <span class="built_in">require</span>(<span class="string">'./components/tree-select'</span>),</span><br><span class="line">  Upload: <span class="built_in">require</span>(<span class="string">'./components/upload'</span>),</span><br><span class="line">  Badge: <span class="built_in">require</span>(<span class="string">'./components/badge'</span>),</span><br><span class="line">  Menu: <span class="built_in">require</span>(<span class="string">'./components/menu'</span>),</span><br><span class="line">  Timeline: <span class="built_in">require</span>(<span class="string">'./components/timeline'</span>),</span><br><span class="line">  Button: <span class="built_in">require</span>(<span class="string">'./components/button'</span>),</span><br><span class="line">  Icon: <span class="built_in">require</span>(<span class="string">'./components/icon'</span>),</span><br><span class="line">  Row: <span class="built_in">require</span>(<span class="string">'./components/row'</span>),</span><br><span class="line">  Col: <span class="built_in">require</span>(<span class="string">'./components/col'</span>),</span><br><span class="line">  Spin: <span class="built_in">require</span>(<span class="string">'./components/spin'</span>),</span><br><span class="line">  Form: <span class="built_in">require</span>(<span class="string">'./components/form'</span>),</span><br><span class="line">  Input: <span class="built_in">require</span>(<span class="string">'./components/input'</span>),</span><br><span class="line">  Calendar: <span class="built_in">require</span>(<span class="string">'./components/calendar'</span>),</span><br><span class="line">  TimePicker: <span class="built_in">require</span>(<span class="string">'./components/time-picker'</span>),</span><br><span class="line">  Transfer: <span class="built_in">require</span>(<span class="string">'./components/transfer'</span>),</span><br><span class="line">  Cascader: <span class="built_in">require</span>(<span class="string">'./components/cascader'</span>),</span><br><span class="line">  Card: <span class="built_in">require</span>(<span class="string">'./components/card'</span>),</span><br><span class="line">  LocaleProvider: <span class="built_in">require</span>(<span class="string">'./components/locale-provider'</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = antd;</span><br></pre></td></tr></table></figure><p>可以看到，这种方式在维护到后期时及其不方便，因此在 <code>css modularize (#1448)</code> 这一 <code>commit</code> 中引入了模块化 <code>CSS</code> 的概念</p><h2 id="第一次重构"><a href="#第一次重构" class="headerlink" title="第一次重构"></a>第一次重构</h2><p>这个版本中，移除了以前输出 <code>CSS</code> 所需要的 <code>style</code> 样式库，将样式库中的所有文件分散到了所有的组件中，方便对单独的组件进行管理</p><p>同时，在引入组件所需的 <code>CSS</code> 时，也不用手动输入路径了，只要输入相应的组件名即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this file is not used if use https://github.com/ant-design/babel-plugin-antd</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Rate, Affix, DatePicker, Tooltip, Carousel, Tabs, Modal, Dropdown, Progress, Popover, Select,</span><br><span class="line">  Breadcrumb, Popconfirm, Pagination, Steps, InputNumber, Switch, Checkbox, Table, Collapse, message,</span><br><span class="line">  Slider, QueueAnim, Radio, notification, Alert, Validation, Tree, TreeSelect, Upload,</span><br><span class="line">  Badge, Menu, Timeline, Button, Icon, Row, Col, Spin, Form, Input, Calendar, TimePicker,</span><br><span class="line">  Card, LocaleProvider, Transfer, Cascader,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy from above</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  Rate, Affix, DatePicker, Tooltip, Tag, Carousel, Tabs, Modal, Dropdown, Progress, Popover, Select,</span><br><span class="line">  Breadcrumb, Popconfirm, Pagination, Steps, InputNumber, Switch, Checkbox, Table, Collapse, message,</span><br><span class="line">  Slider, QueueAnim, Radio, notification, Alert, Validation, Tree, TreeSelect, Upload,</span><br><span class="line">  Badge, Menu, Timeline, Button, Icon, Row, Col, Spin, Form, Input, Calendar, TimePicker,</span><br><span class="line">  Card, LocaleProvider, Transfer, Cascader,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这种引入方法依旧不太方便，我们还是需要在每次新增组件的时候手动添加组件的名字，因此就有了第二次的重构 <code>fix index</code></p><h2 id="第二次重构"><a href="#第二次重构" class="headerlink" title="第二次重构"></a>第二次重构</h2><p>第二次重构中，对这些文件的引用做了自动化处理，我们主要通过 <code>require.context</code> 对文件进行筛选，从中选出我们需要的文件进行自动重命名，并进行输出，相对于上一版本来说有了很大提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelCase</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name.charAt(<span class="number">0</span>).toUpperCase() +</span><br><span class="line">    name.slice(<span class="number">1</span>).replace(<span class="regexp">/-(\w)/g</span>, (m, n) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> n.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">'./components'</span>, <span class="literal">true</span>, /^\.\/[^_][\w-]+\/(style\/)?index\.jsx?$/);</span><br><span class="line"></span><br><span class="line">req.keys().forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> v = req(mod);</span><br><span class="line">  <span class="keyword">const</span> match = mod.match(<span class="regexp">/^\.\/([^_][\w-]+)\/index\.jsx?$/</span>);</span><br><span class="line">  <span class="keyword">if</span> (match &amp;&amp; match[<span class="number">1</span>]) &#123;</span><br><span class="line">    exports[camelCase(match[<span class="number">1</span>])] = v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这一版本的代码还是存在一些 BUG，因此在 <code>3.2.1</code> 前又进行了一些 FIX 操作</p><h2 id="Final-Version"><a href="#Final-Version" class="headerlink" title="Final Version"></a>Final Version</h2><p>这一版本引入了 <code>Typescript</code>，同时修复了 <code>Issue #1968</code> 中的相关问题，保留了默认的组件导出方式 <code>module.exports</code>，以修复 <code>#3745</code> 这一 <code>Issue</code> 中提到的没有 <code>CSS</code> 文件输出的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES-Lint 自定配置，禁止调用 console</span></span><br><span class="line"><span class="comment">/* eslint no-console:0 */</span></span><br><span class="line"><span class="comment">// 驼峰大小写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelCase</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首字母大写</span></span><br><span class="line">  <span class="keyword">return</span> name.charAt(<span class="number">0</span>).toUpperCase() +</span><br><span class="line">    <span class="comment">//取出 [1] 之后的字符作为数组</span></span><br><span class="line">    <span class="comment">//判断每个字符是否符合 -w 这个匹配模式（access-bin=&gt;Access-Bin），符合的进行大写处理</span></span><br><span class="line">    name.slice(<span class="number">1</span>).replace(<span class="regexp">/-(\w)/g</span>, (m, n) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> n.toUpperCase();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Just import style for https://github.com/ant-design/ant-design/issues/3745</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（创建了）一个包含了 components 文件夹（含子目录）下面的、所有路径符合 `/style/test/index.tsx` 模式的、能被 require 请求到的文件的上下文，返回值为一个函数</span></span><br><span class="line"><span class="comment">// 遍历项目在 component 下的组件样式</span></span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">'./components'</span>, <span class="literal">true</span>, /^\.\/[^_][\w-]+\/style\/index\.tsx?$/);</span><br><span class="line"></span><br><span class="line"><span class="comment">// req.keys =&gt; 所有符合 req 定义模式的目录，类型为数组</span></span><br><span class="line"><span class="comment">// 这一部分都是用来输出 dist 文件中的 css 的</span></span><br><span class="line">req.keys().forEach(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果存在 default 入口，则定义 default 为输出</span></span><br><span class="line">  <span class="keyword">let</span> v = req(mod);</span><br><span class="line">  <span class="keyword">if</span> (v &amp;&amp; v.default) &#123;</span><br><span class="line">    v = v.default;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 抛出组件 这个正则是匹配当前目录下的所有 index.tsx 文件</span></span><br><span class="line">  <span class="comment">// 目标是为了遍历样式库下的文件夹，取出需要的样式文件</span></span><br><span class="line">  <span class="keyword">const</span> match = mod.match(<span class="regexp">/^\.\/([^_][\w-]+)\/index\.tsx?$/</span>);</span><br><span class="line">  <span class="keyword">if</span> (match &amp;&amp; match[<span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="comment">// 修复 Bug -- #1968 中错误将 message 和 notification 至为首字母大写的错误</span></span><br><span class="line">    <span class="keyword">if</span> (match[<span class="number">1</span>] === <span class="string">'message'</span> || match[<span class="number">1</span>] === <span class="string">'notification'</span>) &#123;</span><br><span class="line">      <span class="comment">// message &amp; notification should not be capitalized</span></span><br><span class="line">      exports[match[<span class="number">1</span>]] = v;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在 export 中添加需要的键</span></span><br><span class="line">      exports[camelCase(match[<span class="number">1</span>])] = v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// keep index.js as an entry =&gt; Styles should be exported as well</span></span><br><span class="line"><span class="comment">// 上一部分是输出样式的，这一部分是输出组件的</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./components'</span>);</span><br></pre></td></tr></table></figure><p>要理解最终版本的源代码，我们需要了解以下两个小知识点才能继续</p><h3 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h3><p><code>require.context</code> 是 <code>WebPack</code> 提供的一种方法，可以让我们创建自己的模块上下文，其中包含三个参数</p><ul><li>要搜索的文件夹目录</li><li>是否还应该搜索它的子目录</li><li>一个匹配文件的正则表达式</li></ul><blockquote><p>一个上下文模块导出一个（require）函数，这个函数可以接收一个参数：request。</p></blockquote><p>导出的方法有 3 个属性：<code>resolve</code>，<code>keys</code>，<code>id</code></p><ul><li>resolve 是一个函数，它返回请求被解析后得到的模块 id</li><li>keys 也是一个函数，它返回一个数组，包含所有匹配自定义正则表达式的结果</li><li>id 是上下文模块里面所包含的模块 id. 它可能在你使用 module.hot.accept 的时候被用到</li></ul><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p><code>exports</code> 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋予 <code>module.exports</code> 的值。</p><p>它有一个快捷方式，以便 <code>module.exports.f = ...</code> 可以被更简洁地写成 <code>exports.f = ...</code>。 注意，就像任何变量，如果一个新的值被赋值给 <code>exports</code>，它就不再绑定到 <code>module.exports</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.hello = <span class="literal">true</span>; <span class="comment">// 从对模块的引用中导出</span></span><br><span class="line">exports = &#123; <span class="attr">hello</span>: <span class="literal">false</span> &#125;;  <span class="comment">// 不导出，只在模块内有效</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>index.js</code> 整体就是为了在执行 <code>dist</code> 时导出各个组件中的 <code>CSS</code> 样式，以及在被作为库调用的时候输出相应的组件。这一部分源码中，对于 <code>export</code> 和 <code>module.export</code> 部分依然不能理解透彻，有待于进行进一步的底层分析</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;AntD 是十分优秀的前端项目，研究它的组件书写方式对今后 React 组件的书写非常有帮助，因此本系列将以 AntD 3.2.1 版本为基础，逐步分析其中的源代码&lt;/center&gt;
    
    </summary>
    
      <category term="AntD 源码分析" scheme="https://www.douglasdong.site/categories/AntD-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
      <category term="AntD" scheme="https://www.douglasdong.site/tags/AntD/"/>
    
      <category term="Choerodon-UI" scheme="https://www.douglasdong.site/tags/Choerodon-UI/"/>
    
  </entry>
  
  <entry>
    <title>浅谈浏览器常用优化方法</title>
    <link href="https://www.douglasdong.site/2018-08-15.html"/>
    <id>https://www.douglasdong.site/2018-08-15.html</id>
    <published>2018-08-15T08:47:11.000Z</published>
    <updated>2018-10-04T06:12:35.113Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>前端性能优化是一个深度与广度都极广的话题，如果想要深入了解其中的每个细节，没有 3-5 年以上的开发经验是无法做到的。因此，本文仅仅探讨一些前端优化的大体方向，与前端优化中较为基本的实现点</p><h1 id="性能优化原则与方向"><a href="#性能优化原则与方向" class="headerlink" title="性能优化原则与方向"></a>性能优化原则与方向</h1><p>性能优化的原则是以实现更好的用户体验为标准，具体就是实现以下的目标：</p><ol><li>多使用内存、缓存和其他方法</li><li>减少 CPU 和 GPU 运算，更快展现</li></ol><p>优化的方向有两个：</p><ol><li>减少页面体积，提升网络加载速度</li><li>优化页面渲染</li></ol><h1 id="减少页面体积，提升网络加载速度"><a href="#减少页面体积，提升网络加载速度" class="headerlink" title="减少页面体积，提升网络加载速度"></a>减少页面体积，提升网络加载速度</h1><h2 id="静态资源的压缩合并"><a href="#静态资源的压缩合并" class="headerlink" title="静态资源的压缩合并"></a>静态资源的压缩合并</h2><p>如果不合并，每个都会走一遍 HTTP 请求过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"b.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"c.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果合并了，就只走一遍请求过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>PS：Head of line blocking 是 HTTP 1.0 的最大性能瓶颈所在，静态资源压缩合并就是为了应对这一问题而产生的。而在最新的 HTTP2.0 中，这一问题已被多路复用很好的解决。</p><h2 id="静态资源缓存"><a href="#静态资源缓存" class="headerlink" title="静态资源缓存"></a>静态资源缓存</h2><p>通过链接名称控制缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"abc_1.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>只有内容改变的时候，链接名称才会改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"abc_2.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这个名称不用手动改，可通过前端构建工具根据文件内容，为文件名称添加 MD5 后缀。</p><p>这一部分的优化可能主要取决于服务器端，前端能做的非常有限，后期在深入讲解的时候会做详细讨论</p><h2 id="使用-CDN-让资源加载更快"><a href="#使用-CDN-让资源加载更快" class="headerlink" title="使用 CDN 让资源加载更快"></a>使用 CDN 让资源加载更快</h2><p>CDN 会提供专业的加载优化方案，静态资源要尽量放在 CDN 上，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/zepto/1.0rc1/zepto.min.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="优化页面渲染"><a href="#优化页面渲染" class="headerlink" title="优化页面渲染"></a>优化页面渲染</h1><p>谈这部分之前，我们先来谈谈页面在浏览器的渲染流程</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>页面渲染要点如下：</p><ul><li>根据 HTML 结构生成 DOM 树</li><li>根据 CSS 生成 CSSOM</li><li>将 DOM 和 CSSOM 整合形成 RenderTree</li><li>根据 RenderTree 开始渲染和展示</li><li>遇到 <code>&lt;script&gt;</code> 时，会执行并阻塞渲染</li></ul><p>上文中，浏览器已经拿到了 server 端返回的 HTML 内容，开始解析并渲染。最初拿到的内容就是一堆字符串，必须先结构化成计算机擅长处理的基本数据结构，因此要把 HTML 字符串转化成 DOM 树 —— 树是最基本的数据结构之一。</p><p>解析过程中，如果遇到 <code>&lt;link href=&quot;...&quot;&gt;</code> 和 <code>&lt;script src=&quot;...&quot;&gt;</code> 这种外链加载 CSS 和 JS 的标签，浏览器会异步下载，下载过程和上文中下载 HTML 的流程一样。只不过，这里下载下来的字符串是 CSS 或者 JS 格式的。</p><p>浏览器将 CSS 生成 CSSOM，再将 DOM 和 CSSOM 整合成 RenderTree ，然后针对 RenderTree 即可进行渲染了</p><h2 id="CSS-放前面，JavaScript-放后面"><a href="#CSS-放前面，JavaScript-放后面" class="headerlink" title="CSS 放前面，JavaScript 放后面"></a>CSS 放前面，JavaScript 放后面</h2><p>为何要将 CSS 放在网站头部？因为页面需要 CSS 生成 RenderTree，如果放在页面最后，页面会先根据默认选项渲染出 RenderTree</p><p>等到加载到页面最后的 CSS 时，浏览器需要重新生成 CSSOM，再 DOM 配合生成 RenderTree，这一点可能会导致渲染卡顿的情况，影响页面浏览体验。而放在开头就能避免这种问题</p><p>为何要将 JavaScript 放在最后？因为 JavaScript 的加载是阻塞渲染的，浏览器必须要先执行完 JavaScript 后才能继续渲染工作。因此，为了不阻塞渲染，让用户先看到内容，就会把 JavaScript放在页面最后执行。</p><p>另外，JavaScript 执行如果涉及 DOM 操作，得等待 DOM 解析完成才行，JavaScript 放在底部执行时，HTML 肯定都解析成了 DOM 结构。如果放在 HTML 顶部，执行的时候 HTML 还没来得及转换为 DOM 结构，可能会报错。</p><h2 id="懒加载（图片懒加载）"><a href="#懒加载（图片懒加载）" class="headerlink" title="懒加载（图片懒加载）"></a>懒加载（图片懒加载）</h2><p>一开始先将 <code>src</code> 赋值为一个通用的预览图，下拉的时候再动态赋值成正式的图片。如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"preview.png"</span> data-realsrc=<span class="string">"abc.png"</span>/&gt;</span><br></pre></td></tr></table></figure><p><code>preview.png</code> 是预览图片，比较小，加载很快，而且很多图片都共用这个 <code>preview.png</code>，加载一次即可。待页面下拉，图片显示出来时，再去替换 <code>src</code> 为 <code>data-realsrc</code> 的值。</p><p>另外，这里为何要用 <code>data-</code> 开头的属性值？—— 所有 HTML 中自定义的属性，都应该用 <code>data-</code> 开头，因为 <code>data-</code> 开头的属性浏览器渲染的时候会忽略掉，提高渲染性能。</p><h2 id="减少-DOM-查询，对-DOM-查询做缓存"><a href="#减少-DOM-查询，对-DOM-查询做缓存" class="headerlink" title="减少 DOM 查询，对 DOM 查询做缓存"></a>减少 DOM 查询，对 DOM 查询做缓存</h2><p>两段代码作为对比：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>)  <span class="comment">// 只查询一个 DOM ，缓存在 pList 中了</span></span><br><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pList.length; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>).length; i++) &#123;  <span class="comment">// 每次循环，都会查询 DOM ，耗费性能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DOM 操作，无论是查找还是修改，都是非常消耗性能的，应该尽量减少</p><h2 id="减少-DOM-操作，多个操作尽量合并在一起执行（DocumentFragment）"><a href="#减少-DOM-操作，多个操作尽量合并在一起执行（DocumentFragment）" class="headerlink" title="减少 DOM 操作，多个操作尽量合并在一起执行（DocumentFragment）"></a>减少 DOM 操作，多个操作尽量合并在一起执行（<code>DocumentFragment</code>）</h2><p>DOM 操作是非常耗费性能的，因此插入多个标签时，先插入 Fragment 然后再统一插入 DOM。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> listNode = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>)</span><br><span class="line"><span class="comment">// 要插入 10 个 li 标签</span></span><br><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">var</span> x, li;</span><br><span class="line"><span class="keyword">for</span>(x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">    li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"List item "</span> + x;</span><br><span class="line">    frag.appendChild(li);  <span class="comment">// 先放在 frag 中，最后一次性插入到 DOM 结构中。</span></span><br><span class="line">&#125;</span><br><span class="line">listNode.appendChild(frag);</span><br></pre></td></tr></table></figure><h2 id="事件节流"><a href="#事件节流" class="headerlink" title="事件节流"></a>事件节流</h2><p>例如要在文字改变的时候触发一个 <code>change</code> 事件，通过 <code>keyup</code> 来监听，使用节流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>)</span><br><span class="line"><span class="keyword">var</span> timeoutId</span><br><span class="line">textarea.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeoutId) &#123;</span><br><span class="line">        clearTimeout(timeoutId)</span><br><span class="line">    &#125;</span><br><span class="line">    timeoutId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 触发 change 事件</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="尽早执行操作（DOMContented）"><a href="#尽早执行操作（DOMContented）" class="headerlink" title="尽早执行操作（DOMContented）"></a>尽早执行操作（DOMContented）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 页面的全部资源加载完才会执行，包括图片、视频等</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 渲染完即可执行，此时图片、视频还可能没有加载完</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文对于前端的优化做了一些粗浅的解读，后续还会更新文章做进一步的完善</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/book/5a8f9ddcf265da4e9f6fb959/section/5a8f9f7bf265da4e82635e46" target="_blank" rel="noopener">Web 前端面试指南与高频考题解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;如何优化开发完成的前端项目？使之在浏览器中的加载速度更快？从而达成更好的用户体验？&lt;/center&gt;
    
    </summary>
    
      <category term="前端" scheme="https://www.douglasdong.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://www.douglasdong.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Cookie、Session、LocalStorage、SessionStorage 详解</title>
    <link href="https://www.douglasdong.site/2018-08-14.html"/>
    <id>https://www.douglasdong.site/2018-08-14.html</id>
    <published>2018-08-14T04:58:20.000Z</published>
    <updated>2018-10-04T06:12:46.124Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p>由于 HTTP 协议是无状态的，而服务器端的业务又必须是有状态的。<code>cookie</code> 诞生的最初目的是为了存储 Web 中的状态信息，以方便服务器使用。比如判断用户是否第一次访问网站</p><p><code>Cookie</code> 的处理分为：</p><ul><li>服务器向客户端发送 <code>cookie</code></li><li>浏览器将 <code>cookie</code> 保存</li><li>之后每次 HTTP 请求，浏览器都会将 <code>cookie</code> 发送给服务器端</li></ul><h2 id="Cookie-是什么？"><a href="#Cookie-是什么？" class="headerlink" title="Cookie 是什么？"></a>Cookie 是什么？</h2><p><code>cookie</code> 是小甜饼的意思。顾名思义，<code>cookie</code> 确实非常小，它的大小限制为 4KB 左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。</p><p><code>cookie</code> 就是浏览器储存在用户电脑上的一小段文本文件，是纯文本格式，不包含任何可执行的代码。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 <code>cookie</code> 中存入一段辨别用户身份的数据来实现的。</p><h2 id="Cookie-的存储大小是多少？"><a href="#Cookie-的存储大小是多少？" class="headerlink" title="Cookie 的存储大小是多少？"></a>Cookie 的存储大小是多少？</h2><p>每个 <code>cookie</code> 的大小一般不能超过4KB，超过这个长度的 <code>cookie</code> 将被忽略，不会被设置。</p><h2 id="服务器端的发送和解析"><a href="#服务器端的发送和解析" class="headerlink" title="服务器端的发送和解析"></a>服务器端的发送和解析</h2><h3 id="发送-Cookie"><a href="#发送-Cookie" class="headerlink" title="发送 Cookie"></a>发送 Cookie</h3><p>服务器端向客户端发送 <code>cookie</code> 是通过 HTTP 响应报文实现的，在 <code>Set-cookie</code> 中设置需要向客户端发送的 <code>cookie</code>，<code>cookie</code> 主要构成如下：</p><ul><li><code>name</code>：一个唯一确定的 <code>cookie</code> 名称，通常来说 <code>cookie</code> 的名称是不区分大小写的</li><li><code>value</code>：存储在 <code>cookie</code> 中的字符串值，最好为 <code>cookie</code> 的 <code>name</code> 和 <code>value</code> 进行 <code>url 编码</code></li><li><code>domain</code>：<code>cookie</code> 对于哪个域是有效的，所有向该域发送的请求中都会包含这个 <code>cookie</code> 信息，这个值可以包含子域，也可以不包含它</li><li><code>path</code>：表示这个 <code>cookie</code> 影响到的路径，浏览器会根据这项配置，向指定域中匹配的路径发送 <code>cookie</code></li><li><code>expires</code>：失效时间，表示 <code>cookie</code> 何时应该被删除的时间戳，如果不设置这个时间戳，浏览器会在页面关闭时即将删除所有 <code>cookie</code>；不过也可以自己设置删除时间。这个值是 GMT 时间格式，如果客户端和服务器端时间不一致，使用 <code>expires</code> 就会存在偏差。</li><li><code>max-age</code>：同样表示失效时间，用来告诉浏览器此 <code>cookie</code> 多少秒后过期，而不是一个固定的时间点（由于各地之间存在时差问题，因此惯用 <code>max-age</code>，而不是 <code>expire</code></li><li><code>HttpOnly</code>：告知浏览器不允许通过脚本 <code>document.cookie</code> 去更改这个值，同样这个值在 <code>document.cookie</code> 也不可见，但是在 HTTP 请求中还是会携带这个 <code>cookie</code>。注意这个值虽然在脚本中不可获取，但仍然在浏览器安装目录中以文件形式存在。</li><li><code>secure</code>：安全标志，指定后，只有在使用 SSL 链接时候才能发送到服务器，如果是 HTTP 链接则不会传递该信息。就算设置了 <code>secure</code> 属性也并不代表他人不能看到你机器本地保存的 <code>cookie</code> 信息，所以不要把重要信息放 <code>cookie</code> 就对了</li></ul><p>示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'status'</span>, <span class="string">'200 OK'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Set-Cookie'</span>, </span><br><span class="line">        <span class="string">'</span></span><br><span class="line"><span class="string">        isVisit=true;</span></span><br><span class="line"><span class="string">        domain=.yourdomain.com;</span></span><br><span class="line"><span class="string">        path=/;</span></span><br><span class="line"><span class="string">        max-age=1000</span></span><br><span class="line"><span class="string">        '</span></span><br><span class="line">    );</span><br><span class="line">    res.write(<span class="string">'Hello World'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'running localhost:8888'</span>)</span><br></pre></td></tr></table></figure><h3 id="解析-cookie"><a href="#解析-cookie" class="headerlink" title="解析 cookie"></a>解析 cookie</h3><p>cookie可以设置不同的域与路径，所以对于同一个name value，在不同域不同路径下是可以重复的，浏览器会按照与当前请求url或页面地址最佳匹配的顺序来排定先后顺序 </p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-14-1.png" alt="1"></p><p>所以当前端传递到服务器端的cookie有多个重复name value时，我们只需要最匹配的那个，也就是第一个。服务器端解析代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parse = <span class="function"><span class="keyword">function</span>(<span class="params">cstr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cstr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> dec = <span class="built_in">decodeURIComponent</span>;</span><br><span class="line">    <span class="keyword">var</span> cookies = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> parts = cstr.split(<span class="regexp">/\s*;\s*/g</span>);</span><br><span class="line">    parts.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> pos = p.indexOf(<span class="string">'='</span>);</span><br><span class="line">        <span class="comment">// name 与value存入cookie之前，必须经过编码</span></span><br><span class="line">        <span class="keyword">var</span> name = pos &gt; <span class="number">-1</span> ? dec(p.substr(<span class="number">0</span>, pos)) : p;</span><br><span class="line">        <span class="keyword">var</span> val = pos &gt; <span class="number">-1</span> ? dec(p.substr(pos + <span class="number">1</span>)) : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//只需要拿到最匹配的那个</span></span><br><span class="line">        <span class="keyword">if</span> (!cookies.hasOwnProperty(name)) &#123;</span><br><span class="line">            cookies[name] = val;</span><br><span class="line">        &#125;<span class="comment">/* else if (!cookies[name] instanceof Array) &#123;</span></span><br><span class="line"><span class="comment">            cookies[name] = [cookies[name]].push(val);</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            cookies[name].push(val);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cookies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端的存取"><a href="#客户端的存取" class="headerlink" title="客户端的存取"></a>客户端的存取</h3><p>浏览器将后台传递过来的 <code>cookie</code> 进行管理，并且允许开发者在 JavaScript 中使用 <code>document.cookie</code> 来存取 <code>cookie</code>。但是这个接口使用起来非常蹩脚，它会因为使用它的方式不同而表现出不同的行为。</p><ul><li>当用来获取属性值时，<code>document.cookie</code> 返回当前页面可用的（<code>根据cookie的域、路径、失效时间和安全设置</code>）所有的字符串，字符串的格式如下：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"name1=value1;name2=value2;name3=value3"</span>;</span><br></pre></td></tr></table></figure><ul><li>当用来设置值的时候，<code>document.cookie</code> 属性可设置为一个新的 <code>cookie</code> 字符串。这个字符串会被解释并添加到现有的 <code>cookie</code> 集合中。如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"_fa=aaaffffasdsf; domain=.dojotoolkit.org; path=/"</span>;</span><br></pre></td></tr></table></figure><p><strong>设置 <code>document.cookie</code> 并不会覆盖 <code>cookie</code>，除非设置的 <code>name value domain path</code> 都与一个已存在 <code>cookie</code> 重复。</strong></p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p><code>cookie</code> 被存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。而Session 出现的主要诉求在于解决一个问题：如何以既安全、又方便的方式全局读取信息呢？</p><h2 id="Session-与-Cookie-之间的区别和联系"><a href="#Session-与-Cookie-之间的区别和联系" class="headerlink" title="Session 与 Cookie 之间的区别和联系"></a>Session 与 Cookie 之间的区别和联系</h2><p>让我们举几个例子来描述 <code>cookie</code> 和 <code>session</code> 机制之间的区别和联系：</p><p>一家咖啡店有喝 5 杯咖啡免费赠一杯咖啡的优惠，然而一次性消费 5 杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p><ol><li>该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </li><li>发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态（<code>cookie</code>）。 </li><li>发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态（<code>session</code>）。 </li></ol><p>由于 HTTP 协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说，<code>cookie</code> 机制采用的是在客户端保持状态的方案，而 <code>session</code> 机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 <strong><code>session</code> 机制可能需要借助于 <code>cookie</code> 机制来达到保存标识的目的，但实际上它还有其他选择</strong>。 </p><h2 id="理解-Session-机制"><a href="#理解-Session-机制" class="headerlink" title="理解 Session 机制"></a>理解 Session 机制</h2><p><code>session</code> 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 </p><p>当程序需要为某个客户端的请求创建一个 <code>session</code> 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 <code>session</code> 标识 - 称为 <code>session id</code>。</p><p>如果已包含一个 <code>session id</code> 则说明以前已经为此客户端创建过 <code>session</code>，服务器就按照 <code>session id</code> 把这个 <code>session</code> 检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含 <code>session id</code>，则为此客户端创建一个 <code>session</code> 并且生成一个与此 <code>session</code> 相关联的 <code>session id</code>。</p><p><code>session id</code> 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 <code>session id</code> 将被在本次响应中返回给客户端保存。 保存这个 <code>session id</code> 的方式可以采用 <code>cookie</code>，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。一般这个 <code>cookie</code> 的名字都是类似于 <code>SEEESIONID</code>。</p><p>比如 <code>weblogic</code> 对于 web 应用程序生成的 <code>cookie</code>：<code>JSESSIONID=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code>，它的名字就是 <code>JSESSIONID</code>。  </p><p>由于 <code>cookie</code> 可以被人为的禁止，必须有其他机制以便在 <code>cookie</code> 被禁止时仍然能够把 <code>session id</code> 传递回服务器。经常被使用的一种技术叫做 <code>URL 重写</code>，就是把 <code>session id</code> 直接附加在 URL 路径的后面。</p><p>附加方式也有两种，一种是作为 URL 路径的附加信息，表现形式为 <code>http://...../xxx;jsessionid=ByOK ... 99zWpBng!-145788764</code> </p><p>另一种是作为查询字符串附加在URL后面，表现形式为 <code>http://...../xxx?jsessionid=ByOK ... 99zWpBng!-145788764</code></p><p>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把 <code>session id</code> 的信息和正常程序参数区分开来。 </p><p>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个 <code>session id</code>。 </p><h2 id="cookie-的局限性"><a href="#cookie-的局限性" class="headerlink" title="cookie 的局限性"></a>cookie 的局限性</h2><ul><li>存储量太小，只有 4kb</li><li>所有 HTTP 请求都会带着 <code>cookie</code>，影响获取资源的效率</li><li>API 简单，需要进行进一步封装才能使用</li></ul><h1 id="LocalStorage-和-SessionStorage"><a href="#LocalStorage-和-SessionStorage" class="headerlink" title="LocalStorage 和 SessionStorage"></a>LocalStorage 和 SessionStorage</h1><p>HTML 5 标准带来了 <code>LocalStorage</code> 和 <code>SessionStorage</code>，它们是为了专门解决 <code>cookie</code> 的局限性而设计的。先来介绍 <code>LocalStorage</code></p><h2 id="LocalStorage-与-SessionStorage"><a href="#LocalStorage-与-SessionStorage" class="headerlink" title="LocalStorage 与 SessionStorage"></a>LocalStorage 与 SessionStorage</h2><p><code>LocalStorage</code> 是 HTML5 提供的一个 API，<code>LocalStorage</code> 的本质是一个哈希</p><p><code>Session</code> 是服务器的哈希表，而 <code>LocalStorage</code> 是浏览器的哈希表</p><p><code>LocalStorage</code> 只能存字符串，它的值实质上是存在本地的。</p><p>与 <code>cookie</code> 的区别：</p><ul><li><code>LocalStorage</code> 与 HTTP 无关</li><li>HTTP 每次请求不会带上 <code>LocalStorage</code> 的值</li><li>只有相同域名的页面才能互相读取 <code>LocalStorage</code>（这个功能由浏览器完善）</li><li>每个域名 <code>LocalStorage</code> 最大存储量为 5MB 左右，每个浏览器不一样</li><li><code>LocalStorage</code> 永久有效，除非清除</li><li>拥有比 <code>cookie</code> 好用的多的 API：<code>localStorage.setItem(key, value)</code> <code>localStorage.getItem(key)</code></li></ul><p>与 <code>SessionStorage</code> 的区别：</p><ul><li><code>SessionStorage</code> 在用户关闭页面后就会失效</li></ul><p><code>LocalStorage</code> 和 <code>SessionStorage</code> 之间的区别主要是为了应对不同的使用场景，例如，一些需要及时失效的重要信息放在 <code>SessionStorage</code> 中，一些不重要但是不经常设置的信息，放在 <code>LocalStorage</code> 中。</p><p>另外告诉大家一个小技巧，针对 <code>localStorage.setItem</code>，使用时尽量加入到 <code>try-catch</code> 中，某些浏览器（IE）是禁用这个 API 的，要注意。</p><h2 id="LocalStorage-与-SessionStorage-的局限"><a href="#LocalStorage-与-SessionStorage-的局限" class="headerlink" title="LocalStorage 与 SessionStorage 的局限"></a>LocalStorage 与 SessionStorage 的局限</h2><ul><li>浏览器的大小不统一，并且在IE8以上的IE版本才支持 <code>LocalStorage</code> 这个属性</li><li>目前所有的浏览器中都会把 <code>LocalStorage</code> 的值类型限定为 <code>String</code> 类型，这个在对我们日常比较常见的 JSON 对象类型需要一些转换</li><li><code>LocalStorage</code> 在浏览器的隐私模式下面是不可读取的</li><li><code>LocalStorage</code> 本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li><li><code>LocalStorage</code> 不能被爬虫抓取到</li><li>如果你的网站中有 XSS 的风险，它们就能对你的 <code>LocalStorage</code> 肆意妄为</li></ul><h1 id="面试题考察"><a href="#面试题考察" class="headerlink" title="面试题考察"></a>面试题考察</h1><blockquote><p><code>cookie</code> 与 <code>session</code> 有什么关系？</p><p>一般来说，<code>session</code> 是基于 <code>cookie</code> 实现的，<code>session</code> 依赖于 <code>cookie</code> 将 <code>session id</code> 发给客户端</p></blockquote><hr><blockquote><p><code>cookie</code> 与 <code>LocalStorage</code> 的区别？</p><p>最大的区别就是 HTTP 每次请求不会带上 <code>LocalStorage</code> 的值，但是会带上 <code>cookie</code> 的值</p></blockquote><hr><blockquote><p><code>LocalStorage</code> 与 <code>SessionStorage</code> 的区别？</p><p><code>SessionStorage</code> 在用户关闭页面后就会失效，而 <code>LocalStorage</code> 永久有效，除非清除</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文中我们探讨了 <code>cookie</code> 为何诞生，以及在其基础上发展而来的 <code>session</code>，它在 HTML5 时代的替代品：<code>LocalStorage</code> 和 <code>SessionStorage</code>。这也是在日常开发中时常被使用的一部分</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/book/5a8f9ddcf265da4e9f6fb959/section/5a8f9f1af265da4e777fbdef" target="_blank" rel="noopener">Web 前端面试指南与高频考题解析</a><br><a href="https://juejin.im/post/5b5d38065188251ace75d473#heading-4" target="_blank" rel="noopener">Session, LocalStorage ,Cache-Control</a><br><a href="http://www.cnblogs.com/st-leslie/p/5617130.html" target="_blank" rel="noopener">localStorage使用总结</a><br><a href="http://jerryzou.com/posts/cookie-and-web-storage/" target="_blank" rel="noopener">详说 Cookie, LocalStorage 与 SessionStorage</a><br><a href="https://blog.csdn.net/xiongzhengxiang/article/details/7533591" target="_blank" rel="noopener">session 是什么</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Cookie 为何诞生？为什么会有 Session？我们为什么需要 LocalStorage 和 SessionStorage？浏览器中应当如何应用它们？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://www.douglasdong.site/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>DOM 事件详解</title>
    <link href="https://www.douglasdong.site/2018-08-13.html"/>
    <id>https://www.douglasdong.site/2018-08-13.html</id>
    <published>2018-08-13T01:38:42.000Z</published>
    <updated>2018-10-04T06:12:53.199Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="什么是-DOM？"><a href="#什么是-DOM？" class="headerlink" title="什么是 DOM？"></a>什么是 DOM？</h1><p><code>DOM</code> 是 JavaScript 操作网页的接口，全称为 “文档对象模型”（Document Object Model），它由浏览器提供，作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）</p><p>浏览器会根据 <code>DOM</code> 模型，将结构化文档（比如 HTML 和 XML）解析成一系列的节点，再由这些节点组成一个<code>树状结构</code>（<code>DOM</code> tree）。所有的节点和最终的树状结构，都有规范的对外接口</p><p><code>DOM</code> 是一个接口规范，可以用各种语言实现。所以严格来说，<code>DOM</code> 不是 JavaScript 语法的一部分。但是 <code>DOM</code> 操作是 JavaScript 最常见的任务，离开了 <code>DOM</code>，JavaScript 就无法控制网页。另一方面，JavaScript 也是最常用于 <code>DOM</code> 操作的语言。（<code>wasm</code> 现在仍然不够成熟，等到 <code>wasm</code> 成熟的时候，可能就会见到 JavaScript 以外的开发语言了）</p><h1 id="DOM-是如何呈现的？"><a href="#DOM-是如何呈现的？" class="headerlink" title="DOM 是如何呈现的？"></a>DOM 是如何呈现的？</h1><p>HTML 是一个有既定标签标准的 <code>XML</code> 格式，标签的名字、层级关系和属性，都被标准化（否则浏览器无法解析）。同样，它也是一颗树</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is p<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们开发完成的 HTML 代码会保存到一个文档中（一般以 <code>.html</code> 或 <code>.htm</code> 结尾），文档放在服务器上。浏览器请求服务器，这个文档被返回。因此，最终浏览器拿到的只是一个文档而已，文档的内容就是 HTML 格式的代码。</p><p>但是浏览器要把这个文档的 HTML 按照标准渲染成一个页面，此时浏览器就需要将这堆代码处理成自己能理解的东西，也得处理成 JavaScript 能理解的东西，因为还得运行 JavaScript 修改页面内容</p><p>基于以上需求，浏览器就需要把 HTML 转变成 <code>DOM</code>，HTML 是一棵树，<code>DOM</code> 也是一棵树。对 <code>DOM</code> 的理解，可以暂时先抛开浏览器的内部因素，先从 JavaScript 着手，即可以认为 <code>DOM</code> 就是 JavaScript 能识别的 HTML 结构，一个普通的 JavaScript 对象或数组。</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-13-1.png" alt="1"></p><h1 id="DOM-操作方法"><a href="#DOM-操作方法" class="headerlink" title="DOM 操作方法"></a>DOM 操作方法</h1><p>既然 <code>DOM</code> 是一棵树，自然就会有操作这棵树的方法，下面是一些常用的 <code>DOM</code> 操作方法</p><h2 id="获取-DOM-元素"><a href="#获取-DOM-元素" class="headerlink" title="获取 DOM 元素"></a>获取 DOM 元素</h2><p>最常用的 <code>DOM API</code> 就是获取节点，其中常用的获取方法如下面代码示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 id 获取</span></span><br><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>) <span class="comment">// 元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 tagname 获取</span></span><br><span class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)  <span class="comment">// 集合</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 class 获取</span></span><br><span class="line"><span class="keyword">var</span> containerList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'container'</span>) <span class="comment">// 集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 CSS 选择器获取</span></span><br><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>) <span class="comment">// 集合</span></span><br></pre></td></tr></table></figure><h2 id="property-和-attribute"><a href="#property-和-attribute" class="headerlink" title="property 和 attribute"></a>property 和 attribute</h2><p><code>DOM</code> 节点本质上就是一个 JavaScript 对象，因此，如下列代码所示，<code>p</code> 可以有 <code>style</code> 属性，有 <code>className</code>、<code>nodeName</code>、<code>nodeType</code> 属性。注意，这些都是 JavaScript 的对象属性，是符合 JavaScript 语法标准的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(p.style.width); <span class="comment">//获取样式</span></span><br><span class="line">p.style.width = <span class="string">'100px'</span>; <span class="comment">//获取样式</span></span><br><span class="line"><span class="built_in">console</span>.log(p.className); <span class="comment">//获取 class</span></span><br><span class="line">p.className = <span class="string">'p1'</span>; <span class="comment">//修改 class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 nodeName 和 nodeType</span></span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName);</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeType);</span><br></pre></td></tr></table></figure><p><code>property</code> 的获取和修改，是直接改变 JavaScript 对象，而 <code>attribute</code> 是直接改变 HTML 的属性，两者有很大的区别。<code>attribute</code> 就是对 HTML 属性的 <code>Get</code> 和 <code>Set</code>，和 <code>DOM</code> 节点中 JavaScript 范畴的 <code>property</code> 没有关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">var</span> p = pList[<span class="number">0</span>]</span><br><span class="line">p.getAttribute(<span class="string">'data-name'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'data-name'</span>, <span class="string">'juejin'</span>)</span><br><span class="line">p.getAttribute(<span class="string">'style'</span>)</span><br><span class="line">p.setAttribute(<span class="string">'style'</span>, <span class="string">'font-size:30px;'</span>)</span><br></pre></td></tr></table></figure><p><strong><code>get 和 set Attribute 的时候，还会触发 DOM 的查询或重绘、重排，频繁操作会影响页面性能</code></strong></p><h2 id="新增节点"><a href="#新增节点" class="headerlink" title="新增节点"></a>新增节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新的节点</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">p1.innerHTML = <span class="string">'this is p1'</span>;</span><br><span class="line">div1.appendChild(p1); <span class="comment">// 添加新创建的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动已有节点。注意，这里是移动，不是拷贝</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">document</span>.getElementById(<span class="string">'p2'</span>);</span><br><span class="line">div1.appendChild(p2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取父元素"><a href="#获取父元素" class="headerlink" title="获取父元素"></a>获取父元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.parentElement;</span><br></pre></td></tr></table></figure><h2 id="获取子元素"><a href="#获取子元素" class="headerlink" title="获取子元素"></a>获取子元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"><span class="keyword">var</span> child = div1.childNodes;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line"><span class="keyword">var</span> child = div1.childNodes;</span><br><span class="line">div1.removeChild(child[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><code>DOM</code> 级别一共分为 4 个级别：</p><ul><li><code>DOM</code> 0 级</li><li><code>DOM</code> 1 级</li><li><code>DOM</code> 2 级</li><li><code>DOM</code> 3 级</li></ul><p>而 <code>DOM</code> 事件处理可以分为 3 个等级：</p><ul><li><code>DOM</code> 0 级事件处理</li><li><code>DOM</code> 2 级事件处理</li><li><code>DOM</code> 3 级事件处理</li></ul><p>为什么没有 <code>DOM 1 级事件处理</code>？因为 1 级 <code>DOM</code> 标准中并没有定义事件相关的内容，所以没有所谓的 <code>1 级 DOM 事件模型</code>。</p><h2 id="DOM-0-级事件"><a href="#DOM-0-级事件" class="headerlink" title="DOM 0 级事件"></a>DOM 0 级事件</h2><p>HTML 程序是最早的事件处理程序方式，如下文所示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"showFn()"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过直接在 HTML 代码里面定义了一个 <code>onclick</code> 属性触发 <code>showFn</code>，这样的事件处理程序最大的缺点就是 HTML 和 Javascript 耦合性太强，我们如果需要修改函数名就必须修改两个地方，优点是不需要操作 <code>DOM</code> 来完成事件的绑定</p><p><strong>DOM 0 级事件就是将一个函数赋值给一个事件处理属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span> type=<span class="string">"button"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码中，我们给 <code>button</code> 定义了一个 <code>id</code>，通过 JavaScript 原生的 api 获取按钮，将一个函数赋值给了一个事件处理属性 <code>onclick</code> 这样的方法就是 <code>DOM 0 级事件处理</code>的体现。我们可以通过给事件处理属性赋值 <code>null</code> 来解绑事件。</p><p><code>DOM 0 级事件处理程序</code>的缺点在于一个处理程序无法同时绑定多个处理函数，比如我还想再点击按钮事件上加上另外一个函数，这也是为什么后来会发展出 <code>DOM 2 级事件处理</code>的原因</p><h1 id="DOM-2-级事件"><a href="#DOM-2-级事件" class="headerlink" title="DOM 2 级事件"></a>DOM 2 级事件</h1><p>在提到 <code>DOM 2 级事件</code> 之前，我们要先来聊聊事件流</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>首先，我们思考一个很有意思的事情：</p><p>一张纸上画了两个同心圆，当我们把手指放到圆心上时，手指指向的不是一个圆，而是纸上的两个圆，同理之，当我们单击网页上的一个 <code>div</code> 块的时候（代码片段一），单击事件会仅仅作用在这个 <code>div</code> 上面吗？ </p><p>在浏览器发展到第四代时，IE 和 Netscape 的开发团队都遇到这个问题，他们都一致认为，除了单击 <code>div</code> 块，我们也单击了 <code>body</code>、 <code>html</code>、甚至是整个 <code>document</code>，但不幸的是两个团队针对事件流模型产生了两个完全相反的概念。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>事件流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 团队提出的解决方案称为事件冒泡</p><p>即：事件由最具体的元素接收（<code>div</code>），逐级向上传播到不具体的节点（<code>document</code>）</p><p>当我们点击上述代码片段中 <code>id</code> 为 <code>box</code> 的 <code>div</code> 块时，单击事件会按照如下顺序传播：</p><p><code>div =&gt; body =&gt; html =&gt; document</code></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-13-2.png" alt="2"></p><p>如上图所示，<code>click</code> 首先会在 <code>div</code> 元素上发生，然后沿着 <code>DOM</code> 树向上传播，每一级节点都会发生，直至传到 <code>document</code> 对象</p><p>示例：</p><iframe height="489" scrolling="no" title="VBRrQJ" src="//codepen.io/Xeonice/embed/VBRrQJ/?height=489&theme-id=31829&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/Xeonice/pen/VBRrQJ/" target="_blank" rel="noopener">VBRrQJ</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><p>PS：几乎所有的现代浏览器都支持事件冒泡，不过有一些细微的区别</p><p><code>IE5.5</code> 和 <code>IE5.5 -</code> 版本的事件冒泡会跳过 HTML 元素（<code>body</code> 直接到 <code>document</code>）<br><code>IE9</code>、<code>Firefox</code>、<code>Chrome</code>、<code>Safari</code> 则一直冒泡到 <code>window</code> 对象。</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>Netscape 提出的事件流模型叫做事件捕获</p><p>即：事件从最不具体的节点开始接收（document），传递至最具体的节点<div>，和 IE 的冒泡相反，事件捕获的本意是当事件到达预定目标前捕获它</div></p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-13-3.png" alt="3"></p><p>当我们点击代码片段一中 <code>id</code> 为 <code>box</code> 的 <code>div</code> 块时，单击事件会按照如下顺序传播：<br><code>document =&gt; html =&gt; body =&gt; div</code></p><p>PS: 虽然事件捕获是 Netscape 唯一支持的事件流模型，但 IE9、Firefox、Chrome、Safari 目前也都支持这种事件模型，由于老版本的浏览器并不支持，所以我们应该尽量使用事件冒泡，有特殊需求的时候再考虑事件捕获。</p><h2 id="DOM-2-级事件流"><a href="#DOM-2-级事件流" class="headerlink" title="DOM 2 级事件流"></a>DOM 2 级事件流</h2><p><code>DOM 2 级事件流</code>是为了兼容上述两种事件模型而提出的，它规定事件有三个阶段：</p><ul><li>事件捕获阶段：为事件捕获提供机会</li><li>处于目标阶段：事件的目标接收到事件（但不会做出响应）</li><li>事件冒泡阶段：事件响应阶段</li></ul><p>在 <code>DOM 2 级事件流</code>中，一旦我们点击之前代码中的 <code>div</code>，在事件捕获阶段从 <code>document -&gt;html -&gt;body</code> 就停止了（<code>div</code> 元素在这个阶段并不会接收到点击事件）。紧接着，事件在 <code>div</code> 上发生，并把事件真正的处理看成是冒泡阶段的一部分，然后，冒泡阶段发生，事件又回传到 <code>document</code>。</p><p>示例：</p><iframe height="505" scrolling="no" title="rrRpxP" src="//codepen.io/Xeonice/embed/rrRpxP/?height=505&theme-id=31829&default-tab=js,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/Xeonice/pen/rrRpxP/" target="_blank" rel="noopener">rrRpxP</a> by DouglasDong (<a href="https://codepen.io/Xeonice" target="_blank" rel="noopener">@Xeonice</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe><h2 id="事件流的典型应用-——-事件代理"><a href="#事件流的典型应用-——-事件代理" class="headerlink" title="事件流的典型应用 —— 事件代理"></a>事件流的典型应用 —— 事件代理</h2><p>传统的事件处理中，需要为每个元素添加事件处理器。JavaScript 事件代理则是一种简单有效的技巧，通过它可以把事件处理器添加到一个父级元素上，从而避免把事件处理器添加到多个子级元素上。</p><p>事件代理的原理用到的就是事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过 <code>target</code>（IE 为 <code>srcElement</code>）判断是哪个子元素，从而做相应处理, 下面举例说明：</p><p>传统的事件会为每个 <code>DOM</code> 添加事件，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>传统的事件绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"color-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>indigo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>purple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> colorList = <span class="built_in">document</span>.getElementById(<span class="string">"color-list"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> colors = colorList.getElementsByTagName(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        colors[i].addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        e = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> targetElement = e.target || e.srcElement;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(targetElement.innerHTML);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;)();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件代理的处理方式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>传统的事件绑定<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"color-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>red<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>yellow<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>green<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>blue<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>indigo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>purple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> colorList = <span class="built_in">document</span>.getElementById(<span class="string">"color-list"</span>);</span></span><br><span class="line"><span class="javascript">        colorList.addEventListener(<span class="string">'click'</span>, showColor, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            e = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> targetElement = e.target || e.srcElement;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (targetElement.nodeName.toLowerCase() === <span class="string">"li"</span>) &#123;</span></span><br><span class="line"><span class="undefined">                alert(targetElement.innerHTML);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;)();</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用事件代理的好处：</p><ul><li><p>将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高了性能。想象如果有一个 100 行的表格，对比传统的为每个单元格绑定事件处理器的方式和事件代理（即 <code>table</code> 上添加一个事件处理器），不难得出结论，事件代理确实避免了一些潜在的风险，提高了性能。</p></li><li><p><code>DOM</code> 更新无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（<code>a</code>, <code>span</code>, <code>div</code>等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历。</p></li></ul><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>事件冒泡是可以被阻止的，防止事件冒泡带来的不必要困扰</p><p>这个方法是：<code>stopPropagation()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// event为事件对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. You click Button'</span>);</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Stop Propagation!'</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>事件到达具体元素后会停止冒泡，但不影响父元素的事件捕获</p><h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>同样的，开发过程中经常需要阻止元素的默认行为，这时候需要调用 <code>preventDefault()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// event为事件对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. You click Button'</span>);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h1 id="DOM-3-级事件"><a href="#DOM-3-级事件" class="headerlink" title="DOM 3 级事件"></a>DOM 3 级事件</h1><p><code>DOM 3 级事件</code> 在 <code>DOM 2 级事件</code>的基础上添加了很多事件类型。</p><ul><li>UI事件，当用户与页面上的元素交互时触发，如：<code>load</code>、<code>scroll</code></li><li>焦点事件，当元素获得或失去焦点时触发，如：<code>blur</code>、<code>focus</code></li><li>鼠标事件，当用户通过鼠标在页面执行操作时触发如：<code>dbclick</code>、<code>mouseup</code></li><li>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：<code>mousewheel</code></li><li>文本事件，当在文档中输入文本时触发，如：<code>textInput</code></li><li>键盘事件，当用户通过键盘在页面上执行操作时触发，如：<code>keydown</code>、<code>keypress</code></li><li>合成事件，当为IME（输入法编辑器）输入字符时触发，如：<code>compositionstart</code></li><li>变动事件，当底层 <code>DOM</code> 结构发生变化时触发，如：<code>DOMsubtreeModified</code></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>DOM</code> 树是浏览器为了识别 HTML 结构而特化的一种格式，浏览器通过识别它，生成 JavaScript 能够识别的对象，从而方便我们用 JavaScript 进行各种操作。</p><p>需要注意的一点是：<code>DOM</code> 只是一个 W3C 规定的接口规范，并不是 JavaScript 的一部分。经常与 JavaScript 一并被提到的原因仅仅在于现今只能通过 JavaScript 来操作 <code>DOM</code>，假使有一天 <code>wasm</code> 成熟了，我们也有可能会采用别的语言操作 <code>DOM</code> 对象</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.jianshu.com/p/622d994906f7" target="_blank" rel="noopener"><code>DOM</code>级别与<code>DOM</code>事件</a><br><a href="https://segmentfault.com/a/1190000011951192#articleHeader2" target="_blank" rel="noopener">深入理解JavaScript <code>DOM</code>事件机制（一）——事件流</a><br><a href="https://wangdoc.com/javascript/`DOM`/general.html" target="_blank" rel="noopener"><code>DOM</code> 概述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;JavaScript 中的 DOM 是什么？我们应该如何利用浏览器提供的 DOM 对象？JavaScript 的 DOM 有什么实际运用？什么是事件冒泡？什么是事件代理？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://www.douglasdong.site/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 闭包</title>
    <link href="https://www.douglasdong.site/2018-08-12.html"/>
    <id>https://www.douglasdong.site/2018-08-12.html</id>
    <published>2018-08-12T04:14:33.000Z</published>
    <updated>2018-10-04T06:13:01.938Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p>JavaScript 拥有特殊的变量作用域，即全局作用域和函数作用域，它的特异之处在于，函数内部可以直接读取全局变量。这一点是借助作用域链这一机制实现的</p><p>假如说我们在函数内调用一个全局变量，如下列代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">200</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> c = <span class="number">300</span></span><br><span class="line">        <span class="built_in">console</span>.log(a) <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">        <span class="built_in">console</span>.log(b) <span class="comment">// 自由变量，顺作用域链向父作用域找</span></span><br><span class="line">        <span class="built_in">console</span>.log(c) <span class="comment">// 本作用域的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    F2()</span><br><span class="line">&#125;</span><br><span class="line">F1()</span><br></pre></td></tr></table></figure><p><code>F2</code> 中不存在 <code>a</code> 这个变量，因此会按照作用域链向上查找，直到查找到全局作用域为止，这种一层一层的关系，就叫做作用域链</p><p>ES6 中对作用域问题进行了一部分改良，加入了 <code>let</code> 和 <code>const</code> 关键字，用于定义确定的块级作用域。这里不对其进行详细考证</p><p>我们可以通过作用域链一层层向上查找，在内层函数读取外层函数的变量。但是，如果我们反其道而行之呢？如果我们希望在函数外部访问函数内部的变量呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;　　</span><br><span class="line">&#125;　　</span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>按照上述方法是一定行不通的，函数作用域的这种特殊机制也给了 ES5 变相实现块级作用域的方法：通过 <code>IIFE</code>（立即执行函数）在程序内定义相互分离的函数作用域</p><h1 id="如何从外部读取局部变量？"><a href="#如何从外部读取局部变量？" class="headerlink" title="如何从外部读取局部变量？"></a>如何从外部读取局部变量？</h1><p>正常情况下，我们是无法从外部读取局部变量的。但是，我们可以通过变通的方法实现：<strong>在函数的内部，再定义一个函数并返回</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;　　</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">999</span>;　　</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;　　　　　</span><br><span class="line">        alert(n); <span class="comment">// 999　　　　</span></span><br><span class="line">    &#125;　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，函数 <code>f2</code> 被包含在 <code>f1</code> 内部，这时所有 <code>f1</code> 的局部变量，对 <code>f2</code> 都是可见的。但是反过来就不行，这也是 JavaScript 的链式作用域结构决定的</p><p>既然 <code>f2</code> 可以访问 <code>f1</code> 的变量，那么<strong>只要把 <code>f2</code> 作为返回值，我们不就可以在 <code>f1</code> 外部访问它的变量了吗！</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n); </span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>上一节中最后的 <code>f2</code> 函数，就是闭包，简单来说，闭包就是指可以访问另一个函数作用域变量的函数，就如同上一节中用于访问 <code>f1</code> 中变量的 <code>f2</code> 函数一样。</p><h2 id="为什么需要闭包？"><a href="#为什么需要闭包？" class="headerlink" title="为什么需要闭包？"></a>为什么需要闭包？</h2><p>局部变量无法共享和长期保存（js 的垃圾回收机制导致函数会被定期回收），而全局变量可能会造成变量污染（变量重名），所以我们希望有一种机制既可以长久的保存变量，又不会造成全局污染</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>占用更多内存</li><li>不容易被释放（与 JavaScript 的垃圾回收机制相关，具体内容将在之后的文章中涉及）</li></ul><h2 id="何时使用？"><a href="#何时使用？" class="headerlink" title="何时使用？"></a>何时使用？</h2><p>既要反复使用，又想避免全局变量污染</p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><ul><li>定义外层函数，封装被保护的局部变量</li><li>定义内层函数，执行对外部函数变量的操作</li><li>外层函数返回内层函数的对象，并且外层函数调用，结果保存在一个全局的变量中</li></ul><h2 id="函数生命周期"><a href="#函数生命周期" class="headerlink" title="函数生命周期"></a>函数生命周期</h2><ul><li>定义时<ul><li>创建函数对象（封装了函数的定义）</li><li>创建作用域对象（默认存在了一个 window 引用）</li></ul></li><li>调用时<ul><li>创建一个活动对象（包含局部变量）</li><li>将活动对象的引用加到作用域对象中</li><li>创建执行环境（包含了作用域链（scope chain）属性指向作用域对象）</li></ul></li><li>调用后<ul><li>活动对象释放</li><li>作用域链中的活动对象出栈</li><li>执行环境出栈</li></ul></li></ul><h1 id="闭包有什么作用？"><a href="#闭包有什么作用？" class="headerlink" title="闭包有什么作用？"></a>闭包有什么作用？</h1><p>事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。</p><h2 id="封装私有变量"><a href="#封装私有变量" class="headerlink" title="封装私有变量"></a>封装私有变量</h2><p>我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//变量作用域为函数内部，外部无法访问    </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"default"</span>;       </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       getName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">return</span> name;    </span><br><span class="line">       &#125;,    </span><br><span class="line">       setName : <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>)</span>&#123;    </span><br><span class="line">           name = newName;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;();    </span><br><span class="line">     </span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//直接访问，结果为undefined    </span></span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// default</span></span><br><span class="line">person.setName(<span class="string">"abruzzi"</span>); </span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// abruzzi</span></span><br></pre></td></tr></table></figure><p>这个例子中，函数通过闭包返回了两个方法。外层函数可以通过返回的方法操作内部变量，但是无法直接访问内部的变量，从而实现了变量的私有化</p><h2 id="匿名自执行函数"><a href="#匿名自执行函数" class="headerlink" title="匿名自执行函数"></a>匿名自执行函数</h2><p>所有的变量，如果不加 <code>var</code> 关键字，则会被默认添加到全局对象的属性上去。这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；全局对象过于庞大，影响访问速度（因为变量的取值是需要从原型链上遍历的）</p><p>实际情况下，我们经常会遇到这种情况 —— <code>所有的函数只需要执行一次，其内部变量无需维护</code></p><p>比如 UI 的初始化，我们就可以使用闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data= &#123;    </span><br><span class="line">    table : [],    </span><br><span class="line">    tree : &#123;&#125;    </span><br><span class="line">&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">dm</span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dm.table.rows; i++)&#123;    </span><br><span class="line">       <span class="keyword">var</span> row = dm.table.rows[i];    </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; row.cells; i++)&#123;    </span><br><span class="line">           drawCell(i, j);    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;)(data);  </span><br></pre></td></tr></table></figure><p>我们创建了一个匿名的函数，并立即执行它，由于<strong>外界无法引用它的变量，因此在函数执行完以后会立即释放资源</strong>，关键是不污染全局对象</p><h2 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h2><p>设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间</p><p>我们可以将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值。如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为<strong>它不会释放外部的引用，从而使函数内部的值得以保留</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CachedSearchBox = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;,    </span><br><span class="line">       count = [];    </span><br><span class="line">    <span class="keyword">return</span> &#123;    </span><br><span class="line">       attachSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;<span class="comment">//如果结果在缓存中    </span></span><br><span class="line">              <span class="keyword">return</span> cache[dsid];<span class="comment">//直接返回缓存中的对象    </span></span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">var</span> fsb = <span class="keyword">new</span> uikit.webctrl.SearchBox(dsid);<span class="comment">//新建    </span></span><br><span class="line">           cache[dsid] = fsb;<span class="comment">//更新缓存    </span></span><br><span class="line">           <span class="keyword">if</span>(count.length &gt; <span class="number">100</span>)&#123;<span class="comment">//保正缓存的大小&lt;=100    </span></span><br><span class="line">              <span class="keyword">delete</span> cache[count.shift()];    </span><br><span class="line">           &#125;    </span><br><span class="line">           <span class="keyword">return</span> fsb;          </span><br><span class="line">       &#125;,    </span><br><span class="line">     </span><br><span class="line">       clearSearchBox : <span class="function"><span class="keyword">function</span>(<span class="params">dsid</span>)</span>&#123;    </span><br><span class="line">           <span class="keyword">if</span>(dsid <span class="keyword">in</span> cache)&#123;    </span><br><span class="line">              cache[dsid].clearSelection();      </span><br><span class="line">           &#125;    </span><br><span class="line">       &#125;    </span><br><span class="line">    &#125;;    </span><br><span class="line">&#125;)();    </span><br><span class="line">     </span><br><span class="line">CachedSearchBox.attachSearchBox(<span class="string">"input"</span>);</span><br></pre></td></tr></table></figure><p>这样我们第二次调用的时候，就会从缓存中读取到该对象</p><h1 id="面试题考察"><a href="#面试题考察" class="headerlink" title="面试题考察"></a>面试题考察</h1><p>题目：现在有个 HTML 片段，要求编写代码，点击编号为几的链接就 <code>alert</code> 弹出其编号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>编号1，点击我请弹出1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不了解闭包的同学可能会写出以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的执行结果为 <code>6</code>，这是因为用户在看到页面的时候，JavaScript 代码已经执行完毕了。但是 <code>click</code> 事件还没有被用户触发，所以在 <code>for</code> 循环中，我们仅仅是为 <code>list</code> 的所有元素创建了一个监听器而已。</p><p>然而在 JavaScript 中没有块作用域，监听器被触发时，<code>for</code> 循环结束，<code>i</code> 值在结束循环的时候是 <code>5</code>，<code>alert</code> 中经过处理后变成 <code>6</code>，一切都是因为 <code>i</code> 还是调用的外部循环引用，没有被分离</p><p>如果我们希望分离每个监听器中的 <code>i</code>，就需要写成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    list[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i), <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过闭包，我们为每一个监听器创建独立的函数作用域，我们成功把监听器中的 <code>i</code> 与外部循环中的 <code>i</code> 分离开来，使得每个监听器都有一个自己独有的 <code>i</code> 变量，从而实现了题目要求。<br>（PS：<code>IIFE</code> 也可以实现类似的效果）</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p>思考以下代码的执行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  a.fun(<span class="number">1</span>);  a.fun(<span class="number">2</span>);  a.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  c.fun(<span class="number">2</span>);  c.fun(<span class="number">3</span>);<span class="comment">//undefined,?,?,?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//问:三行a,b,c的输出分别是什么？</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JavaScript 的闭包给予了我们在函数外访问函数内变量的可能，JavaScript 自身的垃圾回收机制也允许我们运用闭包保存一些不希望被内存回收的变量，不过在使用闭包的时候，一定要注意内存泄露问题。在真正需要使用闭包的时候再调用闭包</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/yunfeifei/p/4019504.html" target="_blank" rel="noopener">全面理解JavaScript闭包和闭包的几种写法及用途</a><br><a href="https://zhuanlan.zhihu.com/p/27857268" target="_blank" rel="noopener">图解JS闭包</a><br><a href="http://www.ruanyifeng.com/blog/2009/08/learning_JavaScript_closures.html" target="_blank" rel="noopener">学习JavaScript闭包（Closure）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;JavaScript 中的闭包是什么？闭包具有什么特点？我们为什么需要闭包？我们可以用 JavaScript 中的闭包做到什么？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://www.douglasdong.site/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>类，原型链与 Class</title>
    <link href="https://www.douglasdong.site/2018-08-11.html"/>
    <id>https://www.douglasdong.site/2018-08-11.html</id>
    <published>2018-08-11T11:00:35.000Z</published>
    <updated>2018-10-04T06:13:11.822Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>JavaScript 的继承机制一直是很难理解的一部分，它没有子类和父类的概念，也没有类（”<code>class</code>“）和实例（”<code>instance</code>“）的区分，继承部分全部依靠奇特的 ”原型链” 来进行实现</p><p>那么，为什么 JavaScript 会采取这样一种奇特的方式实现继承呢？这要从 JavaScript 的诞生说起</p><h1 id="从古代说起"><a href="#从古代说起" class="headerlink" title="从古代说起"></a>从古代说起</h1><p>1994 年，网景公司发布了 Navigator 0.9，这是历史上第一个比较成熟的浏览器。但是这个版本的浏览器只能用来浏览，与页面进行交互只能交于服务端进行判断。</p><p>比如，如果网页上有一栏 “用户名” 要求填写，浏览器是无法进行判断的，只能将请求发给服务器，让服务器进行判断，如果用户没有填写，服务端就返回错误，要求用户重新填写，这太浪费时间和服务器资源了</p><p>因此，网景公司急需一款网页脚本语言，使得浏览器可以与网页互动。Berndan Eich 负责开发这一款新语言，他认为没有必要设计的很复杂，只要能完成一些简单操作就行了，比如判断用户有没有填写表单</p><p>1994 年是面向对象（object-oriented programming）编程最兴盛的时候，Berndan Eich 很明显受其影响，JavaScript 里面的所有数据类型都是对象。这一点与 Java 非常相似，但这款语言是否需要设计继承呢？</p><h2 id="Berndan-Eich-的选择"><a href="#Berndan-Eich-的选择" class="headerlink" title="Berndan Eich 的选择"></a>Berndan Eich 的选择</h2><p>如果只是单纯的脚本语言，其实上也不需要有继承机制。但是，JavaScript 里面都是对象，必须要有一种机制，将所有对象联系起来。因此，Berndan Eich 最终还是设计了继承</p><p>但是，他不准备引入 “类” 的概念，因为有了 “类” 以后，JavaScript 就是一款标准的面向对象语言了，这与其易于上手的目标不符</p><p>他考虑到，C++ 和 Java 中都使用 <code>new</code> 命令，生成实例</p><p>C++ 中的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName *object = <span class="keyword">new</span> ClassName(param);</span><br></pre></td></tr></table></figure></p><p>Java 中的写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Foo foo = <span class="keyword">new</span> Foo();</span><br></pre></td></tr></table></figure></p><p>因此，他就把 <code>new</code> 命令引入了 JavaScript，用来从一个原型对象生成一个实例对象。但是，JavaScript 没有 ”类“，怎么来表示原型对象呢？</p><p>C++ 和 Java 在生成 ”类“ 的时候，都会调用 ”类“ 的构造函数，于是他就做了一个简化设计，在 JavaScript 后面，<code>new</code> 跟的不是类，而是构造函数</p><p>举例来说，现在有一个叫做 Dog 的构造函数，用来表示狗对象的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个构造函数用 new，就会生成一个新的实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> Dog(”大毛”);</span><br><span class="line">alert(dogA.name); <span class="comment">//大毛</span></span><br></pre></td></tr></table></figure><p>其中的 <code>this</code> 关键字，就代表新创建的实例对象</p><h2 id="new-运算符的缺点"><a href="#new-运算符的缺点" class="headerlink" title="new 运算符的缺点"></a>new 运算符的缺点</h2><p><code>new</code> 运算符的缺点，在于无法共享属性和方法</p><p>比如，在 Dog 对象的构造函数中，设置一个实例对象的共有属性 species</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.species = <span class="string">'犬科'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，生成两个实例对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> Dog(”大毛”);</span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> Dog(”二毛”);</span><br></pre></td></tr></table></figure><p>这两个对象的 <code>species</code> 属性是独立的，一个修改，不会影响到另一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dogA.species = <span class="string">'猫科'</span>;</span><br><span class="line">alert(dogB.species); <span class="comment">// 显示"犬科"，不受dogA的影响</span></span><br></pre></td></tr></table></figure><p>每一个实例对象，都有自己的属性和方法的副本，这不仅无法做到资源共享，也是极大的资源浪费</p><h2 id="prototype-属性的引入"><a href="#prototype-属性的引入" class="headerlink" title="prototype 属性的引入"></a>prototype 属性的引入</h2><p>考虑到这一点，Brendan Eich 决定为构造函数设置一个 <code>prototype</code> 属性</p><p>这个属性包含一个对象（<code>_proto_</code>），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里</p><p>实例对象一旦创建，将自动引用 <code>prototype</code> 对象的属性和方法。也就是说，实例对象的方法和属性分为两种，一种是本地的，另一种是引用的。</p><p>如何判断这个属性是不是对象自身的属性呢？使用 <code>hasOwnProperty</code> 即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> item</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> f) &#123;</span><br><span class="line">    <span class="comment">// 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性</span></span><br><span class="line">    <span class="keyword">if</span> (f.hasOwnProperty(item)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是以 Dog 构造函数为例，现在用 <code>prototype</code> 属性进行改写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">this</span>.name = name;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　DOG.prototype = &#123; <span class="attr">species</span> : <span class="string">'犬科'</span> &#125;;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line">　　<span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br><span class="line">　　alert(dogA.species); <span class="comment">// 犬科</span></span><br><span class="line">　　alert(dogB.species); <span class="comment">// 犬科</span></span><br></pre></td></tr></table></figure><p>现在，<code>species</code> 属性放在 <code>prototype</code> 对象中，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　DOG.prototype.species = <span class="string">'猫科'</span>;</span><br><span class="line"></span><br><span class="line">　　alert(dogA.species); <span class="comment">// 猫科</span></span><br><span class="line">　　alert(dogB.species); <span class="comment">// 猫科</span></span><br></pre></td></tr></table></figure><p>借助于原型，Berndan Eich 在 JavaScript 中以一种奇特的方式实现了对象属性的继承。</p><p>现在 JavaScript 中的原型，一般指的是构造函数中的显式原型 <code>prototype</code>，以及对象中的隐式原型 <code>_proto_</code>，且对象中的 <code>_proto</code> 指向构造函数中的 <code>prototype</code></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>理解了原型的产生原因后，理解原型链就变的简单多了。还是拿刚才的 Dog 构造函数举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">this</span>.name = name;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　DOG.prototype = &#123; <span class="attr">species</span> : <span class="string">'犬科'</span> &#125;;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line">　　<span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br><span class="line">　　alert(dogA.species); <span class="comment">// 犬科</span></span><br><span class="line">　　alert(dogB.species); <span class="comment">// 犬科</span></span><br></pre></td></tr></table></figure><p>如果我现在对 <code>dogA.name</code> 进行 <code>toString</code> 操作，会发生什么呢？</p><ul><li><code>dogA</code> 中没有 <code>toString</code> 方法，通过 <code>dogA._proto_</code> 在 <code>DOG.prototype</code> 中查找</li><li><code>DOG.prototype</code> 中没有 <code>toString</code> 方法，继续通过 <code>DOG.prototype._proto_</code> 在 <code>Object.prototype</code>（等同于 <code>DOG.prototype._proto_</code>，因为 <code>DOG</code> 没有更上一级的原型，因此跳转至原型所属的 <code>Object.prototype</code>） 中进行查找</li><li>于 <code>Object.prototype</code> 中找到方法，返回并调用该方法</li></ul><p>按照这种方式一直往上找，你会发现是一个链式的结构。如果找到最上层都没有找到，那么就宣告失败，返回 <code>undefined</code>。最上层是什么 —— <code>Object.prototype._proto_</code></p><h2 id="复杂的原型链"><a href="#复杂的原型链" class="headerlink" title="复杂的原型链"></a>复杂的原型链</h2><p>下列代码是一个较为复杂的原型链，可以通过它来直观的体会原型链的继承关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.gender = <span class="string">"male"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Human.prototype.constructor = Human;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Human</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.actionWay = <span class="string">"走路"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Teacher.prototype = <span class="keyword">new</span> Human();</span><br><span class="line">Teacher.prototype.constructor = Teacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Teacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.skill = <span class="string">"教书"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BadTeacher.prototype = <span class="keyword">new</span> Teacher();</span><br><span class="line">BadTeacher.prototype.constructor = BadTeacher;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BadTeacher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"吕超"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> BadTeacher();</span><br><span class="line"><span class="built_in">console</span>.log(t);</span><br></pre></td></tr></table></figure><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-11-2018-08-11-exp1.png" alt="2018-08-11-exp1"></p><p>原型链作为 JavaScript 固有的继承实现方式固然很好，但是对于习惯面向对象编程的程序员来说，JavaScript 原型链继承的方式还是非常难以理解，因此，JavaScript 在 ES6 标准加入了 ”类“ 这一概念。</p><h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p>JavaScript 在 ES6 中新加入的 <code>Class</code>，本质上来说只是原型链继承的语法糖而已，这也是之前花大量篇幅介绍原型链继承的原因。我们可以通过以下代码进行证明</p><p>首先，我们用构造函数与原型建立一个类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MathHandle</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">  MathHandle.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MathHandle(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">typeof</span> MathHandle  <span class="comment">// function</span></span><br><span class="line">MathHandle.prototype.constructor === MathHandle; <span class="comment">//true</span></span><br><span class="line">m._proto_ = MathHandle.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>以上代码中，<code>MathHandle</code> 作为构造函数等同于 <code>MathHandle.prototype.constructor</code>，这点毋庸置疑，我们用相同的代码对 ES6 创建的 <code>Class</code> 进行验证</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    add() &#123;</span><br><span class="line">        reutrn <span class="keyword">this</span>.x + <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MathHandle(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">typeof</span> MathHandle  <span class="comment">// function</span></span><br><span class="line">MathHandle.prototype.constructor === MathHandle; <span class="comment">//true</span></span><br><span class="line">m._proto_ = MathHandle.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可以发现，以上代码的执行内容和前一种方式构建的 ”类“ 返回的内容完全相同</p><p>因此，JavaScript 在 ES6 时期依旧不存在 ”类“ 这一概念，它只是将原有的原型链继承机制转换成了更简单易懂的 <code>class</code> 而已，本质上还是原型 + 构造函数创建对象的那一套方法。</p><h2 id="如何在-ES6-的-Class-中继承类？"><a href="#如何在-ES6-的-Class-中继承类？" class="headerlink" title="如何在 ES6 的 Class 中继承类？"></a>如何在 ES6 的 Class 中继承类？</h2><p>ES6 中，对类的继承采用了与 Java 类似的书写方式，我们可以通过以下代码实现类的继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name + <span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name); <span class="comment">// 调用 Animal 的构造函数 constructor</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    bark () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name + <span class="string">"bark"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">'hashiqi'</span>);</span><br><span class="line">dog.bark(); <span class="comment">// hashiqi bark</span></span><br><span class="line">dog.eat(); <span class="comment">// hashiqi eat</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ES6 中的 <code>Class</code>，实质上还是原型链继承的产物。这次我们深入探究了原型链的产生原因，ES6为何要加入 <code>Class</code>这一概念，<code>Class</code> 与原型链之间的联系，以及如何用原型链 + 构造函数、ES6 中的 Class 创建一个 ”类“。下一篇文章中，我们会探究如何用 JavaScript 构造一个标准的类，包含静态方法，私有成员变量</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_JavaScript.html" target="_blank" rel="noopener">JavaScript继承机制的设计思想</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;JavaScript 为什么会有原型链？ES6 中为什么会新增 Class ？和 ES5 中的原型链有何不同？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://www.douglasdong.site/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this、apply、call、bind</title>
    <link href="https://www.douglasdong.site/2018-08-08.html"/>
    <id>https://www.douglasdong.site/2018-08-08.html</id>
    <published>2018-08-08T06:44:52.000Z</published>
    <updated>2018-10-04T06:13:18.288Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>ES5 中，<code>this</code> 的指向始终坚持一个原理：<strong><code>this 永远指向最后调用它的那个对象</code></strong></p><p>下面来看一个最简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">"Cherry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//windowsName</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner: "</span> + <span class="keyword">this</span>); <span class="comment">//inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer: "</span> + <span class="keyword">this</span>); <span class="comment">//outer: Window</span></span><br></pre></td></tr></table></figure><p>根据刚刚那句话 <strong><code>this 永远指向最后调用它的那个对象</code></strong>，我们再看看最后调用 <code>a</code> 的地方 <code>a();</code>，前面没有调用的对象，那么就是全局对象 <code>Window</code>。这就相当于是 <code>window.a</code></p><p>注意，我们在这里没有使用严格模式，如果使用严格模式，全局对象就是 <code>undefined</code>，那么就会报错 <code>Uncaught TypeError：Cannot read property &#39;name&#39; of undefined</code></p><p>再看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>这个例子中，函数 <code>fn</code> 是对象 <code>a</code> 调用的，所以打印的值就是 <code>a</code> 中的 <code>name</code> 值</p><p>我们做一个小小的改动：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure><p>这里打印出 Cherry 的原因还是因为刚刚那句话：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，最后调用它的还是对象 <code>a</code></p><p>我们再来看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="comment">//name: "Cherry";</span></span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.a.fn();</span><br></pre></td></tr></table></figure><p>这里打印 <code>undefined</code> 的原因在于：调用 <code>fn</code> 的是对象 <code>a</code>，也就是说 <code>fn</code> 内部的 <code>this</code> 是对象 <code>a</code>，而对象 <code>a</code> 中并没有对 <code>name</code> 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code></p><p>这个例子还是说明了：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，因为最后调用的对象是 <code>a</code>，所以就算 <code>a</code> 中没有 <code>name</code> 这个属性，也不会继续向上个对象寻找 <code>this.name</code>，而是直接输出 <code>undefined</code></p><a id="more"></a><p>再来看一个比较坑的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">//windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = a.fn();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure><p>这里你可能会有疑问，为什么不是 <code>Cherry</code>？这是因为虽然将 <code>a</code> 对象的 <code>fn</code> 方法赋给变量 <code>f</code> 了，但是没有调用，<strong><code>this 永远指向最后调用它的那个对象</code></strong>，由于刚刚的 <code>f</code> 并没有调用，所以 <code>fn()</code> 最后仍然是被 <code>window</code> 调用的，所以 <code>this</code> 指向的也就是 <code>window</code></p><p>由以上五个例子可以看出，<code>this</code> 的指向并不是在创建的时候就可以确定的，在 ES5 中，<strong><code>this 永远指向最后调用它的那个对象</code></strong></p><p>再来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</span><br><span class="line">    innerFunction();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>现在应该能够理解其中的缘由了吧~~</p><h1 id="怎么改变-this-的指向？"><a href="#怎么改变-this-的指向？" class="headerlink" title="怎么改变 this 的指向？"></a>怎么改变 this 的指向？</h1><p>改变 this 的指向总结有以下几种方法：</p><ul><li>使用 ES6 的箭头函数</li><li>在函数内部使用 <code>_this = this</code></li><li>使用 <code>apply</code>、<code>call</code>、<code>bind</code></li><li><code>new</code> 实例化一个对象</li></ul><p>例7：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name = <span class="string">'Cherry'</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2();  <span class="comment">//this.func1 is not a function</span></span><br></pre></td></tr></table></figure><p>在不使用箭头函数的情况下，是会报错的，因为最后调用 <code>setTimeout</code> 的对象是 <code>Window</code>，但是在 <code>window</code> 中并没有 <code>func1</code> 函数</p><p>我们在改变 <code>this</code> 指向将把这个例子作为 demo 进行改造</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>众所周知，ES6 中的箭头函数是可以避免 ES5 中使用 <code>this</code> 的坑的，箭头函数的 <code>this</code> 始终指向函数定义时的 <code>this</code>，而非执行时。箭头函数需要记着这句话：<strong>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。</strong></p><p>例8：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name = <span class="string">'Cherry'</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2();  <span class="comment">//Cherry</span></span><br></pre></td></tr></table></figure><h2 id="在函数内部使用-this-this"><a href="#在函数内部使用-this-this" class="headerlink" title="在函数内部使用 _this = this"></a>在函数内部使用 <code>_this = this</code></h2><p>如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了。我们是先将调用这个函数的对象保存在变量 <code>_this</code> 中，然后在函数中都使用这个 <code>_this</code>，这样 <code>_this</code> 就不会改变了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name = <span class="string">'Cherry'</span>,</span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1();</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2();  <span class="comment">//Cherry</span></span><br></pre></td></tr></table></figure><p>这个例子中，在 <code>func2</code> 中，首先设置 <code>var _this = this</code>，这里的 <code>this</code> 是调用 <code>func2</code> 的对象 <code>a</code>，为了防止在 <code>func2</code> 中的 <code>setTimeout</code> 被 <code>Window</code> 调用而导致的在 <code>setTimeout</code> 中的 <code>this</code> 为 <code>Window</code>，我们将 <code>this</code> 先赋值给一个变量 <code>_this</code>，这样，在 <code>func2</code> 中我们使用 <code>_this</code> 就是指向对象 <code>a</code> 了。</p><h2 id="使用-apply、call、bind"><a href="#使用-apply、call、bind" class="headerlink" title="使用 apply、call、bind"></a>使用 apply、call、bind</h2><p>使用 <code>apply</code>、<code>call</code>、<code>bind</code> 函数也是可以改变 <code>this</code> 的指向的，我们先看看如何实现</p><h3 id="使用-apply"><a href="#使用-apply" class="headerlink" title="使用 apply"></a>使用 apply</h3><p>例10：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line"></span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.apply(a),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure><h3 id="使用-call"><a href="#使用-call" class="headerlink" title="使用 call"></a>使用 call</h3><p>例11：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line"></span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.call(a),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure><h3 id="使用-bind"><a href="#使用-bind" class="headerlink" title="使用 bind"></a>使用 bind</h3><p>例12：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line"></span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;.bind(a)(),<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()            <span class="comment">// Cherry</span></span><br></pre></td></tr></table></figure><h2 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h2><p><code>apply</code>、<code>call</code>、<code>bind</code> 都是能够改变 <code>this</code> 指向的，但是这三个函数略有不同</p><p>MDN 中对 <code>apply</code> 定义如下：</p><blockquote><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的 <code>this</code> 值，以及作为一个数组（或类似数组的对象）提供的参数</p></blockquote><p>语法：</p><blockquote><p>fun.apply(thisArg, [argsArray])</p></blockquote><ul><li><p><code>thisArg</code>：在 <code>fun</code> 函数运行时指定的 <code>this</code> 值。需要注意的是，指定的 <code>this</code> 值并不一定是该函数执行时真正的 <code>this</code> 值，如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动指向全局对象（浏览器中就是 <code>window对象</code>），同时值为原始值（数字，字符串，布尔值）的 <code>this</code> 会指向该原始值的自动包装对象。</p></li><li><p><code>argsArray</code>：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 <code>fun</code> 函数。如果该参数的值为 <code>null</code> 或 <code>undefined</code>，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。</p></li></ul><h3 id="apply-和-call-区别"><a href="#apply-和-call-区别" class="headerlink" title="apply 和 call 区别"></a>apply 和 call 区别</h3><p><code>apply</code> 和 <code>call</code> 的区别是 <code>call</code> 方法接受的是若干个参数列表，而 <code>apply</code> 接收的是一个包含多个参数的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.apply(a,[<span class="number">1</span>,<span class="number">2</span>])     <span class="comment">// 3</span></span><br><span class="line">b.call(a,<span class="number">1</span>,<span class="number">2</span>)       <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="bind-和-apply、call-区别"><a href="#bind-和-apply、call-区别" class="headerlink" title="bind 和 apply、call 区别"></a>bind 和 apply、call 区别</h3><p>将前面的示例用 <code>bind</code> 尝试一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =&#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a,<span class="number">1</span>,<span class="number">2</span>)；</span><br></pre></td></tr></table></figure><p>会发现并没有输出，这是为什么呢？我们来看看 MDN 文档说明：</p><blockquote><p><code>bind()</code> 方法创建一个新的函数, 当被调用时，将其 <code>this</code> 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><p>简单一点来说，就是 <code>bind()</code> 仅仅创建了一个新的函数，我们需要手动去调用</p><h1 id="JS-中的函数调用"><a href="#JS-中的函数调用" class="headerlink" title="JS 中的函数调用"></a>JS 中的函数调用</h1><p>函数调用的方法一共有四种</p><ul><li>作为一个函数调用</li><li>函数作为方法调用</li><li>使用构造函数调用函数</li><li>作为函数方法调用函数（call、apply）</li></ul><h2 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h2><p>如之前的例1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Cherry"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);          <span class="comment">// windowsName</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"inner:"</span> + <span class="keyword">this</span>);    <span class="comment">// inner: Window</span></span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"outer:"</span> + <span class="keyword">this</span>)         <span class="comment">// outer: Window</span></span><br></pre></td></tr></table></figure><p>这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 <code>window</code> 的，在严格模式，就是 <code>undefined</code>。 </p><p>但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。</p><h2 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h2><p>更多的情况是将函数作为对象的方法使用，比如例 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">"Cherry"</span>,</span><br><span class="line">    fn : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// Cherry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn();</span><br></pre></td></tr></table></figure><p>这里定义一个对象 <code>a</code>，对象 <code>a</code> 有一个属性 <code>name</code> 和一个方法 <code>fn</code></p><p>然后对象通过 <code>.</code> 方法调用了其中的 <code>fn</code> 方法</p><p>然后就是我们一直记得的那句话：<strong><code>this 永远指向最后调用它的那个对象</code></strong>，所以在 <code>fn</code> 中的 <code>this</code> 就是指向 <code>a</code> 的</p><h2 id="使用构造函数调用函数"><a href="#使用构造函数调用函数" class="headerlink" title="使用构造函数调用函数"></a>使用构造函数调用函数</h2><blockquote><p>如果函数调用前使用了 <code>new</code> 关键字, 则是调用了构造函数。<br>这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = arg1;</span><br><span class="line">    <span class="keyword">this</span>.lastName  = arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This creates a new object</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myFunction(<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</span><br><span class="line">a.lastName; <span class="comment">// 返回 "Cherry"</span></span><br></pre></td></tr></table></figure><p>这就有另一个面试经典问题：<code>new</code> 的过程了</p><p>伪代码表示 new 的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myFunction(<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> myFunction&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = myFunction.prototype;</span><br><span class="line">    <span class="keyword">var</span> result = myFunction.call(obj,<span class="string">"Li"</span>,<span class="string">"Cherry"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'obj'</span>? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个空对象 <code>obj</code></li><li>将新建的空对象的隐式原型指向其构造函数的显式原型</li><li>使用 <code>call</code> 改变 <code>this</code> 的指向</li><li>如果无对象值或者返回一个非对象值，则将 <code>obj</code> 返回作为新对象，如果返回值是一个新对象的话，那么直接返回该对象</li></ul><p>所以可以看出，在 <code>new</code> 的过程中，我们使用 call 改变了 this 的指向</p><h2 id="作为函数方法调用函数"><a href="#作为函数方法调用函数" class="headerlink" title="作为函数方法调用函数"></a>作为函数方法调用函数</h2><p>我们再来看之前的例6：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'Cherry'</span>;</span><br><span class="line">    innerFunction();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      <span class="comment">// windowsName</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>这里的 <code>innerFunction()</code> 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 <code>this</code> 就是指向 <code>window</code> 的）</p><p>例7：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"windowsName"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name : <span class="string">"Cherry"</span>,</span><br><span class="line"></span><br><span class="line">    func1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)     </span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    func2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.func1()</span><br><span class="line">        &#125;,<span class="number">100</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.func2()     <span class="comment">// this.func1 is not a function</span></span><br></pre></td></tr></table></figure><p>复制代码这个简单一点的理解可以理解为 <strong><code>匿名函数的 this 永远指向 window</code></strong>，你可以这样想，还是那句话<strong><code>this 永远指向最后调用它的那个对象</code></strong>，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数没名字啊，所以我们是没有办法被其他对象调用匿名函数的。所以说<strong><code>匿名函数的 this 永远指向 window</code></strong>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>this</code> 指向的秘诀主要由以下几句话组成：</p><p><strong><code>this</code> 永远指向最后调用它的那个对象</strong></p><p><strong>匿名函数的 <code>this</code> 永远指向 <code>window</code></strong></p><p><strong>箭头函数中没有 <code>this</code> 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 <code>this</code> 绑定的是最近一层非箭头函数的 <code>this</code>，否则，<code>this</code> 为 <code>undefined</code></strong></p><p>至于为什么 <code>this</code> 在前 ES6 时代会存在指向不同的问题？可以参阅阮一峰大大的这篇文章 – <a href="http://www.ruanyifeng.com/blog/2018/06/JavaScript-this.html" target="_blank" rel="noopener">JavaScript 的 this 原理</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/post/59bfe84351882531b730bac2" target="_blank" rel="noopener">this、apply、call、bind</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;JavaScript 中的 this，在构造函数构建时时常被使用，但是 this 并不是像我们想象的那样直观，它有自己的一套指向机制。而 apply、call、bind 也经常被用于辅助这一套指向机制。&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://www.douglasdong.site/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 异步编程迷思</title>
    <link href="https://www.douglasdong.site/2018-07-29.html"/>
    <id>https://www.douglasdong.site/2018-07-29.html</id>
    <published>2018-07-29T14:34:52.000Z</published>
    <updated>2018-10-04T06:13:28.682Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="为什么要异步编程？"><a href="#为什么要异步编程？" class="headerlink" title="为什么要异步编程？"></a>为什么要异步编程？</h1><p>JavaScript 问世之初便是作为浏览器的辅助语言进行开发的，同时由于 JavaScript 普遍用于浏览器的 GUI 开发，因此需要线程不能被阻塞</p><p>因此，JavaScript 在之后的发展过程中都采用异步非阻塞的编程模式，也就是说，<strong>在执行一个指令后不是马上得到结果，继续执行命令，等到特定的事件触发以后，才得到结果</strong>，这也是我们常说的：JavaScript 是由事件驱动的</p><h1 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h1><p>现目前的异步实现主要有以下几种实现方式：</p><ul><li><code>回调</code></li><li><code>Promise</code></li><li><code>Generator</code></li><li><code>await/async</code></li></ul><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>这种异步方式是最基础的实现，node 中在前 ES6 时代经常会碰到这种代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readdir(path.join(__dirname,<span class="string">'..'</span>),<span class="function"><span class="keyword">function</span>(<span class="params">err , files</span>)</span>&#123;</span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">filename , index</span>)</span>&#123;</span><br><span class="line">        fs.readFle(filename , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这段代码仅仅用于遍历一个目录，但是过深的嵌套很容易导致理解困难，而且这样回调也无法支持对异常的捕获，js 的嵌套回调也经常被调侃</p><p><img src="https://imagetemp.oss-cn-beijing.aliyuncs.com/2018-08-07-v2-0a8d20afae14a3991283cf6e9050f677_r.jpg" alt="回调地狱"></p><a id="more"></a><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>简单一点理解的话，就是把要执行的回调函数拿到外面进行执行，使代码看起来很同步</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 执行异步代码的调用 </span></span><br><span class="line">    <span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>(<span class="params">err , right</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 完全是可以根据返回的数据 , 直接执行相应的逻辑 , 不过为了让代码看着"好看同步" , </span></span><br><span class="line">        <span class="comment">// 决定把数据当作参数传递给外面,去外面(then的回调函数里, 或者catch的回调函数里)执行 </span></span><br><span class="line">        <span class="comment">// 根据返回的数据, 来确定该调用哪个接口 </span></span><br><span class="line">        <span class="keyword">if</span>(right)&#123;</span><br><span class="line">            resolve(<span class="string">"data"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">            reject(<span class="string">'err'</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)  </span><br><span class="line"><span class="comment">// 如果执行了resolve() , 就走到这里 </span></span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    coding..</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//如果执行了reject , 就走到了这里 </span></span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    coding..</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为什么执行了 <code>resolve(&#39;data&#39;)</code>，或 <code>reject(&#39;err&#39;)</code> 后，<code>then</code> 的回调函数，或者 <code>catch</code> 的回调函数就知道，该我执行的时候到了呢？简单点说就是有人’通知’我呗！</p><p><code>resolve</code>，<code>reject</code> 本身是 <code>Promise</code> 内部的方法，实现大概是这样</p><p>当调用 <code>resolve(&#39;data&#39;)</code> 的时候 , 去通知.then里绑定的回调函数 , 通知你一下 , 你该执行了 , 这是参数 <code>this.emit(‘resolve’ , &#39;data&#39;)</code> </p><p>当调用 <code>reject(&#39;err&#39;)</code> 的时候 , 去通知 <code>.catch</code> 里绑定的回调函数 , 通知你一下 , 你该执行了 , 这是参数 <code>this.emit(&#39;reject&#39; , &#39;err&#39;)</code></p><p> 在调用 <code>.then(callback)</code> 的时候 , <code>callback</code> , 你监听下 <code>resolve</code> , 有人通知 <code>(emit)</code> 你的时候 , 你就执行</p><p>在调用 <code>.catch(callback)</code> 的时候 , <code>callback</code>, 你监听下 <code>reject</code>, 有人通知 <code>(emit)</code> 你的时候 , 你就执行</p><p><code>Promise</code> 实现如下：<a href="https://github.com/Tankas/knowledge/blob/master/%E4%BB%A3%E7%A0%81/promise.js" target="_blank" rel="noopener">Promise 简单实现</a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>定义：协程是一个无优先级的子程序调度组件 , 允许子程序在特定的地方挂起和恢复</p><p>线程包含于进程，协程包含于进程，只要内存足够，一个线程中可以有任意个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源</p><p>协程要做的是什么？异步的代码做着同步的活</p><h3 id="何时挂起？何时恢复？"><a href="#何时挂起？何时恢复？" class="headerlink" title="何时挂起？何时恢复？"></a>何时挂起？何时恢复？</h3><p>挂起：在协程发起异步调用的时候挂起</p><p>恢复：其他协程退出并且异步操作完成时</p><h2 id="Generator-gt-协程在-js-中的实现"><a href="#Generator-gt-协程在-js-中的实现" class="headerlink" title="Generator =&gt; 协程在 js 中的实现"></a>Generator =&gt; 协程在 js 中的实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> x+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> a+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> b+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> x+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> a+<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> b+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最直观的感觉是，当调用 <code>generator(1)</code> 的时候，其实上返回了一个链表，每一个单元中装一些函数片段，以 <code>yield</code> 为界限</p><p>像上面的例子：</p><p><strong><code>(x+2) =&gt; (a+3) =&gt; (b+2) =&gt; return</code></strong></p><p>每次通过 <code>next</code> 来移动指针到下一个函数片段，执行函数片段 <code>(eval)</code>，并返回结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = generator(<span class="number">2</span>);</span><br><span class="line">gen.next(); <span class="comment">// 当调用next(),会先走第一个代码段 , 然后就不执行了 , 交出控制权 .直到啥时候再执行next(),会走下一个代码段.</span></span><br></pre></td></tr></table></figure><p>我们完全可以在每个代码段都封装一个异步任务， 反正在异步任务执行的时候，我已经交出了控制权，js 主线程的代码继续往下走，等到所有异步任务都完成的时候，通知我一下，看看其他所有协程都退出的时候，就调用 <code>next()</code>，继续往下走。这样显得代码很同步</p><p>继续看下，当调用 <code>next(&#39;5&#39;)</code> 时，里面可以传入参数，而且传入的参数就是上一个 <code>yield</code> 异步任务的返回结果</p><p>可以说这个特性非常有用，就像上面说的，当异步任务完成的时候，就调用 <code>next()</code>，再执行下面的代码，但是是没法获取到上一个异步任务的结果的，所以这个特性就是做这个的，<code>next(&#39;异步任务的结果&#39;)</code></p><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p><code>async/await</code> 实质上就是 Generator 的高度封装，是 ES7 为我们提供的语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">    <span class="keyword">let</span> f1 = <span class="keyword">await</span> readFile(<span class="string">"one"</span>);</span><br><span class="line">    <span class="keyword">let</span> f2 = <span class="keyword">await</span> readFile2(<span class="number">123123</span>);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单说，<code>async/await</code> 就是对上面 Generator 自动化流程的封装，让每一个异步任务都是自动化的执行，当第一个异步任务 <code>readFile(&#39;one&#39;)</code> 执行完，<code>async</code> 内部自己执行 <code>next()</code>，调用第二个任务 <code>readFile2(123123)</code>，以此类推</p><p>这里也许有人会困惑，<strong>为什么 <code>await</code> 后面返回的必须是 <code>promise</code>？</strong></p><p>上面说了当第一个异步完成的时候通知我一下，我再调用  <code>next()</code>，继续往下执行，但是我是何时完成的？怎么通知你？</p><p><code>Promise</code> 就是做这件事情的，<code>async</code> 内部会在 <code>promise.then(callback)</code> 回调函数中调用 <code>next()</code>… （还有用 <code>thunk</code> 的，也是做这件事情的）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论哪一种处理回调地狱的方式，都是处理回调函数的。只不过真正调用的位置不同而已，上面几种方式都是如何组织回调函数链的执行位置，如何让代码看着更好看</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://juejin.im/post/5b68f894e51d45195f0b7945" target="_blank" rel="noopener">浅浅的谈一下回调地狱的问题</a><br><a href="https://github.com/rccoder/blog/issues/17" target="_blank" rel="noopener">回调地狱的今生前世</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;我们为什么要在 JavaScript 中使用异步模式进行开发？JavaScript 中有哪些实现异步模式的方式？如何才能避免陷入回调地狱？Promise、Generator、async/await 的作用是什么？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript异步执行" scheme="https://www.douglasdong.site/categories/JavaScript%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 事件循环原理总结</title>
    <link href="https://www.douglasdong.site/2018-06-02.html"/>
    <id>https://www.douglasdong.site/2018-06-02.html</id>
    <published>2018-06-02T12:33:24.000Z</published>
    <updated>2018-10-04T06:13:41.258Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><ul><li>node 的初始化<ul><li>初始化 node 环境</li><li>执行输入代码</li><li>执行 <code>process.nextTick</code> 回调</li><li>执行 MicroTask（Promise）</li></ul></li><li>进入 EventLoop 阶段<ul><li>进入 timer 阶段（执行timer（<code>setTimeout</code>、<code>setInterval</code>）的回调）<ul><li>检查 timer 队列是否有到期的回调，如果有，将到期的 timer 回调按照 timerId 升序执行（<code>setTimeout</code>、<code>setInterval</code>）</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>进入 I/O callback 阶段（执行一些系统调用错误，比如网络通信的错误回调）<ul><li>检查是否有 pending 的 I/O 回调，如果有，执行回调，如果没有，退出阶段</li><li>检查是否有 <code>process.nextTick</code> 任务，如果有，全部执行</li><li>检查是否有 MicroTask，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>进入 idle，prepare 阶段<ul><li>这两个阶段与编程关系不大，按下不表</li></ul></li><li>进入 poll 阶段（获取新的 I/O 事件, 适当的条件下node将阻塞在这里）<ul><li>首先检查是否存在尚未完成的回调，如果存在，那么分为两种情况<ul><li>第一种情况<ul><li>如果有可用回调（到期的定时器和一些 IO 事件），执行所有可用回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出该阶段</li></ul></li><li>第二种情况<ul><li>如果没有可用回调</li><li>检查是否有 <code>setImmediate</code> 任务，如果有，退出 poll 阶段，如果没有，阻塞在此阶段，等待新的事件通知</li></ul></li></ul></li><li>如果不存在尚未完成的回调，退出 poll 阶段</li></ul></li><li>进入 check 阶段（执行 <code>setImmediate()</code> 的回调）<ul><li>如果有 <code>setImmediate</code> 回调，那么执行所有的 immediate 回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出 check 阶段</li></ul></li><li>进入 closing 阶段（执行 <code>socket</code> 的 <code>close</code> 事件回调）<ul><li>如果有 <code>setImmediate</code> 回调，那么执行所有的 immediate 回调</li><li>检查是否有 <code>process.nextTick</code> 回调，如果有，全部执行</li><li>检查是否有 MicroTask 任务，如果有，全部执行</li><li>退出 closing 阶段</li></ul></li><li>检查是否有活跃的 handles（定时器，IO 等事件句柄）<ul><li>如果有，继续下一轮循环</li><li>如果没有，结束事件循环，退出程序</li></ul></li></ul></li></ul><a id="more"></a><h1 id="setTimeout-和-setImmediate-执行顺序"><a href="#setTimeout-和-setImmediate-执行顺序" class="headerlink" title="setTimeout 和 setImmediate 执行顺序"></a><code>setTimeout</code> 和 <code>setImmediate</code> 执行顺序</h1><h2 id="普通代码中设置定时器"><a href="#普通代码中设置定时器" class="headerlink" title="普通代码中设置定时器"></a>普通代码中设置定时器</h2><p>普通代码执行阶段中设置的这两个执行任务，它们的执行顺序不是固定的</p><ul><li>首先，设置的 <code>setTimeout(callback, 0)</code> 被转换为 <code>setTimeout(callback, 1)</code>，所以进入定时器阶段时，会根据当前时间判断定时是否超过 1ms</li><li>事件循环在进入定时器阶段之前会由系统调用方法来更新当前时间，由于系统中同时运行着其他的程序，系统需要等待其他程序的进程运行结束才能获取准确时间，所以更新得到的时间可能会有一定的延迟</li><li>更新时间时，若没有延迟，定时不到 1ms ,immediate 任务会先执行；如果存在延迟，并且这个时间达到了 1ms 的界限， timeout 任务就会首先执行</li></ul><h2 id="IO-回调中设置定时器"><a href="#IO-回调中设置定时器" class="headerlink" title="IO 回调中设置定时器"></a>IO 回调中设置定时器</h2><p><code>setImmediate</code> 会率先执行</p><ul><li>进入 poll phase 轮询阶段之前会先检查是否有 timer 定时任务。</li><li>如果没有 timer 定时任务，才会执行后面的 IO 回调。</li><li>我们在 IO 回调中设置 setTimeout 定时任务，这时已经过了 timer 检查阶段，所以 timer 定时任务会被推迟到下一个循环中执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;同样的 JavaScript 代码，在 Node.js 与浏览器中分别执行，会得到完全不同的结果。其主要原因在于 Node.js 拥有一套独有的事件循环系统，这套事件循环系统的调用方式是怎样的？&lt;/center&gt;
    
    </summary>
    
      <category term="Node.js" scheme="https://www.douglasdong.site/categories/Node-js/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 执行机制解析</title>
    <link href="https://www.douglasdong.site/2018-04-21.html"/>
    <id>https://www.douglasdong.site/2018-04-21.html</id>
    <published>2018-04-21T12:33:24.000Z</published>
    <updated>2018-10-04T06:13:48.290Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="关于-JavaScript"><a href="#关于-JavaScript" class="headerlink" title="关于 JavaScript"></a>关于 JavaScript</h1><p>JavaScript 是一门单线程语言，在最新的 HTML5 中提出了 <code>Web-worker</code>，但 JavaScript 是单线程这一核心并未改变，所以，一切 JavaScript 版的“多线程”都是用单线程模拟出来的。</p><h1 id="JavaScript-事件循环"><a href="#JavaScript-事件循环" class="headerlink" title="JavaScript 事件循环"></a>JavaScript 事件循环</h1><p>既然 JS 是单线程，那就像只有一个窗口的银行，客户需要一个一个办理业务，同理 JS 任务也要一个一个顺序执行，如果一个任务耗时过长，那么后一个任务也必须等着，那么问题来了，<strong>假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？</strong>因此聪明的程序员将其分为两类：</p><ul><li>同步任务</li><li>异步任务</li></ul><p><strong>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染，而像加载图片、音乐之类占用资源大，耗时久的任务，就是异步任务</strong></p><p>下面是异步任务定义的导图表示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdd88994142347?imageView2/0/w/1280/h/960/ignore-error/1" alt="异步执行"></p><p>导图要表达的内容用文字来表述的话：</p><ul><li>同步和异步任务分别进入不同的“场所”，同步的进入主进程，异步的进入 <code>Event Table</code> 并注册函数</li><li>当指定的事情完成时，<code>Event Table</code> 会将这个函数移入 <code>Event Queue</code></li><li>主线程内的任务执行完毕为空，会去 <code>Event Queue</code> 读取对应的函数，进入主进程执行</li><li>上述过程会不断重复，也就是常说的 <code>Event Loop</code>（事件循环）</li></ul><p>怎么知道主线程执行栈为空？JS 引擎存在 <code>monitor process</code> 进程，会持续不断的检查主进程执行栈是否为空，一旦为空，就会去 Event Queue 那里检查是否有等待被调用的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$ajax(&#123;</span><br><span class="line">    url: www.JavaScript.com,</span><br><span class="line">    data: data,</span><br><span class="line">    success: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'发送成功'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'代码执行结束'</span>);    </span><br></pre></td></tr></table></figure><p>上面是一段简易的 <code>ajax</code> 请求代码</p><ul><li><code>ajax</code> 进入 <code>Event Table</code>，注册回调函数 <code>success</code></li><li>执行 <code>console.log(’代码执行结束)</code></li><li><code>ajax</code> 事件完成，回调函数 <code>success</code> 进入 <code>Event Queue</code></li><li>主线程从 <code>Event Queue</code> 读取回调函数 <code>success</code> 并执行</li></ul><p>接下来我们来研究进阶活动：<code>setTimeout</code></p><a id="more"></a><h1 id="又爱又恨的-setTimeout"><a href="#又爱又恨的-setTimeout" class="headerlink" title="又爱又恨的 setTimeout"></a>又爱又恨的 setTimeout</h1><p>大名鼎鼎的 <code>setTimeout</code>，我们经常这么实现延时 3 秒执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log (<span class="string">'延时3秒'</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>)    </span><br></pre></td></tr></table></figure><p>渐渐的，<code>setTimeout</code> 用的地方多了以后就会出现问题，有时候<strong>明明写的延时 3 秒，实际却 5、6 秒才执行</strong>，这又是怎么回事？</p><p>先看一个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;, <span class="number">3000</span>)   </span><br><span class="line"><span class="built_in">console</span>.log (<span class="string">'执行console'</span>); </span><br></pre></td></tr></table></figure><p>根据前面我们的结论，<code>setTimeout</code> 是异步的，应该先执行 <code>console.log</code> 这个同步任务，所以我们的结论是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行console</span></span><br><span class="line"><span class="comment">//task()</span></span><br></pre></td></tr></table></figure><p>验证一下，结果正确！</p><p>然后修改一下前面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    task()</span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br><span class="line">sleep(<span class="number">100000000</span>);    </span><br></pre></td></tr></table></figure><p>乍一看其实差不多，但我们把这段代码在 chrome 执行一下，却发现控制台执行 <code>task()</code> 需要的时间远远超过 3 秒，说好的延时 3 秒，为什么需要这么长时间？</p><p>这时候我们需要重新理解 <code>setTimeout</code> 的定义，我们先说上述代码是怎么执行的：</p><ul><li><code>task()</code> 进入 <code>Event Table</code> 并注册，计时开始</li><li>执行 <code>sleep</code> 函数，很慢，非常慢，计时仍在继续</li><li>3 秒到了，计时事件 <code>timeout</code> 完成，<code>task()</code> 进入 <code>Event Queue</code>，但是 <code>sleep</code> 还没执行完，只好等着</li><li><code>sleep</code> 终于执行完了，<code>task()</code> 终于从 <code>Event Queue</code> 进入了主线程执行</li></ul><p>上述的流程走完，我们知道 <strong><code>setTimeout</code> 这个函数，是经过指定时间后，把要执行的任务（本例中为 <code>task()</code>） 加入到 <code>Event Queue</code> 中</strong>，又因为是<strong>单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只好等着</strong>，导致真正的延迟时间远远大于 3 秒</p><p>我们还经常遇到 <code>setTimeout(fn, 0)</code> 这样的代码，0 秒后执行时什么意思呢？是不是可以立即执行呢？</p><p>答案是不会的，<code>setTimeout(fn, 0)</code> 的含义是，指定某个任务在主进程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行，举例说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>); </span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'先执行这里'</span>);</span><br><span class="line">setTimeout ( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行啦'</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>); </span><br></pre></td></tr></table></figure><p>代码 1 的输出结果是：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先执行这里</span></span><br><span class="line"><span class="comment">//执行啦</span></span><br></pre></td></tr></table></figure></p><p>代码 2 的输出结果是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先执行这里</span></span><br><span class="line"><span class="comment">// ... 3s later</span></span><br><span class="line"><span class="comment">//执行啦</span></span><br></pre></td></tr></table></figure><p>关于 <code>setTimeout</code> 要补充的是，即便主进程为空，0 毫秒实际上也是达不到的，<strong>根据 HTML 的标准，最低是 4 毫秒</strong>，有兴趣的同学可以自行了解</p><h1 id="又恨又爱的-setInterval"><a href="#又恨又爱的-setInterval" class="headerlink" title="又恨又爱的 setInterval"></a>又恨又爱的 setInterval</h1><p><code>setInterval</code> 与 <code>setTimeout</code> 差不多，只不过后者是循环的执行，对于执行顺序来说，<strong><code>setInterval</code> 会每隔指定的时间将注册的函数置入 <code>Event Queue</code></strong>，如果前面的任务耗时太久，那么同样需要等待</p><p>唯一需要注意的一点是，对于 <code>setInterval(fn, ms)</code> 来说，我们已经知道<strong>不是每过 <code>ms</code> 秒会执行一次 <code>fn</code>，而是每过 <code>ms</code> 秒，会有 <code>fn</code> 进入 <code>Event Queue</code>，一旦 <code>setInterval</code> 的回调函数 <code>fn</code> 执行时间超过了延迟时间 <code>ms</code>，那么就完全看不出来有时间间隔了</strong></p><h1 id="Promise-与-process-nextTick-callback"><a href="#Promise-与-process-nextTick-callback" class="headerlink" title="Promise 与 process.nextTick(callback)"></a>Promise 与 process.nextTick(callback)</h1><p>传统的定时器我们已经研究过了，接着我们探究 <code>Promise</code> 与 <code>process.nextTick(callback)</code> 的表现</p><p><code>Promise</code> 的定义和功能本文不再赘述，而 <code>process.nextTick(callback)</code> 类似 node.js 版的 <code>setTimeout</code>，在事件循环的下一次循环中调用 <code>callback</code> 回调函数</p><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务）：包括整体代码 <code>script</code>，<code>setTimeout</code>，<code>setInterval</code></li><li>micro-task（微任务）：<code>Promise</code>，<code>process.nextTick</code></li></ul><p>不同类型的任务会进入对应的 <code>Event Queue</code>，比如 <code>setTimeout</code> 和 <code>setInterval</code> 会进入相同的 <code>Event Queue</code></p><p>事件循环的顺序，决定 js 代码的执行顺序，进入整体代码（宏任务）后，开始第一次循环，接着执行所有的微任务，然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务，听起来有点绕，我们用文章最开始的一段代码说明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>);    </span><br></pre></td></tr></table></figure><ul><li>这段代码作为宏任务，进入主线程</li><li>先遇到 <code>setTimeout</code>，那么将其回调函数注册后分发到宏任务 <code>Event Queue</code>（注册过程与上同，下文不再赘述）</li><li>接下来遇到了 <code>Promise</code>，<code>new Promise</code> 立即执行，<code>then</code> 函数分发到微任务 <code>Event Queue</code></li><li>遇到 <code>console.log()</code>，立即执行</li><li>整体代码 script 作为第一个宏任务执行结束，看看有哪些微任务？我们发现了 <code>then</code> 在微任务 <code>Event Queue</code> 中，执行</li><li>ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务 <code>Event Queue</code> 开始，我们发现了宏任务 <code>Event Queue</code> 中 <code>setTimeout</code> 对应的回调函数，立即执行</li><li>结束</li></ul><p>事件循环，宏任务，微任务的关系如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/21/15fdcea13361a1ec?imageView2/0/w/1280/h/960/ignore-error/1" alt="事件循环关系"></p><p>我们来分析一段比较复杂的代码，看看你是否真的掌握了 js 的执行机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)   </span><br></pre></td></tr></table></figure><p>第一轮事件循环流程分析如下：</p><ul><li>整体 script 作为第一个宏任务进入主线程，遇到 <code>console.log()</code>，输出 1</li><li>遇到 <code>setTimeout</code>，其回调函数被分发到宏任务 <code>Event Queue</code> 中，我们记为 <code>setTimeout1</code></li><li>遇到 <code>process.nextTick()</code>，其回调函数被分发到微任务 <code>Event Queue</code> 中，我们记为 <code>then1</code></li><li>又遇到 <code>setTimeout</code>，其回调函数被分发到宏任务 <code>Event Queue</code> 中，我们记为 <code>setTimeout2</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout1</td><td>process1</td></tr><tr><td>setTimeout2</td><td>then1</td></tr></tbody></table><ul><li>上表是第一轮事件循环宏任务结束时各 <code>Event Queue</code> 的情况，此时已经输出了 1 和 7 </li><li>我们发现了 <code>process1</code> 和 <code>then1</code> 两个微任务</li><li>执行 <code>process1</code>，输出 6</li><li>执行 <code>then1</code>，输出 8</li></ul><p>第一轮事件循环正式结束，这一轮的结果是输出 1、7、6、8，那么第二轮事件循环从 <code>setTimeout1</code> 宏任务开始：</p><ul><li>首先输出 2，接下来遇到了 process.nextTick()，同样将其分发到微任务 <code>Event Queue</code> 中，记为 <code>process2</code>，<code>new Promise</code> 立即执行输出 4，<code>then</code> 也分发到微任务 <code>Event Queue</code> 中，记为 <code>then2</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td>setTimeout2</td><td>process2</td></tr><tr><td></td><td>then2</td></tr></tbody></table><ul><li>第二轮事件循环宏任务结束，我们发现有 <code>process2</code> 和 <code>then2</code> 两个微任务可以执行</li><li>输出 3</li><li>输出 5</li><li>第二轮时间循环结束，输出 2、4、3、5</li><li>第三轮事件循环开始，此时只剩下 <code>setTimeout2</code>，执行</li><li>直接输出 9</li><li>将 <code>process.nextTick()</code> 分发到微任务 <code>Event Queue</code> 中，记为 <code>process3</code></li><li>直接执行 <code>new Promise</code>，输出 11</li><li>将 <code>then</code> 分发到微任务 <code>Event Queue</code> 中，记为 <code>then3</code></li></ul><table><thead><tr><th>宏任务 Event Queue</th><th>微任务 Event Queue</th></tr></thead><tbody><tr><td></td><td>process3</td></tr><tr><td></td><td>then3</td></tr></tbody></table><ul><li>第三轮时间循环宏任务执行结束，执行两个微任务 <code>process3</code> 和 <code>then3</code></li><li>输出 10</li><li>输出 12</li><li>第三轮事件循环结束，第三轮输出 9，11，10，12</li></ul><p>整段代码，共进行了三次事件循环，完整的输出为 1、7、6、8、2、4、3、5、9、11、10、12（请注意，node 环境下的事件监听依赖 libuv 和前端环境不完全相同，输出顺序可能会有误差）</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>（1）js 的异步</strong></p><p>我们从最开头就说 JavaScript 是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要</p><p><strong>（2）事件循环 Event loop</strong></p><p>事件循环是 js 实现异步的一种方法，也是 js 的执行机制</p><p><strong>（3）JavaScript 的执行和运行</strong></p><p>执行和运行有很大的区别，JavaScript 在不同的环境下，比如 node，浏览器，Ringo 等等，执行方式是不同的，而运行大多指 JavaScript 解析引擎，是统一的</p><p><strong>（4）settimemediate</strong></p><p>微任务和宏任务还有很多种类，比如 <code>setImmediate</code> 等等，执行都是有共同点的，有兴趣的同学可以自行了解</p><p><strong>（5）最后的最后</strong></p><ul><li>JavaScript 是一门单线程语言</li><li><code>Event Loop</code> 是 JavaScript 的执行机制</li></ul><p>转载至：<br>作者：ssssyoki<br>链接：<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">https://juejin.im/post/59e85eebf265da430d571f89</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;JavaScript 的异步编程极度依赖事件循环，这一点也是在面试中经常考察的一部分。单线程的 JavaScript 中各个事件是如何被调用的？它们之间的执行顺序又是如何？&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript异步执行" scheme="https://www.douglasdong.site/categories/JavaScript%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Thunk 解析</title>
    <link href="https://www.douglasdong.site/2018-04-11.html"/>
    <id>https://www.douglasdong.site/2018-04-11.html</id>
    <published>2018-04-11T11:19:24.000Z</published>
    <updated>2018-10-04T06:13:56.668Z</updated>
    
    <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="何为-THUNK？"><a href="#何为-THUNK？" class="headerlink" title="何为 THUNK？"></a>何为 THUNK？</h1><p>开发者时常会面临一个选择：函数的参数到底应该何时求值？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f ( x + <span class="number">5</span> );</span><br></pre></td></tr></table></figure><p>上例中的代码非常正常，问题是：<strong>什么时候计算参数 x + 5 呢</strong>？</p><p>一种策略是立即计算，于是 <code>f(x + 5)</code> 会被转换成 <code>f(6)</code>，然后进入函数 <code>f</code> 内运行函数</p><p>另一种策略是延迟计算，在进入函数 <code>f</code> 之前并不计算参数值，而是进入函数体之后才计算，因此函数体内的 <code>return m * 2;</code> 会被转换为 <code>return (x + 5) * 2;</code>，此时才开始计算</p><p>如果不考虑开发成本，延迟计算是比较好的，否则如果函数体内走了某 if 分支并没有用到该参数，就白计算了，浪费性能。延迟到真正用到参数时才开始计算，这也是程序开发的一种流行的风格：<strong>越懒越好</strong><br><a id="more"></a></p><h2 id="如何实现-Thunk？"><a href="#如何实现-Thunk？" class="headerlink" title="如何实现 Thunk？"></a>如何实现 Thunk？</h2><p>如何实现延迟计算呢？可以生成一个临时函数（Thunk 函数），将参数放进去，上面代码等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">tempFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tempFunc() * <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f (thunk);  <span class="comment">//12    </span></span><br></pre></td></tr></table></figure><p>上面这样的延迟计算，可能对效率控来说节省了一些理论上的性能（实际真节省了吗？未必），但从代码可读性，可维护性上来看，这样是得不偿失的</p><h2 id="Thunk-的具体应用"><a href="#Thunk-的具体应用" class="headerlink" title="Thunk 的具体应用"></a>Thunk 的具体应用</h2><p>Thunk 函数在 JS 里的应用是将多参的一步函数转换为单参，通常异步函数的最后一个参数是回调函数，以 NodeJS 的核心模块 File System 的异步函数 <code>readFile</code> 为例</p><p>函数原型：<code>fs.readFile (file[, options], callback)</code><br>支持 3 个参数，其中最后一个是回调函数，普通调用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someCallback</span> (<span class="params"> err, data </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log (data);</span><br><span class="line">&#125;</span><br><span class="line">fs.readFile(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>, someCallback); </span><br></pre></td></tr></table></figure><p>用 Thunk 改造后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someCallback</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fs.readFile(fileName, options, callback);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">readFileThunk(someCallBack);    </span><br></pre></td></tr></table></figure><p>Thunk 函数真正的作用是<strong>简化了参数，将原本多参的函数，简化成只接受回调函数做参数</strong>，即多参版本的一步函数，经由 Thunk，变成了单参（参数为回调函数）函数</p><p>现实中不必为每个异步函数定制一个 Thunk 函数，因此可以定义通用的 Thunk 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">            args.push(callback);</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fs.readFile);</span><br><span class="line">readFileThunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>)(someCallback); </span><br></pre></td></tr></table></figure><p>可以把上面 Thunk 函数放到 common 位置，任何多参的异步函数（最后一个参数为回调函数），都可以调用上面的 Thunk 函数转换成单参版本</p><p>其实上述 Thunk 函数等价于柯里化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFileThunk = fs.readFile.bind(<span class="literal">null</span>, <span class="string">'./orange.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">readFileThunk(someCallback);</span><br></pre></td></tr></table></figure><p>如果不想自己造轮子来写 Thunk 函数，可以 Thunkify 模块：<code>npm install thunkify</code>，源代码和我们写的 Thunk 非常像</p><h2 id="Thunk-的真正用途"><a href="#Thunk-的真正用途" class="headerlink" title="Thunk 的真正用途"></a>Thunk 的真正用途</h2><p>上面举的 Thunk 函数的例子，无论是延迟计算，还是将多参异步函数转换成单参，其实都没什么用，所以在 Generator 函数出现之前，Thunk 函数确实没什么用，真正让其发挥作用的是配合 Generator 函数实现自动化异步操作，以读取文件为例，Generator 函数封装了两个异步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFileThunk = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunk(<span class="string">'./apples.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r1);</span><br><span class="line">    <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunk(<span class="string">'./oranges.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(r2);</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure><p>定义的异步操作很清晰（这也是 Generator 的优点，可以用同步化的方式定义异步操作步骤），可以如下执行异步操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> r = g.next();</span><br><span class="line">r.value(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;  <span class="comment">//r.value 是一个 function，等价于 fs.readFile(callback)</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> r2 = g.next(data);</span><br><span class="line">    r2.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        g.next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);    </span><br></pre></td></tr></table></figure><p>上面代码第二行执行 <code>next</code> 后，返回值 r 的 <code>value</code> 属性是 Generator 函数体内 <code>yield readFileThunk(&#39;./apples.txt&#39;, &#39;utf8&#39;);</code> 语句的执行结果，即 r 的 <code>value</code> 属性是一个内部封装了 <code>[&#39;./apples.txt&#39;, &#39;utf8&#39;]</code> d的单参数的 fs.readFile 函数，即 r 的 <code>value</code> 属性是 fs.readFile(callback)函数</p><p>因此上面代码第三行 <code>r.value(function(err, data){...}</code> 等价于 <code>fs.readFile(function(err, data){...}</code>，此时才开始正式执行异步函数读取文件内容，读取到的内容通过第 5 行 <code>next</code> 方法传递给 Generator 函数里的 <code>r1</code>，打印出文件内容，之后就是重复上述套路</p><p>显然开发者不想用这样嵌套的调用方法，所以可以定义一个 <code>run</code> 方法将上面的调用代码封装起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">genFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> g = genFunc();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">        <span class="keyword">if</span> (result.done) <span class="keyword">return</span>;</span><br><span class="line">        result.value(next);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);    </span><br></pre></td></tr></table></figure><p>定义了 <code>run</code> 方法后，执行 Generator 函数就方便了很多，直接将 Generator 函数作为参数传动给 <code>run</code> 就行了，然后会自动像多米诺骨牌一样依次执行 Generator 函数内的异步操作，当然，前提是每一个异步操作，都要是 Thunk 函数，即 <code>yield</code> 命令后面的必须是 Thunk 函数</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Thunk 是什么？Thunk 应该如何被实现？Thunk 的真正用途是什么？在 JavaScript 异步编程的 Generator 实现中，Thunk 的作用是怎样的&lt;/center&gt;
    
    </summary>
    
      <category term="JavaScript异步执行" scheme="https://www.douglasdong.site/categories/JavaScript%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C/"/>
    
    
      <category term="JavaScript" scheme="https://www.douglasdong.site/tags/JavaScript/"/>
    
  </entry>
  
</feed>
